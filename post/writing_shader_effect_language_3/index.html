<!DOCTYPE html>
<html lang="en-us">

<head>

  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="generator" content="Source Themes Academic 4.4.0">

  

  
  
  
  
  
    
    
    
  
  

  <meta name="author" content="Gabriel Sassone">

  
  
  
    
  
  <meta name="description" content="Overview Data Driven Rendering Series:
 https://jorenjoestar.github.io/post/writing_shader_effect_language_1/ https://jorenjoestar.github.io/post/writing_shader_effect_language_2/ https://jorenjoestar.github.io/post/writing_shader_effect_language_3/ https://jorenjoestar.github.io/post/data_driven_rendering_pipeline/  In Part 2 of this series we added Resource Layouts and Properties to the HFX language, trying to arrive at a point in which we can describe the rendering of a Shader Effect almost entirely.In this article I would like to explore further adds to HFX, especially a proper Material System to be used in conjunction with the HFX language.">

  
  <link rel="alternate" hreflang="en-us" href="https://jorenjoestar.github.io/post/writing_shader_effect_language_3/">

  


  

  
  
  
  <meta name="theme-color" content="hsl(339, 90%, 68%)">
  

  
  
  
  
    
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/academicons/1.8.6/css/academicons.min.css" integrity="sha256-uFVgMKfistnJAfoCUQigIl+JfUaP47GrRKjf6CTPVmw=" crossorigin="anonymous">
    <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.6.0/css/all.css" integrity="sha384-aOkxzJ5uQz7WBObEZcHvV5JvRW3TUc2rNPA7pe3AwnsUohiw1Vj2Rgx2KSOkF5+h" crossorigin="anonymous">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.2.5/jquery.fancybox.min.css" integrity="sha256-ygkqlh3CYSUri3LhQxzdcm0n1EQvH2Y+U5S2idbLtxs=" crossorigin="anonymous">

    
    
    
      
    
    
      
      
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.6/styles/ocean.min.css" crossorigin="anonymous" title="hl-light">
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.6/styles/ocean.min.css" crossorigin="anonymous" title="hl-dark" disabled>
      
    

    

    

  

  
  
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Inconsolata&display=swap">
  

  
  
  
  <link rel="stylesheet" href="/css/academic.min.3c1397731166a1801db28da8c18494e1.css">

  

  
  
  

  

  <link rel="manifest" href="/site.webmanifest">
  <link rel="icon" type="image/png" href="/img/icon.png">
  <link rel="apple-touch-icon" type="image/png" href="/img/icon-192.png">

  <link rel="canonical" href="https://jorenjoestar.github.io/post/writing_shader_effect_language_3/">

  
  
  
  
    
    
  
  <meta property="twitter:card" content="summary">
  
  <meta property="twitter:site" content="@GabrielSassone">
  <meta property="twitter:creator" content="@GabrielSassone">
  
  <meta property="og:site_name" content="Gabriel&#39;s Virtual Tavern">
  <meta property="og:url" content="https://jorenjoestar.github.io/post/writing_shader_effect_language_3/">
  <meta property="og:title" content="Writing a Shader Effect Language Part 3: Materials | Gabriel&#39;s Virtual Tavern">
  <meta property="og:description" content="Overview Data Driven Rendering Series:
 https://jorenjoestar.github.io/post/writing_shader_effect_language_1/ https://jorenjoestar.github.io/post/writing_shader_effect_language_2/ https://jorenjoestar.github.io/post/writing_shader_effect_language_3/ https://jorenjoestar.github.io/post/data_driven_rendering_pipeline/  In Part 2 of this series we added Resource Layouts and Properties to the HFX language, trying to arrive at a point in which we can describe the rendering of a Shader Effect almost entirely.In this article I would like to explore further adds to HFX, especially a proper Material System to be used in conjunction with the HFX language."><meta property="og:image" content="https://jorenjoestar.github.io/img/icon-192.png">
  <meta property="twitter:image" content="https://jorenjoestar.github.io/img/icon-192.png"><meta property="og:locale" content="en-us">
  
  <meta property="article:published_time" content="2019-10-14T10:43:49-04:00">
  
  <meta property="article:modified_time" content="2019-12-19T10:58:49-04:00">
  

  

<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/cookieconsent2/3.0.3/cookieconsent.min.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/cookieconsent2/3.0.3/cookieconsent.min.js"></script>
<script>
  window.addEventListener("load", function(){
    window.cookieconsent.initialise({
      "palette": {
        "popup": {
          "background": "hsl(339, 90%, 68%)",
          "text": "#fff"
        },
        "button": {
          "background": "#fff",
          "text": "hsl(339, 90%, 68%)"
        }
      },
      "theme": "classic",
      "content": {
        "message": "This website uses cookies to ensure you get the best experience on our website.",
        "dismiss": "Got it!",
        "link": "Learn more",
        "href": "https://cookies.insites.com"
      }
    })});
</script>



  





  <title>Writing a Shader Effect Language Part 3: Materials | Gabriel&#39;s Virtual Tavern</title>

</head>

<body id="top" data-spy="scroll" data-offset="70" data-target="#TableOfContents" class="dark">

  <aside class="search-results" id="search">
  <div class="container">
    <section class="search-header">

      <div class="row no-gutters justify-content-between mb-3">
        <div class="col-6">
          <h1>Search</h1>
        </div>
        <div class="col-6 col-search-close">
          <a class="js-search" href="#"><i class="fas fa-times-circle text-muted" aria-hidden="true"></i></a>
        </div>
      </div>

      <div id="search-box">
        
        <input name="q" id="search-query" placeholder="Search..." autocapitalize="off"
        autocomplete="off" autocorrect="off" spellcheck="false" type="search">
        
      </div>

    </section>
    <section class="section-search-results">

      <div id="search-hits">
        
      </div>

    </section>
  </div>
</aside>


  
<nav class="navbar navbar-light fixed-top navbar-expand-lg py-0 compensate-for-scrollbar" id="navbar-main">
  <div class="container">

    
      <a class="navbar-brand" href="/">Gabriel&#39;s Virtual Tavern</a>
      
      <button type="button" class="navbar-toggler" data-toggle="collapse"
              data-target="#navbar" aria-controls="navbar" aria-expanded="false" aria-label="Toggle navigation">
        <span><i class="fas fa-bars"></i></span>
      </button>
      

    
    <div class="collapse navbar-collapse" id="navbar">

      
      
      <ul class="navbar-nav mr-auto">
        

        

        
        
        
          
        

        
        
        
        
        
        
          
          
          
            
          
          
        

        <li class="nav-item">
          <a class="nav-link " href="/#about"><span>Home</span></a>
        </li>

        
        

        

        
        
        
          
        

        
        
        
        
        
        
          
          
          
            
          
          
        

        <li class="nav-item">
          <a class="nav-link " href="/#posts"><span>Posts</span></a>
        </li>

        
        

        

        
        
        
          
        

        
        
        
        
        
        
          
          
          
            
          
          
        

        <li class="nav-item">
          <a class="nav-link " href="/#contact"><span>Contact</span></a>
        </li>

        
        

      
      </ul>
      <ul class="navbar-nav ml-auto">
      

        

        
        <li class="nav-item">
          <a class="nav-link js-search" href="#"><i class="fas fa-search" aria-hidden="true"></i></a>
        </li>
        

        

        
        <li class="nav-item">
          <a class="nav-link js-dark-toggle" href="#"><i class="fas fa-moon" aria-hidden="true"></i></a>
        </li>
        

      </ul>

    </div>
  </div>
</nav>


  <article class="article" itemscope itemtype="http://schema.org/Article">

  












  

  
  
  
<div class="article-container pt-3">
  <h1 itemprop="name">Writing a Shader Effect Language Part 3: Materials</h1>

  

  
    



<meta content="2019-10-14 10:43:49 -0400 -0400" itemprop="datePublished">
<meta content="2019-12-19 10:58:49 -0400 -0400" itemprop="dateModified">

<div class="article-metadata">

  
  

  
  <span class="article-date">
    
    
      
          Last updated on
      
    
    <time>2019-12-19</time>
  </span>
  

  

  
  <span class="middot-divider"></span>
  <span class="article-reading-time">
    21 min read
  </span>
  

  
  
  

  
  
  <span class="middot-divider"></span>
  <span class="article-categories">
    <i class="fas fa-folder"></i>
    <a href="/categories/coding/">coding</a></span>
  

  
    
<div class="share-box" aria-hidden="true">
  <ul class="share">
    
      
      
      
        
      
      
      
      <li>
        <a href="https://twitter.com/intent/tweet?url=https://jorenjoestar.github.io/post/writing_shader_effect_language_3/&amp;text=Writing%20a%20Shader%20Effect%20Language%20Part%203:%20Materials" target="_blank" rel="noopener" class="share-btn-twitter">
          <i class="fab fa-twitter"></i>
        </a>
      </li>
    
      
      
      
        
      
      
      
      <li>
        <a href="https://www.facebook.com/sharer.php?u=https://jorenjoestar.github.io/post/writing_shader_effect_language_3/&amp;t=Writing%20a%20Shader%20Effect%20Language%20Part%203:%20Materials" target="_blank" rel="noopener" class="share-btn-facebook">
          <i class="fab fa-facebook-f"></i>
        </a>
      </li>
    
      
      
      
        
      
      
      
      <li>
        <a href="mailto:?subject=Writing%20a%20Shader%20Effect%20Language%20Part%203:%20Materials&amp;body=https://jorenjoestar.github.io/post/writing_shader_effect_language_3/" target="_blank" rel="noopener" class="share-btn-email">
          <i class="fas fa-envelope"></i>
        </a>
      </li>
    
      
      
      
        
      
      
      
      <li>
        <a href="https://www.linkedin.com/shareArticle?url=https://jorenjoestar.github.io/post/writing_shader_effect_language_3/&amp;title=Writing%20a%20Shader%20Effect%20Language%20Part%203:%20Materials" target="_blank" rel="noopener" class="share-btn-linkedin">
          <i class="fab fa-linkedin-in"></i>
        </a>
      </li>
    
      
      
      
        
      
      
      
      <li>
        <a href="https://reddit.com/submit?url=https://jorenjoestar.github.io/post/writing_shader_effect_language_3/&amp;title=Writing%20a%20Shader%20Effect%20Language%20Part%203:%20Materials" target="_blank" rel="noopener" class="share-btn-reddit">
          <i class="fab fa-reddit-alien"></i>
        </a>
      </li>
    
  </ul>
</div>


  

</div>

    














  
</div>



  <div class="article-container">

    <div class="article-style" itemprop="articleBody">
      <h1 id="overview">Overview</h1>
<p>Data Driven Rendering Series:</p>
<ol>
<li><a href="https://jorenjoestar.github.io/post/writing_shader_effect_language_1/">https://jorenjoestar.github.io/post/writing_shader_effect_language_1/</a></li>
<li><a href="https://jorenjoestar.github.io/post/writing_shader_effect_language_2/">https://jorenjoestar.github.io/post/writing_shader_effect_language_2/</a></li>
<li><a href="https://jorenjoestar.github.io/post/writing_shader_effect_language_3/">https://jorenjoestar.github.io/post/writing_shader_effect_language_3/</a></li>
<li><a href="https://jorenjoestar.github.io/post/data_driven_rendering_pipeline/">https://jorenjoestar.github.io/post/data_driven_rendering_pipeline/</a></li>
</ol>
<p>In <a href="https://jorenjoestar.github.io/post/writing_shader_effect_language_2/">Part 2 of this series</a> we added Resource Layouts and Properties to the <strong>HFX</strong> language, trying to arrive at a point in which we can describe the rendering of a Shader Effect almost entirely.<!-- raw HTML omitted -->
In this article I would like to explore further adds to HFX, especially a proper <strong>Material System</strong> to be used in conjunction with the HFX language.<!-- raw HTML omitted -->
I also separated the code a little bit for clarity and added the usage of STB array and hash maps.<!-- raw HTML omitted -->
With that I would like to develop a Material System that is robust and easy to use, even though I am (DISCLAIMER!) far from it!<!-- raw HTML omitted --></p>
<p>I will first talk about the theory and thoughts behind those changes, and then go through the code changes and addition.</p>
<h1 id="material-system-thoughts">Material System thoughts</h1>
<p>Following a nomenclature from the amazing guys at <a href="https://ourmachinery.com/post/">our_machinery</a>, we are adding a <em>Tier 1 Shader System</em> - something that builds on top of the graphics API created in the previous article.</p>
<p>First of all, a great series of article is again on their website:</p>
<ul>
<li><a href="https://ourmachinery.com/post/the-machinery-shader-system-part-1/">https://ourmachinery.com/post/the-machinery-shader-system-part-1/</a></li>
<li><a href="https://ourmachinery.com/post/the-machinery-shader-system-part-2/">https://ourmachinery.com/post/the-machinery-shader-system-part-2/</a></li>
<li><a href="https://ourmachinery.com/post/the-machinery-shader-system-part-3/">https://ourmachinery.com/post/the-machinery-shader-system-part-3/</a></li>
</ul>
<p>We are building a Material System based on a graphics-API that exposes the following concepts:</p>
<ul>
<li>Buffer</li>
<li>Texture</li>
<li>Pipeline (that includes shaders)</li>
<li>Render Pass</li>
<li>Resource List Layout</li>
<li>Resource List</li>
</ul>
<p>We are using a Vulkan/D3D12 interface here, and these concepts map 1 to 1 with that.<!-- raw HTML omitted -->
One of the big changes from a typical low-level graphics API is both the &lsquo;missing&rsquo; concept of Shader as a resource, and the addition of Render Pass as resource.<!-- raw HTML omitted -->
A new concept is the one of <strong>Resource List Layout</strong> and <strong>Resource List</strong>.<!-- raw HTML omitted -->
The Vulkan names are <strong>Descriptor Set Layout</strong> and <strong>Descriptor Set</strong>, but even though they reflect more the underlying driver nature of the term, I changed to <strong>Resource List</strong> just to have it clearer as a concept.</p>
<p>The <strong>King</strong> here is the Pipeline: it is a structure that contains <strong>all the immutable data of a pipeline</strong>. That includes our missing <strong>shaders</strong>, all the <strong>render states</strong> (DepthStencil, AlphaBlend, &hellip;) and a <strong>Layout of the resources to be used by the shader</strong>.</p>
<p>Part of the <strong>dynamic</strong> pipeline states are normally the <strong>geometry</strong> and the <strong>resource lists</strong>.<!-- raw HTML omitted -->
Note that I am using the plural here: each <strong>pipeline</strong> can have 1 or more <strong>resource lists!!</strong>.<!-- raw HTML omitted -->
This is a good to organize your resources based on update frequencies, something coming from the numerous talks about Approaching Zero Driver Overhead.</p>
<p>Remembering the simple interface of our API, now we have the following:</p>
<pre tabindex="0"><code>struct Device {

	...

    BufferHandle                    create_buffer( const BufferCreation&amp; creation );
    TextureHandle                   create_texture( const TextureCreation&amp; creation );
    PipelineHandle                  create_pipeline( const PipelineCreation&amp; creation );
    SamplerHandle                   create_sampler( const SamplerCreation&amp; creation );
    ResourceListLayoutHandle        create_resource_list_layout( const ResourceListLayoutCreation&amp; creation );
    ResourceListHandle              create_resource_list( const ResourceListCreation&amp; creation );
    RenderPassHandle                create_render_pass( const RenderPassCreation&amp; creation );

    ...
};
</code></pre><p>If you look at the OpenGL implementation (the only I wrote for now :( ) you will find that Shaders are considered resources, but it is more for convenience of the attach/linking OpenGL need than anything else.</p>
<p>Let&rsquo;s finally introduce the new concept for this article!</p>
<h2 id="shader-effect">Shader Effect</h2>
<blockquote>
<p>A <strong>Shader Effect</strong> is the blueprint of <em>static</em> data needed to draw something on the screen.</p>
</blockquote>
<p>It needs to include <strong>shaders</strong> (included in a <strong>Pipeline Description</strong>), <strong>properties</strong> (coming from the HFX file) and find its location into a <strong>render graph</strong>.<!-- raw HTML omitted --></p>
<blockquote>
<p>A <strong>Shader Effect</strong> is 1 to 1 with a <strong>Binary HFX file</strong>.</p>
</blockquote>
<p>As a convenience we will add also informations about the <strong>local constants</strong>.<!-- raw HTML omitted -->
When creating a Shader Effect, we can define properties, and we put all the numerical properties into one buffer.</p>
<p>This is the current code:</p>
<pre tabindex="0"><code>
struct ShaderEffect {

    //
    //
    struct PropertiesMap {

        char*                       key;
        hfx::ShaderEffectFile::MaterialProperty* value;

    }; // struct PropertiesMap

    struct Pass {
        PipelineCreation            pipeline_creation;
        char                        name[32];
        PipelineHandle              pipeline_handle;
        uint32_t                    pool_id;
    }; // struct Pass

    Pass*                           passes;

    uint16_t                        num_passes              = 0;
    uint16_t                        num_properties          = 0;
    uint32_t                        local_constants_size    = 0;

    char*                           local_constants_default_data = nullptr;
    char*                           properties_data         = nullptr;

    PropertiesMap*                  name_to_property        = nullptr;

    char                            name[32];
    char                            pipeline_name[32];
    uint32_t                        pool_id;

}; // struct ShaderEffect

</code></pre><p>You see both a <strong>pipeline name</strong> and an array of <strong>passes</strong> with a name. These are to insert the pass into a very <strong>primordial</strong> render graph, that I wrote just because I didn&rsquo;t want to hardcode the frame structure, especially because next article will be EXACTLY on this topic!</p>
<p>Having defined the Shader Effect, we can now move into the next big actor.</p>
<h2 id="material">Material</h2>
<blockquote>
<p>A <strong>Material</strong> is an instance of a <strong>Shader Effect</strong>.</p>
</blockquote>
<p>Given a HFX file, we generate a new file (HMT, Hydra Material) that will contain all the informations.<!-- raw HTML omitted -->
The concept of Material is really <strong>unique values for the properties of a Shader Effect</strong>.</p>
<p>That is basically it.</p>
<p>For example, if a shader contains a property like an <em>albedo texture</em>, the material answer the question &ldquo;which albedo texture?&rdquo;.<!-- raw HTML omitted -->
This is done for every property.</p>
<p>Let&rsquo;s have a look at our new material:</p>
<pre tabindex="0"><code>{
    &quot;name&quot;: &quot;SimpleFullscreen&quot;,
    &quot;effect_path&quot;: &quot;SimpleFullscreen.hfx&quot;,
    &quot;properties&quot;: [
        {
            &quot;scale&quot;: 16.0,
            &quot;albedo&quot;: &quot;AngeloCensorship.png&quot;,
            &quot;modulo&quot;: 2.0
        }
    ],
    &quot;bindings&quot;: [
        {
            &quot;LocalConstants&quot;: &quot;LocalConstants&quot;,
            &quot;destination_texture&quot;: &quot;compute_output_texture&quot;,
            &quot;input_texture&quot;: &quot;compute_output_texture&quot;,
            &quot;albedo_texture&quot;: &quot;albedo&quot;
        }
    ]
}
</code></pre><p>As you can see there is a name, the effect path, the properties and the bindings. These will be explained in the next section.<!-- raw HTML omitted -->
Properties are just a name-value list, coming from the Shader Effect itself (the .bhfx file).</p>
<p>The texture is my horrible drawing after reading the fantastic <a href="http://c0de517e.blogspot.com/2019/08/engineering-career-guide-leaked.html">rendering guide by Angelo Pesce</a> and how he censored the parts that were internal to Roblox!</p>
<h2 id="shader-resource-database-and-lookup">Shader Resource Database and Lookup</h2>
<p>A concept that I saw only in the <strong>our_machinery</strong> posts, but I personally adopted since a couple of years, is a way of automating a daunting task: <em>setting shader resources</em>.</p>
<p>I still need to finish the correct implementation of those, but the concepts are simple.<!-- raw HTML omitted -->
A <strong>Shader Resource Database</strong> is a database of resources that can be searched using a <strong>Shader Resources Lookup</strong>.<!-- raw HTML omitted -->
The name of the binding is the shader related name, while the value is the name into the database.<!-- raw HTML omitted -->
Of course you can use hashes instead of names, and compile them into a binary version of this, but this is not important now.</p>
<p>One interesting bit (sadly not implemented here, sorry!) is the binding specialization. <!-- raw HTML omitted -->
This is done so that resources can be specialized in the database.<!-- raw HTML omitted -->
This is done per pass and it let you write only one binding list for all the Material, and then gather the proper resource based on the specialization.<!-- raw HTML omitted -->
For example if there is a binding for a pass-dependent resource, writing a generic version can specialize the shader pass correctly. Or using special keywords in the bindings, you can retrieve input/output textures from the render pass in which the shader is rendered!</p>
<p>For now though it is more a manual written list, but it will be developed further.</p>
<h1 id="where-is-my-code-">Where is my code ?</h1>
<p>Having introduced the new concept, let&rsquo;s look at the changes that happened in the last weeks of night coding.<!-- raw HTML omitted -->
As said before, in general I separated the code in header/cpp for clarity and building performances (after a good talk on Twitter, <a href="https://twitter.com/GabrielSassone/status/1179810419617275905?s=20)">https://twitter.com/GabrielSassone/status/1179810419617275905?s=20)</a>.</p>
<h2 id="applications">Applications</h2>
<p>First big changes was separating the code from the previous articles in an <em>application</em>: namely <strong>CustomShaderLanguageApplication</strong> in <strong>CustomShaderLanguage.h/cpp</strong> and <strong>MaterialSystemApplication</strong> in <strong>MaterialSystem.h/cpp</strong>.</p>
<p>The first contains all the application code that uses HDF and HFX, with code generation and HFX compilation.<!-- raw HTML omitted -->
The second contains both the new <strong>Material System</strong> and the application that uses it.<!-- raw HTML omitted -->
I would love to say that is an usable app, but I really touched my limits in non designing clearly when night coding.<!-- raw HTML omitted -->
<strong>Personal note: I hope this could be the spark to create a FX Composer successor, open source and free for all!</strong></p>
<h2 id="stb">STB</h2>
<p>As part of this experiment I wanted to try something different.<!-- raw HTML omitted -->
Instead of re-writing array and hash maps with templates, I wanted to give a try to the <a href="https://github.com/nothings/stb">STB libraries</a>: namely <strong>stb_ds.h</strong> and <strong>stb_image.h</strong>.<!-- raw HTML omitted -->
Arrays and Hash Maps are now included in hydra_lib.h to be used across the code.</p>
<h2 id="hydra-graphics">Hydra Graphics</h2>
<p>The device added render passes and the support for multiple resources layout.<!-- raw HTML omitted -->
It also creates FBOs for color passes and supports resize, especially thanks to the Render Pipeline.</p>
<h2 id="primitive-render-graph-called-render-pipeline">Primitive Render Graph (called Render Pipeline)</h2>
<p>I use the term I used since the inception in 2010, and honestly it is more true to what it does.<!-- raw HTML omitted -->
It is not a graph but more a list of <strong>Render Stages</strong> with input/outputs defined clearly.<!-- raw HTML omitted -->
In the next article I will develop more on this, but for now I needed some structure like this to be explicit.</p>
<p>In the application there are 3 pipelines, one for a single pass ShaderToy shader, one for a silly compute to framebuffer shader(that for now loads a texture and outputs it to the framebuffer), and one for just a render to window.</p>
<p>I use this in my indie project, with a fully custom and data driven (written in json) pipeline that includes compute deferred lighting and shadows, shadow passes, various post-process passes and such, everything very easy to debug and very easy to modify/add/delete.<!-- raw HTML omitted -->
There is a mechanism to send the correct draw calls to the correct pass through the usage of render systems, but again this will be a topic for the next article!</p>
<p>In the included code, there is also a small but powerful tool: a pipeline explorer.<!-- raw HTML omitted -->
For now it will just show the render targets for each stage, and in these simple examples does not matter much.<!-- raw HTML omitted -->
In the next article we will dive deep into the <strong>Render Pipeline/Graph</strong> subject and then all of this will make sense!</p>
<h1 id="break-a-simple-resource-manager">Break: a simple Resource Manager</h1>
<p>While being a very important topic, this is not the focus of this article.<!-- raw HTML omitted -->
Anyway I wanted a Resource Manager that would be helpful to handle resource creation and loading.<!-- raw HTML omitted -->
This includes also <em>resource compilation</em>, something that normally happens at <em>build time</em>, but in our exercise can be triggered at run-time.</p>
<p>The <strong>resource manager</strong> is a class that simply manages resources using <strong>factories</strong> and manages dependencies between resources.<!-- raw HTML omitted -->
We have only 3 resources for now:</p>
<ol>
<li>Textures</li>
<li>Shader Effects</li>
<li>Materials</li>
</ol>
<h2 id="resources">Resources</h2>
<p>A resource is a class that both has data and let the dependency with other data be clear.<!-- raw HTML omitted -->
The <strong>resource&rsquo;s data</strong> is actually a pointer to actual raw data used by other systems, in this case rendering.<!-- raw HTML omitted -->
Let&rsquo;s see its definition:</p>
<pre tabindex="0"><code>struct Resource {

    struct ResourceReference {
        uint8_t                     type;
        char                        path[255];
    }; // struct ResourceReference

    struct Header {

        char                        header[7];
        uint8_t                     type;   // ResourceType::enum

        size_t                      data_size;
        uint16_t                    num_external_references;
        uint16_t                    num_internal_references;
        
    }; // struct Header

    struct ResourceMap {
        char*                       key;
        Resource*                   value;
    };

    Header*                         header;
    char*                           data;
    void*                           asset;

    Resource::ResourceReference*    external_references;
    // External
    ResourceMap*                    name_to_external_resources;
    // Interal

}; // struct Resource
</code></pre><p>A resource is loaded from a binary file and contains a header and some data coming from the file, and an asset containing a system specific pointer.</p>
<p>We added 3 system specific resources (Texture, Shader Effect and Material) but the class handled is always resource.<!-- raw HTML omitted -->
To access the system specific data, asset member is used.</p>
<p>A resource contains also a map to the external resources loaded within it - to handle external references.</p>
<h2 id="compilation">Compilation</h2>
<p>Starting from a <em>source file</em> (.hfx, .png, .hmt) using the specific factory, the resource manager compiles the code to a binary resource.<!-- raw HTML omitted -->
This means both converting the source format to a binary representation but also adding <strong>external dependencies</strong> to the file.<!-- raw HTML omitted -->
These dependencies will be loaded when loading the resource, and before it.</p>
<h2 id="loading">Loading</h2>
<p>Loading happens by first loading all the dependent resources and then using the specific factory to load the <em>system specific</em> asset.<!-- raw HTML omitted -->
This is a very semplicistic resource management - synchronous only, single threaded, not optimized - so really was an exercise in having something running for both compiling a resource and managing dependencies.<!-- raw HTML omitted -->
The whole point is the separation between a source and human-readable format to a binary one and encapsulate this.</p>
<p>After this (very!) small break on resource management, let&rsquo;s continue to the actual code for the materials!</p>
<h1 id="material-system-implementation">Material System implementation</h1>
<p>After all this thory let&rsquo;s look at the code!<!-- raw HTML omitted --></p>
<h2 id="shader-effect-1">Shader Effect</h2>
<p>The main parts of a <strong>Shader Effect</strong> are <strong>Passes</strong> and <strong>Properties</strong>.<!-- raw HTML omitted -->
<strong>Passes</strong> are the most important one, as they contain all the informations to create an actual <strong>Pipeline</strong>, called <strong>Pipeline Creation</strong>.<!-- raw HTML omitted --></p>
<p>Remembering the Vulkan/DX12 interface, we cannot create singularly a shader, but we need all the pipeline data (depth stencil, alpha blend, &hellip;) to actually create the shaders too.</p>
<p>The gist here is to access all those informations in a hiearchical way, basically reading them from the RenderPipeline and then overwriting with what is defined in the HFX file.</p>
<p>Right now there is almost nothing if not the shaders, so the creation is quite simple:</p>
<pre tabindex="0"><code>for ( uint16_t p = 0; p &lt; shader_effect_file.header-&gt;num_passes; p++ ) {
    hfx::ShaderEffectFile::PassHeader* pass_header = hfx::get_pass( shader_effect_file, p );

    uint32_t shader_count = pass_header-&gt;num_shader_chunks;

    memcpy( effect-&gt;passes[p].name, pass_header-&gt;stage_name, 32 );

    PipelineCreation&amp; pipeline_creation = effect-&gt;passes[p].pipeline_creation;
    ShaderCreation&amp; creation = pipeline_creation.shaders;
    bool compute = false;

    // Create Shaders
    for ( uint16_t i = 0; i &lt; shader_count; i++ ) {
        hfx::get_shader_creation( pass_header, i, &amp;creation.stages[i] );

        if ( creation.stages[i].type == ShaderStage::Compute )
            compute = true;
    }

    creation.name = pass_header-&gt;name;
    creation.stages_count = shader_count;

    effect-&gt;passes[p].pipeline_creation.compute = compute;

    // Create Resource Set Layouts
    for ( uint16_t l = 0; l &lt; pass_header-&gt;num_resource_layouts; l++ ) {

        uint8_t num_bindings = 0;
        const ResourceListLayoutCreation::Binding* bindings = get_pass_layout_bindings( pass_header, l, num_bindings );
        ResourceListLayoutCreation resource_layout_creation = { bindings, num_bindings };

        pipeline_creation.resource_list_layout[l] = context.device.create_resource_list_layout( resource_layout_creation );

    }

    pipeline_creation.num_active_layouts = pass_header-&gt;num_resource_layouts;

    // Create Pipeline
    effect-&gt;passes[p].pipeline_handle = context.device.create_pipeline( pipeline_creation );
    if ( effect-&gt;passes[p].pipeline_handle.handle == k_invalid_handle ) {
        invalid_effect = true;
        break;
    }
}
</code></pre><p>When we will have a proper RenderPipeline, we will get the basic pipeline creation from there, and overwrite the shaders and states that will be defined in the HFX.</p>
<p>There are 3 main steps here:</p>
<ol>
<li>Create Shaders</li>
<li>Create Resource Set Layouts</li>
<li>Create Pipelines</li>
</ol>
<p>These are simple operations that rely heavily on the device.<!-- raw HTML omitted -->
The objective of the HFX is to embed most information possible to create a complete pipeline.</p>
<p>Another important step is to populate the properties map:</p>
<pre tabindex="0"><code>string_hash_init_arena( effect-&gt;name_to_property );

for ( uint32_t p = 0; p &lt; effect-&gt;num_properties; ++p ) {
    hfx::ShaderEffectFile::MaterialProperty* property = hfx::get_property( effect-&gt;properties_data, p );

    string_hash_put( effect-&gt;name_to_property, property-&gt;name, property );
}
</code></pre><p>We are using the STB String Hashmap here with the property that are inside the shader effect file. Those will contain the type, name for UI and the pointer to a default value. <!-- raw HTML omitted -->
The default value will be used based on the type of course.</p>
<p>We are also saving the local constant buffer size, so that we can allocate some memory in the Material and alter its property using the UI.</p>
<p>We will see the importance of this next.</p>
<h2 id="material-1">Material</h2>
<pre tabindex="0"><code>struct ShaderInstance {

    PipelineHandle                  pipeline;
    ResourceListHandle              resource_lists[hydra::graphics::k_max_resource_layouts];

    uint32_t                        num_resource_lists;
}; // struct ShaderInstance

struct Material {

    ShaderInstance*                 shader_instances        = nullptr;
    uint32_t                        num_instances           = 0;

    ShaderResourcesLookup           lookups; // Per-pass resource lookup. Same count as shader instances.
    ShaderEffect*                   effect                  = nullptr;

    BufferHandle                    local_constants_buffer;
    char*                           local_constants_data    = nullptr;

    const char*                     name                    = nullptr;
    StringBuffer                    loaded_string_buffer;
    
    uint32_t                        num_textures            = 0;
    uint32_t                        pool_id                 = 0;

    Texture**                       textures                = nullptr;

}; // struct Material
</code></pre><p>This is the glue to actually render something on the screen.<!-- raw HTML omitted -->
As a recap, we need 3 informations to render something:</p>
<ol>
<li>Pipeline (shaders + render states)</li>
<li>Resources (handles to buffers and textures)</li>
<li>Geometry (in this case a fullscreen quad)</li>
</ol>
<p>Material gives all those informations.</p>
<p>A <strong>Shader Instance</strong> is defined for each <strong>pass</strong>, and actually contains the Pipeline Handle and the <strong>List of Resource Lists</strong> to be used.<!-- raw HTML omitted -->
This is one of the new concepts for Vulkan/DX12: you can use one of more lists of resources to render, and normally it is better to group them by frequency.</p>
<p>Finally, a list of <strong>textures</strong> is saved to be modified by the editor.</p>
<p>To understand more the process, let&rsquo;s look at the loading code of a Material.</p>
<pre tabindex="0"><code>void* MaterialFactory::load( LoadContext&amp; context ) {
    
    using namespace hydra::graphics;

    // 1. Read header from file
    MaterialFile material_file;
    material_file.header = (MaterialFile::Header*)context.data;
    material_file.property_array = (MaterialFile::Property*)(context.data + sizeof( MaterialFile::Header ));
    material_file.binding_array = (MaterialFile::Binding*)(context.data + sizeof( MaterialFile::Header ) + sizeof( MaterialFile::Property ) * material_file.header-&gt;num_properties);
</code></pre><p>We are using the data from the material file to access properties and bindings.<!-- raw HTML omitted -->
Properties are both numerical and path to textures, bindings are name to retrieve resources from the database. We will look into that later.</p>
<pre tabindex="0"><code>    // 2. Read shader effect
    Resource* shader_effect_resource = string_hash_get( context.resource-&gt;name_to_external_resources, material_file.header-&gt;hfx_filename );
    ShaderEffect* shader_effect = shader_effect_resource ? (ShaderEffect*)shader_effect_resource-&gt;asset : nullptr;
    if ( !shader_effect ) {
        return nullptr;
    }

    // 3. Search pipeline
    RenderPipeline* render_pipeline = string_hash_get( context.name_to_render_pipeline, shader_effect-&gt;pipeline_name );
    if ( !render_pipeline ) {
        return nullptr;
    }

</code></pre><p>Access the Shader Effect through the resource dependencies, and the Render Pipeline from the map.</p>
<pre tabindex="0"><code>    // 4. Load material
    char* material_name = material_file.header-&gt;name;
    uint32_t pool_id = materials_pool.obtain_resource();
    Material* material = new (materials_pool.access_resource(pool_id))Material();
    material-&gt;loaded_string_buffer.init( 1024 );
    material-&gt;pool_id = pool_id;

    // TODO: for now just have one lookup shared.
    material-&gt;lookups.init();
    // TODO: properly specialize.
    // For each pass
    //for ( uint32_t i = 0; i &lt; effect-&gt;num_pipelines; i++ ) {
    //    PipelineCreation&amp; pipeline = effect-&gt;pipelines[i];
    //    //final ShaderBindings specializedBindings = bindings.specialize( shaderTechnique.passName, shaderTechnique.viewName );
    //    //shaderBindings.add( specializedBindings );
    //}

    material-&gt;effect = shader_effect;
    material-&gt;num_instances = shader_effect-&gt;num_passes;
    material-&gt;shader_instances = new ShaderInstance[shader_effect-&gt;num_passes];
    material-&gt;name = material-&gt;loaded_string_buffer.append_use( material_name );
    material-&gt;num_textures = material_file.header-&gt;num_textures;
    material-&gt;textures = (Texture**)hydra::hy_malloc( sizeof( Texture* ) * material-&gt;num_textures );
</code></pre><p>Here is the meaty part.<!-- raw HTML omitted -->
We create the Material, initialize a StringBuffer used to store all the names found in the file, init the db-&gt;resource lookup and create the ShaderInstance array.</p>
<pre tabindex="0"><code>    // Init memory for local constants
    material-&gt;local_constants_data = (char*)hydra::hy_malloc( shader_effect-&gt;local_constants_size );
    // Copy default values to init to sane valuess
    memcpy( material-&gt;local_constants_data, material-&gt;effect-&gt;local_constants_default_data, material-&gt;effect-&gt;local_constants_size );
</code></pre><p>We cached the constant data size to allocate its memory, and we copy the default values in it.
This memory will be overwritten by the other numerical properties and used to initialize the local constant buffer.</p>
<pre tabindex="0"><code>    // Add properties
    uint32_t current_texture = 0;
    for ( size_t p = 0; p &lt; material_file.header-&gt;num_properties; ++p ) {
        MaterialFile::Property&amp; property = material_file.property_array[p];

        hfx::ShaderEffectFile::MaterialProperty* material_property = string_hash_get( material-&gt;effect-&gt;name_to_property, property.name );

        switch ( material_property-&gt;type ) {
            case hfx::Property::Texture2D:
            {
                const char* texture_path = material-&gt;loaded_string_buffer.append_use( property.data );
                Resource* texture_resource = string_hash_get( context.resource-&gt;name_to_external_resources, texture_path );
                Texture* texture = (Texture*)texture_resource-&gt;asset;
                texture-&gt;filename = texture_path;

                render_pipeline-&gt;resource_database.register_texture( property.name, texture-&gt;handle );

                material-&gt;textures[current_texture] = texture;

                ++current_texture;

                break;
            }

            case hfx::Property::Float:
            {
                memcpy( material-&gt;local_constants_data + material_property-&gt;offset, property.data, sizeof( float ) );
                break;
            }
        }
    }
</code></pre><p>When cycling through the properties, we are copying the numerical properties into the newly allocated memory (local_constant_data) and we load the textures from the dependencies.</p>
<pre tabindex="0"><code>     // Add bindings
    for ( size_t b = 0; b &lt; material_file.header-&gt;num_bindings; ++b ) {
        MaterialFile::Binding&amp; binding = material_file.binding_array[b];

        char* name = material-&gt;loaded_string_buffer.append_use( binding.name );
        char* value = material-&gt;loaded_string_buffer.append_use( binding.value );
        material-&gt;lookups.add_binding_to_resource( name, value );
    }

</code></pre><p>We populate the resource lookups.</p>
<pre tabindex="0"><code>    BufferCreation checker_constants_creation = {};
    checker_constants_creation.type = BufferType::Constant;
    checker_constants_creation.name = s_local_constants_name;
    checker_constants_creation.usage = ResourceUsageType::Dynamic;
    checker_constants_creation.size = shader_effect-&gt;local_constants_size;
    checker_constants_creation.initial_data = material-&gt;local_constants_data;

    material-&gt;local_constants_buffer = context.device.create_buffer( checker_constants_creation );
    render_pipeline-&gt;resource_database.register_buffer( (char*)s_local_constants_name, material-&gt;local_constants_buffer );
</code></pre><p>Generate the actual constant buffer.</p>
<pre tabindex="0"><code>    // Bind material resources
    update_material_resources( material, render_pipeline-&gt;resource_database, context.device );
</code></pre><p>And finally search the bindings for the resources.<!-- raw HTML omitted --></p>
<pre tabindex="0"><code>static void update_material_resources( hydra::graphics::Material* material, hydra::graphics::ShaderResourcesDatabase&amp; database, hydra::graphics::Device&amp; device ) {

    using namespace hydra::graphics;

    // Create resource list
    // Get all resource handles from the database.
    ResourceListCreation::Resource resources_handles[k_max_resources_per_list];

    // For each pass
    for ( uint32_t i = 0; i &lt; material-&gt;effect-&gt;num_passes; i++ ) {
        PipelineCreation&amp; pipeline = material-&gt;effect-&gt;passes[i].pipeline_creation;

        for ( uint32_t l = 0; l &lt; pipeline.num_active_layouts; ++l ) {
            // Get resource layout description
            ResourceListLayoutDescription layout;
            device.query_resource_list_layout( pipeline.resource_list_layout[l], layout );

            // For each resource
            for ( uint32_t r = 0; r &lt; layout.num_active_bindings; r++ ) {
                const ResourceBinding&amp; binding = layout.bindings[r];

                // Find resource name
                // Copy string_buffer 
                char* resource_name = material-&gt;lookups.find_resource( (char*)binding.name );

                switch ( binding.type ) {
                    case hydra::graphics::ResourceType::Constants:
                    case hydra::graphics::ResourceType::Buffer:
                    {
                        BufferHandle handle = resource_name ? database.find_buffer( resource_name ) : device.get_dummy_constant_buffer();
                        resources_handles[r].handle = handle.handle;

                        break;
                    }

                    case hydra::graphics::ResourceType::Texture:
                    case hydra::graphics::ResourceType::TextureRW:
                    {
                        TextureHandle handle = resource_name ? database.find_texture( resource_name ) : device.get_dummy_texture();
                        resources_handles[r].handle = handle.handle;

                        break;
                    }

                    default:
                    {
                        break;
                    }
                }
            }

            ResourceListCreation creation = { pipeline.resource_list_layout[l], resources_handles, layout.num_active_bindings };
            material-&gt;shader_instances[i].resource_lists[l] = device.create_resource_list( creation );
        }
        material-&gt;shader_instances[i].num_resource_lists = pipeline.num_active_layouts;
        material-&gt;shader_instances[i].pipeline = material-&gt;effect-&gt;passes[i].pipeline_handle;
    }
}

</code></pre><p>For each Pass, Resource Layout and Binding, we search the Database to retrieve the actual resource and create the Resource List.</p>
<p>This can be improved - having a global database of resources and a &lsquo;local&rsquo; one based on material resources.<!-- raw HTML omitted --></p>
<pre tabindex="0"><code>    // 5. Bind material to pipeline
    for ( uint8_t p = 0; p &lt; shader_effect-&gt;num_passes; ++p ) {
        char* stage_name = shader_effect-&gt;passes[p].name;
        hydra::graphics::RenderStage* stage = string_hash_get( render_pipeline-&gt;name_to_stage, stage_name );

        if ( stage ) {
            stage-&gt;material = material;
            stage-&gt;pass_index = (uint8_t)p;
        }
    }

    return material;
}
</code></pre><p>Finally, and this is hacky, we assing the current material and pass index to the found stage.<!-- raw HTML omitted -->
Once we have the real Render Pipeline/Graph working, we will use another dispatching mechanism.</p>
<h1 id="rendering-of-a-material">Rendering of a Material</h1>
<p>After all of this we finally have created a Material.<!-- raw HTML omitted -->
But how can we render it ?<!-- raw HTML omitted -->
The magic here happens in a <strong>Render Pipeline</strong>!<!-- raw HTML omitted -->
A Render Pipeline is a list of Render Stages and some resources with it. In this case resources are the <strong>render targets</strong> and the <strong>buffers</strong> that are shared amongst <strong>Stages</strong> (and Render Systems in the future).<!-- raw HTML omitted -->
Resources are inside a <strong>Shader Resources Database</strong> and they can be retrieved using a <strong>Shader Resource Lookup</strong>.</p>
<p>Each <strong>Render Stage</strong> has defined a list of input and output textures plus some resize data. This data is needed to recreate textures when a resize event arrives if needed, or change size if an option is changed (like a Shadow Map resolution option).<!-- raw HTML omitted -->
As everthing in this articles, this is primordial and simple, but I think is a very good start, especially from a mindset perspective.</p>
<p>In this simple scenario we render 1 material only, and normally it simply 1 <em>Material Pass</em> for each <em>Render Stage Pass</em>, rendering either using a fullscreen quad or through compute.</p>
<p>There are 2 pipelines, both simple and used as a test, one is for a <em>ShaderToy</em> shader that I use as test, the other as a compute only pipeline. They are both hardcoded and created at the beginning of the <em>Material Application</em>, but as said before, it should be data-driven and reloadable to have great rendering power.</p>
<h2 id="rendering-of-a-pipeline">Rendering of a Pipeline</h2>
<p>The code is simple:</p>
<pre tabindex="0"><code>void RenderPipeline::render( CommandBuffer* commands ) {

    for ( size_t i = 0; i &lt; string_hash_length( name_to_stage ); i++ ) {

        RenderStage* stage = name_to_stage[i].value;
        stage-&gt;begin( commands );
        stage-&gt;render( commands );
        stage-&gt;end( commands );
    }
}
</code></pre><p>We cycle through each stage and render.<!-- raw HTML omitted --></p>
<pre tabindex="0"><code>void RenderStage::begin( CommandBuffer* commands ) {
    commands-&gt;begin_submit( 0 );
    commands-&gt;begin_pass( render_pass );
    commands-&gt;set_viewport( { 0, 0, (float)current_width, (float)current_height, 0.0f, 1.0f } );
    if ( clear_rt ) {
        commands-&gt;clear( clear_color[0], clear_color[1], clear_color[2], clear_color[3] );
    }
    commands-&gt;end_submit();
    // Set render stage states (depth, alpha, ...)
}

</code></pre><p>Before rendering anything this code will bind the correct FBO/Render Targets, clear and set viewport and set render states.<!-- raw HTML omitted -->
After this we are ready to render the actual stage. In this simple implementation we have only 3 type of stages: Compute, Post and Swapchain.<!-- raw HTML omitted --></p>
<p>They are very simple and similar, like this:</p>
<pre tabindex="0"><code>commands-&gt;begin_submit( pass_index );
commands-&gt;bind_pipeline( shader_instance.pipeline );
commands-&gt;bind_resource_list( &amp;shader_instance.resource_lists[0], shader_instance.num_resource_lists );
commands-&gt;draw( graphics::TopologyType::Triangle, 0, 3 );
commands-&gt;end_submit();
</code></pre><p>Set the pipeline, bind all the different resource lists and issue the draw (in this case a full screen triangle).</p>
<h1 id="included-in-the-code">Included in the code</h1>
<h2 id="material-application">Material application</h2>
<p>I just added a simple Material Application to render the content of one of those simple shaders.</p>
<p>Honestly not very happy about the code quality - and you can see why trying to add big features like memory management or multi-threading is a no-go.</p>
<p>The application let you switch between <strong>materials</strong> by right clicking on the <strong>.hmt</strong> file.<!-- raw HTML omitted -->
The whole purpose is to explore with the given code a couple of materials and their dependencies.<!-- raw HTML omitted --></p>
<p><a href="https://www.shadertoy.com/view/XlfGRj">Starnest</a> is a shader by the amazing <a href="https://www.deviantart.com/fractkali"><strong>Pablo Roman Andrioli</strong></a>, so all credits are to him! I wanted something beautiful to show in this simple example from ShaderToy.</p>
<h1 id="conclusions-and-some-thoughts">Conclusions and some thoughts</h1>
<p>We added a simple material system based on our HFX language.<!-- raw HTML omitted -->
Interestingly enough code generation is used much less - if almost nothing - instead of serializing data into files and using them.<!-- raw HTML omitted -->
As stated in the other articles, the goal is to have a parsing and code generation knowledge under your belt, and understand when it is time to use it!<!-- raw HTML omitted -->
We also introduced a lot of connections to other topics that are lengthy enough - like resource management - that need more time and dedication to properly be explored.<!-- raw HTML omitted -->
I am continuing working on this until it will become my <em>rendering explorer</em> - a tool I can use to easily explore ideas, much like <strong>ShaderToy</strong> but in an even more powerful way.<!-- raw HTML omitted -->
How ?<!-- raw HTML omitted -->
In the next article we will explore the final piece of the puzzle, and then we will probably start iterating and improving on what we have!<!-- raw HTML omitted -->
We will see how we can describe a frame and the rendering dependencies in an easy way, especially if done since the beginning, and how much having that knowledge upfront is GREAT to work on rendering.<!-- raw HTML omitted --></p>
<p>I am honestly not happy about the overall architecture though - here you have an example of <em>exploring code</em> - code written to explore a specific subject, and after venturing more into it you want to rewrite it.<!-- raw HTML omitted -->
To properly rewrite it you need to create solid foundations - namely <strong>Memory Management, Multi-Threading, Basic Data Structures, &hellip;</strong> and choose to pick your battles!</p>
<p>This is a huge lesson: pick your battles, choose what to concentrate on.<!-- raw HTML omitted -->
These articles are more towards code generation and rendering, but defining the constraints of the articles helps in narrowing down what to do.<!-- raw HTML omitted -->
If, as I would like, you want to use this code to evolve into something like a &lsquo;desktop&rsquo; Shadertoy, then you can&rsquo;t ignore all the foundational topics.<!-- raw HTML omitted -->
On the other end if you just quickly want to experiment with those topics, this should suffice.<!-- raw HTML omitted --></p>
<p>I have two paths here: rewriting most of this code with a solid foundations, and delaying a RenderPipeline/Graph article, or finishing with this architecture and then re-write everything with the &lsquo;desktop Shadertoy&rsquo;.<!-- raw HTML omitted -->
Again, pick your battles :)</p>
<p>As always, please comment, feedback, share!<!-- raw HTML omitted -->
I really hope soon there will be some <em>rendering joy</em>!</p>
<p>Gabriel</p>

    </div>

    


    

<div class="article-tags">
  
  <a class="badge badge-light" href="/tags/shaders/">shaders</a>
  
</div>



    
      








  





  
  
  
    
  
  
  <div class="media author-card" itemscope itemtype="http://schema.org/Person">
    
      
      <img class="portrait mr-3" src="/authors/admin/avatar_hud465246e9f9c1d8ddb2723f337b10400_187705_250x250_fill_q90_lanczos_center.jpg" itemprop="image" alt="Avatar">
    

    <div class="media-body">
      <h5 class="card-title" itemprop="name"><a href="https://jorenjoestar.github.io/">Gabriel Sassone</a></h5>
      <h6 class="card-subtitle">Principal Rendering/Engine Programmer</h6>
      
      <ul class="network-icon" aria-hidden="true">
        
          
          
          
            
          
          
          
          
          
            
          
          <li>
            <a itemprop="sameAs" href="https://twitter.com/GabrielSassone" target="_blank" rel="noopener">
              <i class="fab fa-twitter"></i>
            </a>
          </li>
        
          
          
          
            
          
          
          
          
          
            
          
          <li>
            <a itemprop="sameAs" href="https://bsky.app/profile/gabrielsassone.bsky.social" target="_blank" rel="noopener">
              <i class="fab fa-mastodon"></i>
            </a>
          </li>
        
          
          
          
            
          
          
          
          
          
            
          
          <li>
            <a itemprop="sameAs" href="https://mastodon.gamedev.place/@GabrielSassone" target="_blank" rel="noopener">
              <i class="fab fa-mastodon"></i>
            </a>
          </li>
        
          
          
          
            
          
          
          
          
          
            
          
          <li>
            <a itemprop="sameAs" href="https://github.com/JorenJoestar" target="_blank" rel="noopener">
              <i class="fab fa-github"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>



      
      
      <div class="article-widget">
        <div class="hr-light"></div>
        <h3>Related</h3>
        <ul>
          
          <li><a href="/post/writing_shader_effect_language_2/">Writing a Shader Effect Language Part 2</a></li>
          
          <li><a href="/post/writing_shader_effect_language_1/">Writing a Shader Effect Language Part 1</a></li>
          
        </ul>
      </div>
      
    

    

    


  </div>
</article>

      

    
    
    
    <script src="/js/mathjax-config.js"></script>
    

    
    
    
      <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js" integrity="sha256-CSXorXvZcTkaix6Yvo6HppcZGetbYMGWSFlBw8HfCJo=" crossorigin="anonymous"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery.imagesloaded/4.1.4/imagesloaded.pkgd.min.js" integrity="sha256-lqvxZrPLtfffUl2G/e7szqSvPBILGbwmsGE1MKlOi0Q=" crossorigin="anonymous"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery.isotope/3.0.6/isotope.pkgd.min.js" integrity="sha256-CBrpuqrMhXwcLLUd5tvQ4euBHCdh7wGlDfNz8vbu/iI=" crossorigin="anonymous"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.2.5/jquery.fancybox.min.js" integrity="sha256-X5PoE3KU5l+JcX+w09p/wHl9AzK333C4hJ2I9S5mD4M=" crossorigin="anonymous"></script>

      
        <script src="https://cdnjs.cloudflare.com/ajax/libs/mermaid/8.0.0/mermaid.min.js" integrity="sha256-0w92bcB21IY5+rGI84MGj52jNfHNbXVeQLrZ0CGdjNY=" crossorigin="anonymous" title="mermaid"></script>
      

      
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.6/highlight.min.js" integrity="sha256-aYTdUrn6Ow1DDgh5JTc3aDGnnju48y/1c8s1dgkYPQ8=" crossorigin="anonymous"></script>
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.6/languages/cpp.min.js"></script>
        
      

      
      
      <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=TeX-AMS_CHTML-full" integrity="sha256-GhM+5JHb6QUzOQPXSJLEWP7R73CbkisjzK5Eyij4U9w=" crossorigin="anonymous" async></script>
      
    

    
    

    
    
    <script>hljs.initHighlightingOnLoad();</script>
    

    
    
    <script>
      const search_index_filename = "/index.json";
      const i18n = {
        'placeholder': "Search...",
        'results': "results found",
        'no_results': "No results found"
      };
      const content_type = {
        'post': "Posts",
        'project': "Projects",
        'publication' : "Publications",
        'talk' : "Talks"
        };
    </script>
    

    
    

    
    
    <script id="search-hit-fuse-template" type="text/x-template">
      <div class="search-hit" id="summary-{{key}}">
      <div class="search-hit-content">
        <div class="search-hit-name">
          <a href="{{relpermalink}}">{{title}}</a>
          <div class="article-metadata search-hit-type">{{type}}</div>
          <p class="search-hit-description">{{snippet}}</p>
        </div>
      </div>
      </div>
    </script>
    

    
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/fuse.js/3.2.1/fuse.min.js" integrity="sha256-VzgmKYmhsGNNN4Ph1kMW+BjoYJM2jV5i4IlFoeZA9XI=" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mark.js/8.11.1/jquery.mark.min.js" integrity="sha256-4HLtjeVgH0eIB3aZ9mLYF6E8oU5chNdjU6p6rrXpl9U=" crossorigin="anonymous"></script>
    

    
    

    
    
    
    
    
    
    
    
    
      
    
    
    
    
    <script src="/js/academic.min.5fde6b67896bd1833c4041260289785f.js"></script>

    






  
  <div class="container">
    <footer class="site-footer">
  

  <p class="powered-by">
    

    Powered by the
    <a href="https://sourcethemes.com/academic/" target="_blank" rel="noopener">Academic theme</a> for
    <a href="https://gohugo.io" target="_blank" rel="noopener">Hugo</a>.

    
    <span class="float-right" aria-hidden="true">
      <a href="#" id="back_to_top">
        <span class="button_icon">
          <i class="fas fa-chevron-up fa-2x"></i>
        </span>
      </a>
    </span>
    
  </p>
</footer>

  </div>
  

  
<div id="modal" class="modal fade" role="dialog">
  <div class="modal-dialog">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title">Cite</h5>
        <button type="button" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body">
        <pre><code class="tex hljs"></code></pre>
      </div>
      <div class="modal-footer">
        <a class="btn btn-outline-primary my-1 js-copy-cite" href="#" target="_blank">
          <i class="fas fa-copy"></i> Copy
        </a>
        <a class="btn btn-outline-primary my-1 js-download-cite" href="#" target="_blank">
          <i class="fas fa-download"></i> Download
        </a>
        <div id="modal-error"></div>
      </div>
    </div>
  </div>
</div>

</body>
</html>
