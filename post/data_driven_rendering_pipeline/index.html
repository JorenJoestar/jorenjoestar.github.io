<!DOCTYPE html>
<html lang="en-us">

<head>

  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="generator" content="Source Themes Academic 4.4.0">

  

  
  
  
  
  
    
    
    
  
  

  <meta name="author" content="Gabriel Sassone">

  
  
  
    
  
  <meta name="description" content="Overview   Model used in the demo.   Data Driven Rendering Series:
 https://jorenjoestar.github.io/post/writing_shader_effect_language_1/ https://jorenjoestar.github.io/post/writing_shader_effect_language_2/ https://jorenjoestar.github.io/post/writing_shader_effect_language_3/ https://jorenjoestar.github.io/post/data_driven_rendering_pipeline/  We finally arrived in the Rendering Pipeline realm.Some can write that it is useless, some can hate it.Many have some sort of abstraction for it since ages, and others have to now that new APIs like Vulkan and DX12 have it as an explicit part of their design (finally!).
After we built a basic Material System in the previous article (https://jorenjoestar.">

  
  <link rel="alternate" hreflang="en-us" href="https://jorenjoestar.github.io/post/data_driven_rendering_pipeline/">

  


  

  
  
  
  <meta name="theme-color" content="hsl(339, 90%, 68%)">
  

  
  
  
  
    
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/academicons/1.8.6/css/academicons.min.css" integrity="sha256-uFVgMKfistnJAfoCUQigIl+JfUaP47GrRKjf6CTPVmw=" crossorigin="anonymous">
    <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.6.0/css/all.css" integrity="sha384-aOkxzJ5uQz7WBObEZcHvV5JvRW3TUc2rNPA7pe3AwnsUohiw1Vj2Rgx2KSOkF5+h" crossorigin="anonymous">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.2.5/jquery.fancybox.min.css" integrity="sha256-ygkqlh3CYSUri3LhQxzdcm0n1EQvH2Y+U5S2idbLtxs=" crossorigin="anonymous">

    
    
    
      
    
    
      
      
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.6/styles/ocean.min.css" crossorigin="anonymous" title="hl-light">
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.6/styles/ocean.min.css" crossorigin="anonymous" title="hl-dark" disabled>
      
    

    

    

  

  
  
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Inconsolata&display=swap">
  

  
  
  
  <link rel="stylesheet" href="/css/academic.min.58e9e3ea16c6b921b0163e93b88cfa1f.css">

  

  
  
  

  

  <link rel="manifest" href="/site.webmanifest">
  <link rel="icon" type="image/png" href="/img/icon.png">
  <link rel="apple-touch-icon" type="image/png" href="/img/icon-192.png">

  <link rel="canonical" href="https://jorenjoestar.github.io/post/data_driven_rendering_pipeline/">

  
  
  
  
    
    
  
  <meta property="twitter:card" content="summary">
  
  <meta property="twitter:site" content="@GabrielSassone">
  <meta property="twitter:creator" content="@GabrielSassone">
  
  <meta property="og:site_name" content="Joren&#39;s">
  <meta property="og:url" content="https://jorenjoestar.github.io/post/data_driven_rendering_pipeline/">
  <meta property="og:title" content="Data Driven Rendering: Pipelines | Joren&#39;s">
  <meta property="og:description" content="Overview   Model used in the demo.   Data Driven Rendering Series:
 https://jorenjoestar.github.io/post/writing_shader_effect_language_1/ https://jorenjoestar.github.io/post/writing_shader_effect_language_2/ https://jorenjoestar.github.io/post/writing_shader_effect_language_3/ https://jorenjoestar.github.io/post/data_driven_rendering_pipeline/  We finally arrived in the Rendering Pipeline realm.Some can write that it is useless, some can hate it.Many have some sort of abstraction for it since ages, and others have to now that new APIs like Vulkan and DX12 have it as an explicit part of their design (finally!).
After we built a basic Material System in the previous article (https://jorenjoestar."><meta property="og:image" content="https://jorenjoestar.github.io/img/icon-192.png">
  <meta property="twitter:image" content="https://jorenjoestar.github.io/img/icon-192.png"><meta property="og:locale" content="en-us">
  
  <meta property="article:published_time" content="2019-10-14T10:43:49-04:00">
  
  <meta property="article:modified_time" content="2020-02-22T10:58:49-04:00">
  

  

<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/cookieconsent2/3.0.3/cookieconsent.min.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/cookieconsent2/3.0.3/cookieconsent.min.js"></script>
<script>
  window.addEventListener("load", function(){
    window.cookieconsent.initialise({
      "palette": {
        "popup": {
          "background": "hsl(339, 90%, 68%)",
          "text": "#fff"
        },
        "button": {
          "background": "#fff",
          "text": "hsl(339, 90%, 68%)"
        }
      },
      "theme": "classic",
      "content": {
        "message": "This website uses cookies to ensure you get the best experience on our website.",
        "dismiss": "Got it!",
        "link": "Learn more",
        "href": "https://cookies.insites.com"
      }
    })});
</script>



  





  <title>Data Driven Rendering: Pipelines | Joren&#39;s</title>

</head>

<body id="top" data-spy="scroll" data-offset="70" data-target="#TableOfContents" class="dark">

  <aside class="search-results" id="search">
  <div class="container">
    <section class="search-header">

      <div class="row no-gutters justify-content-between mb-3">
        <div class="col-6">
          <h1>Search</h1>
        </div>
        <div class="col-6 col-search-close">
          <a class="js-search" href="#"><i class="fas fa-times-circle text-muted" aria-hidden="true"></i></a>
        </div>
      </div>

      <div id="search-box">
        
        <input name="q" id="search-query" placeholder="Search..." autocapitalize="off"
        autocomplete="off" autocorrect="off" spellcheck="false" type="search">
        
      </div>

    </section>
    <section class="section-search-results">

      <div id="search-hits">
        
      </div>

    </section>
  </div>
</aside>


  
<nav class="navbar navbar-light fixed-top navbar-expand-lg py-0 compensate-for-scrollbar" id="navbar-main">
  <div class="container">

    
      <a class="navbar-brand" href="/">Joren&#39;s</a>
      
      <button type="button" class="navbar-toggler" data-toggle="collapse"
              data-target="#navbar" aria-controls="navbar" aria-expanded="false" aria-label="Toggle navigation">
        <span><i class="fas fa-bars"></i></span>
      </button>
      

    
    <div class="collapse navbar-collapse" id="navbar">

      
      
      <ul class="navbar-nav mr-auto">
        

        

        
        
        
          
        

        
        
        
        
        
        
          
          
          
            
          
          
        

        <li class="nav-item">
          <a class="nav-link " href="/#about"><span>Home</span></a>
        </li>

        
        

        

        
        
        
          
        

        
        
        
        
        
        
          
          
          
            
          
          
        

        <li class="nav-item">
          <a class="nav-link " href="/#posts"><span>Posts</span></a>
        </li>

        
        

        

        
        
        
          
        

        
        
        
        
        
        
          
          
          
            
          
          
        

        <li class="nav-item">
          <a class="nav-link " href="/#contact"><span>Contact</span></a>
        </li>

        
        

      
      </ul>
      <ul class="navbar-nav ml-auto">
      

        

        
        <li class="nav-item">
          <a class="nav-link js-search" href="#"><i class="fas fa-search" aria-hidden="true"></i></a>
        </li>
        

        

        
        <li class="nav-item">
          <a class="nav-link js-dark-toggle" href="#"><i class="fas fa-moon" aria-hidden="true"></i></a>
        </li>
        

      </ul>

    </div>
  </div>
</nav>


  <article class="article" itemscope itemtype="http://schema.org/Article">

  












  

  
  
  
<div class="article-container pt-3">
  <h1 itemprop="name">Data Driven Rendering: Pipelines</h1>

  

  
    



<meta content="2019-10-14 10:43:49 -0400 -0400" itemprop="datePublished">
<meta content="2020-02-22 10:58:49 -0400 -0400" itemprop="dateModified">

<div class="article-metadata">

  
  

  
  <span class="article-date">
    
    
      
          Last updated on
      
    
    <time>2020-02-22</time>
  </span>
  

  

  
  <span class="middot-divider"></span>
  <span class="article-reading-time">
    17 min read
  </span>
  

  
  
  

  
  

  
    
<div class="share-box" aria-hidden="true">
  <ul class="share">
    
      
      
      
        
      
      
      
      <li>
        <a href="https://twitter.com/intent/tweet?url=https://jorenjoestar.github.io/post/data_driven_rendering_pipeline/&amp;text=Data%20Driven%20Rendering:%20Pipelines" target="_blank" rel="noopener" class="share-btn-twitter">
          <i class="fab fa-twitter"></i>
        </a>
      </li>
    
      
      
      
        
      
      
      
      <li>
        <a href="https://www.facebook.com/sharer.php?u=https://jorenjoestar.github.io/post/data_driven_rendering_pipeline/&amp;t=Data%20Driven%20Rendering:%20Pipelines" target="_blank" rel="noopener" class="share-btn-facebook">
          <i class="fab fa-facebook-f"></i>
        </a>
      </li>
    
      
      
      
        
      
      
      
      <li>
        <a href="mailto:?subject=Data%20Driven%20Rendering:%20Pipelines&amp;body=https://jorenjoestar.github.io/post/data_driven_rendering_pipeline/" target="_blank" rel="noopener" class="share-btn-email">
          <i class="fas fa-envelope"></i>
        </a>
      </li>
    
      
      
      
        
      
      
      
      <li>
        <a href="https://www.linkedin.com/shareArticle?url=https://jorenjoestar.github.io/post/data_driven_rendering_pipeline/&amp;title=Data%20Driven%20Rendering:%20Pipelines" target="_blank" rel="noopener" class="share-btn-linkedin">
          <i class="fab fa-linkedin-in"></i>
        </a>
      </li>
    
      
      
      
        
      
      
      
      <li>
        <a href="https://reddit.com/submit?url=https://jorenjoestar.github.io/post/data_driven_rendering_pipeline/&amp;title=Data%20Driven%20Rendering:%20Pipelines" target="_blank" rel="noopener" class="share-btn-reddit">
          <i class="fab fa-reddit-alien"></i>
        </a>
      </li>
    
  </ul>
</div>


  

</div>

    














  
</div>



  <div class="article-container">

    <div class="article-style" itemprop="articleBody">
      <h1 id="overview">Overview</h1>






<figure>

  <a data-fancybox="" href="GLTFHelmet.png" >

<img src="GLTFHelmet.png" >
</a>


<figcaption data-pre="Figure " data-post=":" >
  <h4>Model used in the demo.</h4>
  
</figcaption>

</figure>

<p>Data Driven Rendering Series:</p>
<ol>
<li><a href="https://jorenjoestar.github.io/post/writing_shader_effect_language_1/">https://jorenjoestar.github.io/post/writing_shader_effect_language_1/</a></li>
<li><a href="https://jorenjoestar.github.io/post/writing_shader_effect_language_2/">https://jorenjoestar.github.io/post/writing_shader_effect_language_2/</a></li>
<li><a href="https://jorenjoestar.github.io/post/writing_shader_effect_language_3/">https://jorenjoestar.github.io/post/writing_shader_effect_language_3/</a></li>
<li><a href="https://jorenjoestar.github.io/post/data_driven_rendering_pipeline/">https://jorenjoestar.github.io/post/data_driven_rendering_pipeline/</a></li>
</ol>
<p>We finally arrived in the <strong>Rendering Pipeline</strong> realm.<!-- raw HTML omitted -->
Some can write that it is useless, some can hate it.<!-- raw HTML omitted -->
Many have some sort of abstraction for it since ages, and others have to now that new APIs like <strong>Vulkan</strong> and <strong>DX12</strong> have it as an explicit part of their design (finally!).</p>
<p>After we built a basic Material System in the previous article (<a href="https://jorenjoestar.github.io/post/writing_shader_effect_language_3/">https://jorenjoestar.github.io/post/writing_shader_effect_language_3/</a>) we can add another layer on top of it and built a complete <em>Rendering Frame</em>.</p>
<p>In this article I will talk about a simplified version of <strong>Render Graph</strong> that I call <strong>Render Pipeline</strong> and came into my mind in the canteen of Codemasters after thinking:</p>
<blockquote>
<p>What is the biggest dependency in Rendering ?</p>
</blockquote>
<p>The answer is simple:</p>
<blockquote>
<p>Render Targets!</p>
</blockquote>
<p><strong>Render Targets</strong> or <strong>Frame Buffers</strong> is just an intermediate buffer in which we can draw something and use it later.<!-- raw HTML omitted -->
Basically a Read/Write texture!<!-- raw HTML omitted -->
It is not easy to shuffle around a Render Target, and having knowledge of which one are you using can make a huge difference for your rendering tech.<!-- raw HTML omitted -->
Textures and Render Targets are the biggest memory lord in any rendering application, thus knowing <em>where</em> you are spending your memory can be really powerful.</p>
<p>From a pure <em>understanding</em> of rendering techniques, having a clear visualization of this aspect makes a HUGE difference!</p>
<p>Once I started using to describe a frame of rendering with the <strong>Render Target Dependencies</strong> I never looked back.<!-- raw HTML omitted -->
As always, knowledge is power.<!-- raw HTML omitted --></p>
<h1 id="render-pipeline-thinking">Render Pipeline Thinking</h1>
<p>First of all, let&rsquo;s start defining some general concepts to describe the problem we are trying to solve.<!-- raw HTML omitted --></p>
<p>The problem we are trying to solve is:</p>
<blockquote>
<p>How to describe the inter-frame dependencies of Render Targets in a frame ?</p>
</blockquote>
<p>The dependencies are who <strong>writes</strong> and/or <strong>read</strong> from/to a <strong>Render Target</strong>.<!-- raw HTML omitted -->
That is exactly what is described in a Render Pipeline.
Enter the <em>Render Pipeline</em>.</p>
<blockquote>
<p>A Render Pipeline is a list of Passes that read and writes Render Targets.<!-- raw HTML omitted --></p>
</blockquote>
<p>That&rsquo;s it.<!-- raw HTML omitted -->
Done! See you next article!<!-- raw HTML omitted --></p>
<p>Of course I am kidding - but this is the gist of it.<!-- raw HTML omitted -->
The implications, however, are profound.<!-- raw HTML omitted --></p>
<p>Next logical question is:</p>
<blockquote>
<p>How can we read and write from/to a Render Target ?</p>
</blockquote>
<p>Let&rsquo;s list how we can <em>write</em> to a Render Target</p>
<ol>
<li>Graphics - binding some geometry, render states and Render Targets</li>
<li>Compute - write anything to the Render Target</li>
</ol>
<p>Even a so called <em>&lsquo;post-process&rsquo;</em> is just a <em>fullscreen triangle with a shader</em>.</p>
<p>And to read&hellip;well any <strong>shader</strong> that takes reads a texture!</p>
<p>It is incredible to think that with this simple building blocks you can describe almost everything to render!</p>
<p>For example, let&rsquo;s try to express some common rendering techniques using only those concepts.</p>
<h2 id="deferred-rendering">Deferred Rendering</h2>
<p>We can define the following simple steps:</p>
<ol>
<li>Meshes uses their materials (shaders + textures + constants) as input and write into GBuffer Render Target + depth.</li>
<li>A Compute/Post-process shader will read the Gbuffer Render Target and depth (to reconstruct the pixel position), a light list of some sort and outputs a texture with the result.</li>
<li>Transparent objects are drawn into this new Render Target using their materials.</li>
<li>And so on&hellip;</li>
</ol>
<!-- raw HTML omitted -->
<h2 id="exponential-variance-shadow-mapping-in-a-forward-rendering-pipeline">Exponential Variance Shadow Mapping in a Forward Rendering Pipeline</h2>
<ol>
<li>Meshes writes into a depth-only render target using the light as &lsquo;camera/point of view&rsquo;.</li>
<li>Compute or Postprocess converts the depth-only render target into a EVSM one.</li>
<li>Meshes uses their materials and the <em>EVSM shadow map</em> to render into a <em>&lsquo;main&rsquo;</em> Render Target.</li>
</ol>
<p>&lt;diagram 2 goes here&gt;</p>
<h1 id="other-rendering-concepts">Other Rendering Concepts</h1>
<p>To give a full description of the frame we need to add other concepts that will help us.<!-- raw HTML omitted -->
These are the less strict ones - and just a personal way of seeing things.</p>
<h2 id="render-view">Render View</h2>
<p>The concept of <em>&lsquo;Render View&rsquo;</em> is just a way or representing a <em>camera</em> and a list of visible objects from it.<!-- raw HTML omitted -->
We will see how we use it later, but a simple example of Render View would be the &lsquo;Sun Shadow&rsquo; render view - representing the sun (as a camera) and a list of visible objects from it.<!-- raw HTML omitted -->
The &lsquo;Main&rsquo; render view of course represent the main camera and visible objects.<!-- raw HTML omitted -->
This, combined with <strong>render managers</strong> becomes a powerful combination to describe <em>what</em> needs to be rendered.</p>
<h2 id="render-manager">Render Manager</h2>
<p>If you think from an ECS mentality, this would be a &lsquo;system&rsquo;.<!-- raw HTML omitted -->
Each render manager is responsible to render one or more render <em>&lsquo;aspects/entities&rsquo;</em> into a Render Pass.<!-- raw HTML omitted -->
A render manager can subscribe to any &lsquo;graphics&rsquo; pass and render from there.</p>
<p>For example, a &lsquo;static geometry&rsquo; render manager could setup an instancing buffer for the gbuffer-generation pass and draw all objects.</p>
<h1 id="render-pipeline-implementation">Render Pipeline Implementation</h1>
<p>After we defined the basic concepts let&rsquo;s see an actual implementation of the Render Pipeline.<!-- raw HTML omitted -->
We will see the code of each component and arrive at the actual data definition (in json).</p>
<p>The code has changed a bit since last article, with the inclusion of CGLM as math library and other high-level rendering code, included in hydra_rendering.h/.cpp.</p>
<h2 id="render-view-1">Render View</h2>
<p>First element is the Render View:</p>
<pre><code>//
// Render view is a 'contextualized' camera - a way of using the camera in the render pipeline.
//
struct RenderView {

    Camera                          camera;

    array( RenderScene )            visible_render_scenes;

}; // struct RenderView

</code></pre><p>Using STB&rsquo;s array (the macro is just an aid to know it is not just a pointer) we have a list of visible render scenes from that camera.<!-- raw HTML omitted -->
It should be pretty straighforward.</p>
<h2 id="render-manager-1">Render Manager</h2>
<p>Next is Render Manager:</p>
<pre><code>//
struct RenderManager {

    struct RenderContext {
        Device*                     device;

        const RenderView*           render_view;
        CommandBuffer*              commands;
        
        RenderScene*                render_scene_array;
        uint16_t                    start;
        uint16_t                    count;
        
        uint16_t                    stage_index;
    }; // struct RenderContext

    virtual void                    render( RenderContext&amp; render_context ) = 0;

}; // struct RenderManager
</code></pre><p>The base class is really just a &lsquo;render&rsquo; method.<!-- raw HTML omitted -->
Here the RenderContext is interesting, and it gives access to all you need to render:</p>
<ol>
<li>Device - used to map/unmap resources.</li>
<li>RenderView - access to camera (and more, but that&rsquo;s for the next article!).</li>
<li>CommandBuffer - the actual draw commands are written here.</li>
<li>RenderScene - the RenderScene from start to start + count.</li>
</ol>
<p>In this very simple demo, we have just 2 <em>render managers</em>: <em>Line Renderer</em> and <em>Scene Renderer</em>.<!-- raw HTML omitted -->
The most interesting one is the second: Line Renderer has commands to draw lines that will be mapped into a GPU buffer and uses instancing to draw them.</p>
<pre><code>
void LineRenderer::render( RenderContext&amp; render_context ) {

    Device&amp; device = *render_context.device;

    // Update camera matrix
    const Camera&amp; camera = render_context.render_view-&gt;camera;

    MapBufferParameters cb_map = { lines_cb, 0, 0 };
    
    float L = 0, T = 0;
    float R = device.swapchain_width, B = device.swapchain_height;
    const float ortho_projection[4][4] =
    {
        { 2.0f / ( R - L ),   0.0f,         0.0f,   0.0f },
        { 0.0f,         2.0f / ( T - B ),   0.0f,   0.0f },
        { 0.0f,         0.0f,        -1.0f,   0.0f },
        { ( R + L ) / ( L - R ),  ( T + B ) / ( B - T ),  0.0f,   1.0f },
    };

    LocalConstants* cb_data = (LocalConstants*)device.map_buffer( cb_map );
    if ( cb_data ) {
        cb_data-&gt;view_projection = camera.view_projection;
        
        memcpy( &amp;cb_data-&gt;projection, &amp;ortho_projection, 64 );
        
        cb_data-&gt;resolution = { device.swapchain_width * 1.0f, device.swapchain_height * 1.0f, 1.0f / device.swapchain_width, 1.0f / device.swapchain_height };
        device.unmap_buffer( cb_map );
    }

    if ( current_line_index ) {
        const uint32_t mapping_size = sizeof( LinVertex ) * current_line_index;
        MapBufferParameters map_parameters_vb = { lines_vb, 0, mapping_size };
        LinVertex* vtx_dst = (LinVertex*)device.map_buffer( map_parameters_vb );
        
        if ( vtx_dst ) {
            memcpy( vtx_dst, &amp;s_line_buffer[0], mapping_size );
            
            device.unmap_buffer( map_parameters_vb );
        }

        CommandBuffer* commands = render_context.commands;
        commands-&gt;begin_submit( 2 );

        ShaderInstance&amp; shader_instance = line_material-&gt;shader_instances[3];
        commands-&gt;bind_pipeline( shader_instance.pipeline );
        commands-&gt;bind_resource_list( shader_instance.resource_lists, shader_instance.num_resource_lists, nullptr, 0 );
        commands-&gt;bind_vertex_buffer( lines_vb, 0, 0 );
        // Draw using instancing and 6 vertices.
        const uint32_t num_vertices = 6;
        commands-&gt;draw( TopologyType::Triangle, 0, num_vertices, current_line_index / 2 );
        commands-&gt;end_submit();

        current_line_index = 0;
    }
}
</code></pre><p>Easy to notice how, with a Vulkan/DX12 interface, there are few less commands to write. Binding a pipeline sets everything considered &lsquo;static&rsquo; - render states, shaders - and with just <em>resource lists</em> (that sets textures and constants) and <em>vertex/index buffers</em> we have everything needed to render.</p>
<p><strong>NOTE</strong>: HFX has gone some improvements and now supports <em>render states and vertex declarations/formats</em>. I&rsquo;ll write about it in the next post - but this has become crucial.</p>
<h2 id="shader-resources-management">Shader Resources Management</h2>
<p>This is another personal preference - but not necessary at all.<!-- raw HTML omitted -->
Two concepts are really useful to me to be explicit and centralized: <em>resources and bindings</em>.</p>
<p>Resources are all referenced in a <em>&lsquo;Shader Resource Database&rsquo;</em>:</p>
<pre><code>//
// Struct used to retrieve textures, buffers and samplers.
//
struct ShaderResourcesDatabase {

    struct BufferStringMap {
        char*                       key;
        BufferHandle                value;
    }; // struct BufferStringMap

    struct TextureStringMap {
        char*                       key;
        TextureHandle               value;
    }; // struct TextureStringMap

    struct SamplerStringMap {
        char* key;
        SamplerHandle               value;
    }; // struct SamplerStringMap

    BufferStringMap*                name_to_buffer = nullptr;
    TextureStringMap*               name_to_texture = nullptr;
    SamplerStringMap*               name_to_sampler = nullptr;

    void                            init();
    void                            terminate();

    void                            register_buffer( char* name, BufferHandle buffer );
    void                            register_texture( char* name, TextureHandle texture );
    void                            register_sampler( char* name, SamplerHandle sampler );

    BufferHandle                    find_buffer( char* name );
    TextureHandle                   find_texture( char* name );
    SamplerHandle                   find_sampler( char* name );

}; // struct ShaderResourcesDatabase

</code></pre><p>Simply put, any resource used by rendering is here.<!-- raw HTML omitted -->
Both Materials, Pipelines and Render Managers register and use the database to create the <em>resource lists</em> used in rendering.</p>
<p>Next and more convoluted is the <em>shader resources lookup</em> class:</p>
<pre><code>//
// Struct to link between a Shader Binding Name and a Resource. Used both in Pipelines and Materials.
//
struct ShaderResourcesLookup {

    enum Specialization {
        Frame, Pass, View, Shader
    }; // enum Specialization

    struct NameMap {
        char*                       key;
        char*                       value;
    }; // struct NameMap

    struct SpecializationMap {
        char*                       key;
        Specialization              value;
    }; // struct SpecializationMap

    NameMap*                        binding_to_resource = nullptr;
    SpecializationMap*              binding_to_specialization = nullptr;
    NameMap*                        binding_to_sampler = nullptr;

    void                            init();
    void                            terminate();

    void                            add_binding_to_resource( char* binding, char* resource );
    void                            add_binding_to_specialization( char* binding, Specialization specialization );
    void                            add_binding_to_sampler( char* binding, char* sampler );

    char*                           find_resource( char* binding );
    Specialization                  find_specialization( char* binding );
    char*                           find_sampler( char* binding );

    void                            specialize( char* pass, char* view, ShaderResourcesLookup&amp; final_lookup );

}; // struct ShaderResourcesLookup
</code></pre><p>This class specify the binding between a <em>shader resource</em> and an <em>actual resource</em>.<!-- raw HTML omitted -->
As a simple example to clarify, a shader could have an <em>&lsquo;albedo&rsquo;</em> texture defined in the code, but the <em>actual</em> texture is defined by the material.<!-- raw HTML omitted -->
Or for a Render Stage, like a Post-Processing one, its input could be defined in the shader code as <em>&lsquo;input 0, input 1&hellip;'</em> and the render pipeline creates the binding.</p>
<p>With those in place, we can finalize any resource used by any shader/material/pipeline.</p>
<p>The actual usage is into the Shader Instance class. Let&rsquo;s have a quick look.</p>
<pre><code>//
struct ShaderInstance {

    void                            load_resources( const PipelineCreation&amp; pipeline, PipelineHandle pipeline_handle, ShaderResourcesDatabase&amp; database, ShaderResourcesLookup&amp; lookup, Device&amp; device );

    PipelineHandle                  pipeline;
    ResourceListHandle              resource_lists[k_max_resource_layouts];

    uint32_t                        num_resource_lists;
}; // struct ShaderInstance
</code></pre><p>This class is what actually contains the resource lists and pipeline used to render anything.<!-- raw HTML omitted -->
Not very happy with the name - any suggestion welcome.<!-- raw HTML omitted -->
A material contains a list of those - one for each pass - and is used to draw.<!-- raw HTML omitted -->
Again with the new Vulkan/DX12 mentality, Pipeline + Resource Lists + Geometry is all you need to render almost.</p>
<p>The magic happens when creating the resource lists:</p>
<pre><code>void ShaderInstance::load_resources( const PipelineCreation&amp; pipeline_creation, PipelineHandle pipeline_handle, ShaderResourcesDatabase&amp; database, ShaderResourcesLookup&amp; lookup, Device&amp; device ) {
    
    using namespace hydra::graphics;
    ResourceListCreation::Resource resources_handles[k_max_resources_per_list];

    for ( uint32_t l = 0; l &lt; pipeline_creation.num_active_layouts; ++l ) {
        // Get resource layout description
        ResourceListLayoutDescription layout;
        device.query_resource_list_layout( pipeline_creation.resource_list_layout[l], layout );

</code></pre><p>We know that a pipeline can have 1 or more resource lists, thus we just iterate through them.<!-- raw HTML omitted -->
Next we look into each resource of the current list:</p>
<pre><code>
        // For each resource
        for ( uint32_t r = 0; r &lt; layout.num_active_bindings; r++ ) {
            const ResourceBinding&amp; binding = layout.bindings[r];

            // Find resource name
            // Copy string_buffer 
            char* resource_name = lookup.find_resource( (char*)binding.name );

            switch ( binding.type ) {
                case hydra::graphics::ResourceType::Constants:
                case hydra::graphics::ResourceType::Buffer:
                {
                    BufferHandle handle = resource_name ? database.find_buffer( resource_name ) : device.get_dummy_constant_buffer();
                    resources_handles[r].handle = handle.handle;

                    break;
                }

                ... same for textures
</code></pre><p>For each binding coming from the shader (think &lsquo;albedo&rsquo; for a PBR shader) we search for the actual resource name (&lsquo;WoodBeamAlbedo&rsquo;) and query the database to find it.<!-- raw HTML omitted -->
After we did that, we can create the list:</p>
<pre><code>            }
        }

        ResourceListCreation creation = { pipeline_creation.resource_list_layout[l], resources_handles, layout.num_active_bindings };
        resource_lists[l] = device.create_resource_list( creation );
    }

    num_resource_lists = pipeline_creation.num_active_layouts;
    pipeline = pipeline_handle;
}
</code></pre><p>With this mechanism we added another explicit connection between resources.</p>
<p>It is finally time to see the actual render pipeline!</p>
<h2 id="render-stagepass">Render Stage/Pass</h2>
<p>This is the <em>CORE</em> of everything, and it must work with all both <strong>geometrical</strong> stages and <strong>post-process</strong> ones.<!-- raw HTML omitted -->
You can either create a base virtual class or doing something like here.<!-- raw HTML omitted -->
Important is understanding the concept!</p>
<pre><code>//
// Encapsulate the rendering of anything that writes to one or more Render Targets.
//
struct RenderStage {

    enum Type {
        Geometry, Post, PostCompute, Swapchain, Count
    };

	Type                            type                                = Count;
</code></pre><p>Simply we define the types:</p>
<ol>
<li>Geometry - uses render manager with meshes to draw.</li>
<li>Post - fullscreen triangle + shader.</li>
<li>PostCompute - any compute shader execution basically!</li>
<li>Swapchain - special case of binding the window framebuffer and render the last time.</li>
</ol>
<p>Next is the most important part: dependencies!</p>
<pre><code>    array( TextureHandle )          input_textures                      = nullptr;
    array( TextureHandle )          output_textures                     = nullptr;

    TextureHandle                   depth_texture;

</code></pre><p>When we create the pipeline, we save all inputs and outputs textures.<!-- raw HTML omitted -->
Depth/Stencil is a put in its own part.</p>
<pre><code>    float                           scale_x                             = 1.0f;
    float                           scale_y                             = 1.0f;
    uint16_t                        current_width                       = 1;
    uint16_t                        current_height                      = 1;
</code></pre><p>Here we handle scaling. When using scale, we use the framebuffer&rsquo;s window width/height to calculate the Render Target size of the output ones. When using the current width/height we instead define a specific size (like for a shadow map).</p>
<pre><code>    RenderPassHandle                render_pass;
</code></pre><p>hydra::graphics low level rendering needs this handle to actually handle the drawing.</p>
<pre><code>    Material*                       material                            = nullptr;
    uint8_t                         pass_index                          = 0;
</code></pre><p>This is for PostProcesses : material and pass index to retrieve the &lsquo;shader instance&rsquo; containing the <em>pipeline</em> and the <em>resource lists</em>.</p>
<pre><code>    RenderView*                     render_view                         = nullptr;
</code></pre><p>RenderView used by this stage.<!-- raw HTML omitted -->
For example the &lsquo;Sun Shadow Render Stage&rsquo; will use the &lsquo;Shadow Render View&rsquo; to dispatch all its objects to each render manager.</p>
<pre><code>    float                           clear_color[4];
    float                           clear_depth_value;
    uint8_t                         clear_stencil_value;

    uint8_t                         clear_rt                            : 1;
    uint8_t                         clear_depth                         : 1;
    uint8_t                         clear_stencil                       : 1;
    uint8_t                         resize_output                       : 1;
    uint8_t                         pad                                 : 4;
</code></pre><p>If the stage needs to clear its output(s), these will tell what to do.</p>
<pre><code>    uint64_t                        geometry_stage_mask;                // Used to send render objects to the proper stage. Not used by compute or postprocess stages.
</code></pre><p>This creates a link between render managers and stages.<!-- raw HTML omitted -->
An object is rendered only if its <em>stage mask</em> equals at least one stage.<!-- raw HTML omitted -->
Why that ? <!-- raw HTML omitted -->
Because when defining a <em>render view</em>, we have a list of objects visible from that camera, and we need a way of dispatching those objects to their respective managers.</p>
<p>For example a &lsquo;dynamic render object&rsquo; could have appear both on the gbuffer pass and an &lsquo;object special effect&rsquo; pass - both visible from the main camera.</p>
<p>This ideas comes from the <em>AMAZING</em> talk by Bungie:</p>
<p><a href="http://advances.realtimerendering.com/destiny/gdc_2015/Tatarchuk_GDC_2015__Destiny_Renderer_web.pdf">http://advances.realtimerendering.com/destiny/gdc_2015/Tatarchuk_GDC_2015__Destiny_Renderer_web.pdf</a></p>
<p>A <em>render manager</em> is what they call a <em>feature renderer</em> - named differently because this version is much more basic!</p>
<pre><code>    array( RenderManager* )         render_managers;
</code></pre><p>Render Managers can register to stages even if they don&rsquo;t have objects, for example a <em>&lsquo;Lighting Manager&rsquo;</em> would want to submit a list of visible light in a certain pass.</p>
<pre><code>    // Interface
    virtual void                    init();
    virtual void                    terminate();

    virtual void                    begin( Device&amp; device, CommandBuffer* commands );
    virtual void                    render( Device&amp; device, CommandBuffer* commands );
    virtual void                    end( Device&amp; device, CommandBuffer* commands );

    virtual void                    load_resources( ShaderResourcesDatabase&amp; db, Device&amp; device );
    virtual void                    resize( uint16_t width, uint16_t height, Device&amp; device );

    void                            register_render_manager( RenderManager* manager );

}; // struct RenderStage
</code></pre><p>This is the final interface.<!-- raw HTML omitted -->
Load resources is used for PostProcesses - they have a material and need to load its resources.</p>
<h2 id="render-pipeline">Render Pipeline</h2>
<p>We arrived at the last piece of the puzzle!</p>
<pre><code>//
// A full frame of rendering using RenderStages.
//
struct RenderPipeline {

    struct StageMap {
        char*                       key;
        RenderStage*                value;
    };

    struct TextureMap {
        char*                       key;
        TextureHandle               value;
    };

    void                            init( ShaderResourcesDatabase* initial_db );
    void                            terminate( Device&amp; device );

    void                            update();
    void                            render( Device&amp; device, CommandBuffer* commands );

    void                            load_resources( Device&amp; device );
    void                            resize( uint16_t width, uint16_t height, Device&amp; device );

    StageMap*                       name_to_stage                       = nullptr;
    TextureMap*                     name_to_texture                     = nullptr;

    ShaderResourcesDatabase         resource_database;
    ShaderResourcesLookup           resource_lookup;

}; // struct RenderPipeline
</code></pre><p>This is literally IT!<!-- raw HTML omitted -->
This class contains all the stages and resources needed to render.<!-- raw HTML omitted -->
Most of the time it will just iterate over the stages and execute something per stage.</p>
<p>Resource database contains all the resources used actually - and the lookup instead is only for the PostProcess stages.<!-- raw HTML omitted --></p>
<h2 id="render-pipeline-description">Render Pipeline Description</h2>
<p>We really have all the part to render a frame!<!-- raw HTML omitted -->
Let&rsquo;s look at the data defining the pipeline.<!-- raw HTML omitted -->
We will define a simple-silly-non-effective PBR deferred rendering.<!-- raw HTML omitted -->
Probably the worst shaders you saw, but it will still work.</p>
<p>First we define the Render Targets:</p>
<pre><code>{
    &quot;name&quot;: &quot;PBR_Deferred&quot;,
    &quot;RenderTargets&quot;: [
        {
            &quot;name&quot;: &quot;GBufferAlbedo&quot;,
            &quot;format&quot;: &quot;R8G8B8A8_UNORM&quot;
        },
        {
            &quot;name&quot;: &quot;GBufferNormals&quot;,
            &quot;format&quot;: &quot;R16G16B16A16_SNORM&quot;
        },
        {
            &quot;name&quot;: &quot;GBufferProperties0&quot;,
            &quot;format&quot;: &quot;R8G8B8A8_UNORM&quot;
        },
        {
            &quot;name&quot;: &quot;MainDepth&quot;,
            &quot;format&quot;: &quot;D24_UNORM_S8_UINT&quot;
        },
        {
            &quot;name&quot;: &quot;BackBufferColor&quot;,
            &quot;format&quot;: &quot;R16G16B16A16_FLOAT&quot;
        }
    ],
</code></pre><p>by default they will have the same size as the window framebuffer, unless otherwise written (scale_x/y, width/height).</p>
<p>Next are the actual render stages.<!-- raw HTML omitted -->
The first is the GBufferOpaque one:</p>
<pre><code>    &quot;RenderStages&quot;: [
        {
            &quot;name&quot;: &quot;GBufferOpaque&quot;,
            &quot;type&quot;: &quot;Geometry&quot;,
            &quot;render_view&quot;: &quot;main&quot;,
            &quot;depth_stencil&quot;: &quot;Main&quot;,
            &quot;inputs&quot;: [

            ],
            &quot;outputs&quot;: {
                &quot;rts&quot;: [ &quot;GBufferAlbedo&quot;, &quot;GBufferNormals&quot;, &quot;GBufferProperties0&quot; ],
                &quot;depth&quot;: &quot;MainDepth&quot;,
                &quot;flags&quot;: &quot;Common&quot;,
                &quot;clear_color&quot;: &quot;000000ff&quot;,
                &quot;clear_depth&quot;: 1.0,
                &quot;clear_stencil&quot;: 0
            }
        },
</code></pre><p>As you see it outputs to 3 Render Targets + Depth.<!-- raw HTML omitted -->
It also specify clear color, depth and stencil.</p>
<p>Next is the silliest compute shader to calculate light:</p>
<pre><code>        {
            &quot;name&quot;: &quot;DeferredLights&quot;,
            &quot;type&quot;: &quot;PostCompute&quot;,
            &quot;material_name&quot;: &quot;SimpleFullscreen&quot;,
            &quot;material_pass_index&quot;: 2,
            &quot;inputs&quot;: [
                {
                    &quot;name&quot;: &quot;GBufferAlbedo&quot;,
                    &quot;sampler&quot;: &quot;Point&quot;,
                    &quot;binding&quot;: &quot;gbuffer_albedo&quot;
                },
                {
                    &quot;name&quot;: &quot;GBufferNormals&quot;,
                    &quot;sampler&quot;: &quot;Point&quot;,
                    &quot;binding&quot;: &quot;gbuffer_normals&quot;
                },
                {
                    &quot;name&quot;: &quot;GBufferProperties0&quot;,
                    &quot;sampler&quot;: &quot;Point&quot;,
                    &quot;binding&quot;: &quot;gbuffer_properties0&quot;
                },
                {
                    &quot;name&quot;: &quot;MainDepth&quot;,
                    &quot;sampler&quot;: &quot;Point&quot;,
                    &quot;binding&quot;: &quot;depth_texture&quot;
                }
            ],
            &quot;outputs&quot;: {
                &quot;images&quot;: [
                    {
                        &quot;name&quot;: &quot;BackBufferColor&quot;,
                        &quot;binding&quot;: &quot;destination_texture&quot;
                    }
                ],
                &quot;flags&quot;: &quot;Common&quot;
            }
        },

</code></pre><p>It will read all the previously generated textures and run a compute shader to calculate the final lighting.<!-- raw HTML omitted -->
Worth noting &lsquo;material&rsquo; and &lsquo;material pass index&rsquo; - to retrieve the shader from the material. If you open SimpleFullscreen.hfx and go to the third defined pass, you will see the code.</p>
<p>Next is an example of reusing a Render Target to add informations (like transparent objects).<!-- raw HTML omitted -->
It will add debug rendering on top of the other objects and write in the BackBufferColor render target.<!-- raw HTML omitted -->
The absence of clear parameters dictates that we don&rsquo;t want to clear.</p>
<pre><code>        {
            &quot;name&quot;: &quot;DebugRendering&quot;,
            &quot;type&quot;: &quot;Geometry&quot;,
            &quot;render_view&quot;: &quot;main&quot;,
            &quot;inputs&quot;: [

            ],
            &quot;outputs&quot;: {
                &quot;rts&quot;: [ &quot;BackBufferColor&quot; ],
                &quot;depth&quot;: &quot;MainDepth&quot;,
                &quot;flags&quot;: &quot;Common&quot;
            }
        },
</code></pre><p>Last step is the swapchain.<!-- raw HTML omitted -->
It is simply using a simple shader to write to the window framebuffer as the last step of the frame.</p>
<pre><code>        {
            &quot;name&quot;: &quot;Swapchain&quot;,
            &quot;type&quot;: &quot;Swapchain&quot;,
            &quot;mask&quot;: &quot;FRAMEBUFFER&quot;,
            &quot;material_name&quot;: &quot;Swapchain&quot;,
            &quot;render_view&quot;: &quot;&quot;,
            &quot;depth_stencil&quot;: &quot;Post&quot;,
            &quot;inputs&quot;: [
                {
                    &quot;name&quot;: &quot;BackBufferColor&quot;,
                    &quot;sampler&quot;: &quot;Point&quot;,
                    &quot;binding&quot;: &quot;input_texture&quot;
                }
            ],
            &quot;outputs&quot;: {
                &quot;rts&quot;: [
                ],
                &quot;depth&quot;: &quot;&quot;,
                &quot;flags&quot;: &quot;Common&quot;,
                &quot;clear_color&quot;: &quot;000000ff&quot;
            }
        }
    ]
}
</code></pre><h2 id="visualization">Visualization</h2>
<p>With all this defined, we can arrive to have something incredibly useful as this (included in the demo!):</p>






<figure>

  <a data-fancybox="" href="HydraFrame.png" >

<img src="HydraFrame.png" >
</a>


<figcaption data-pre="Figure " data-post=":" >
  <h4>Render Pipeline</h4>
  
</figcaption>

</figure>

<p>To me this is the quintessence of rendering: visualization.<!-- raw HTML omitted -->
Seeing things helps me understanding much better.<!-- raw HTML omitted -->
Debugging broken features, studying features, understanding dependencies, shuffling things around becomes MUCH easier.</p>
<h1 id="demo-and-code">Demo and code</h1>
<p>The demo loads a model, apply a silly directional light and gives you some controls, and uses the render pipeline.<!-- raw HTML omitted -->
It was setup during the night just to show something usable, but it is far from ideal!</p>
<p>In the code provided there is everything I am talking here.<!-- raw HTML omitted --></p>
<p>And now some links to libraries/resources used.</p>
<p>3 models are included from the free GLTF library:
<a href="https://github.com/KhronosGroup/glTF-Sample-Models">https://github.com/KhronosGroup/glTF-Sample-Models</a></p>
<p>TinyGLTF by <a href="https://twitter.com/syoyo">Syoyo Fujita</a>:</p>
<p><a href="https://github.com/syoyo/tinygltf">https://github.com/syoyo/tinygltf</a></p>
<p>The always present-always amazing ImGui by <a href="https://twitter.com/ocornut">Omar</a>:
<a href="https://github.com/ocornut/imgui">https://github.com/ocornut/imgui</a></p>
<p>With the NodeEditor by <a href="https://github.com/thedmd">Michał Cichoń</a>:
<a href="https://github.com/thedmd/imgui-node-editor">https://github.com/thedmd/imgui-node-editor</a></p>
<p>For the PBR rendering, kudos to the GREAT INFORMATIONS from <a href="https://google.github.io/filament/Filament.md.html">Google Filament</a> and <a href="https://twitter.com/romainguy">Romain Guy</a>.</p>
<p>Lastly, this is not anywhere near production ready, but I am still happy to share it as a knowledge building block for others.<!-- raw HTML omitted -->
I am thinking of making some videos for this - if you are interested let me know (both in English and Italian).</p>
<h1 id="conclusions">Conclusions</h1>
<p>We arrived at defining the Render Pipeline - a way of describing how a frame is rendered.<!-- raw HTML omitted -->
It is a very simplified version of the RenderGraph/FrameGraph - as seen in many talks - and this is something I&rsquo;ve used in my home projects (and current indie game) with great success.<!-- raw HTML omitted -->
No mention of adding resource barriers, sharing memory, async compute and more.<!-- raw HTML omitted -->
The whole purpose of this article was instead to focus on the more high level architecture side.</p>
<p>What is next ?</p>
<p>I would write about the improvements on the HFX shader effect and would like to cleanup and make that library more robust.<!-- raw HTML omitted -->
Then there is the Vulkan backend to be wrote and many examples to be done. Examples could be amazing to be tutorial and develop the technology more.<!-- raw HTML omitted -->
Then there is talking deeper about dispatching rendering draws, render managers and such - another interesting and very unique subject in Rendering Engine architectures. In all the companies I&rsquo;ve worked, I always found completely different solutions!</p>
<p>Please comment, share, send feedback!
I am happy to answer any question and very happy to share this article.
Thanks for reading!</p>
<p>Gabriel</p>

    </div>

    


    



    
      








  





  
  
  
    
  
  
  <div class="media author-card" itemscope itemtype="http://schema.org/Person">
    
      
      <img class="portrait mr-3" src="/authors/admin/avatar_hu4ba9915415047fa4e8e4f547c8f3933e_319586_250x250_fill_q90_lanczos_center.jpg" itemprop="image" alt="Avatar">
    

    <div class="media-body">
      <h5 class="card-title" itemprop="name"><a href="https://jorenjoestar.github.io/">Gabriel Sassone</a></h5>
      <h6 class="card-subtitle">Principal Rendering/Engine Programmer</h6>
      
      <ul class="network-icon" aria-hidden="true">
        
          
          
          
            
          
          
          
          
          
            
          
          <li>
            <a itemprop="sameAs" href="https://twitter.com/GabrielSassone" target="_blank" rel="noopener">
              <i class="fab fa-twitter"></i>
            </a>
          </li>
        
          
          
          
            
          
          
          
          
          
            
          
          <li>
            <a itemprop="sameAs" href="https://github.com/JorenJoestar" target="_blank" rel="noopener">
              <i class="fab fa-github"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>



      
      
    

    

    


  </div>
</article>

      

    
    
    
    <script src="/js/mathjax-config.js"></script>
    

    
    
    
      <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js" integrity="sha256-CSXorXvZcTkaix6Yvo6HppcZGetbYMGWSFlBw8HfCJo=" crossorigin="anonymous"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery.imagesloaded/4.1.4/imagesloaded.pkgd.min.js" integrity="sha256-lqvxZrPLtfffUl2G/e7szqSvPBILGbwmsGE1MKlOi0Q=" crossorigin="anonymous"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery.isotope/3.0.6/isotope.pkgd.min.js" integrity="sha256-CBrpuqrMhXwcLLUd5tvQ4euBHCdh7wGlDfNz8vbu/iI=" crossorigin="anonymous"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.2.5/jquery.fancybox.min.js" integrity="sha256-X5PoE3KU5l+JcX+w09p/wHl9AzK333C4hJ2I9S5mD4M=" crossorigin="anonymous"></script>

      
        <script src="https://cdnjs.cloudflare.com/ajax/libs/mermaid/8.0.0/mermaid.min.js" integrity="sha256-0w92bcB21IY5+rGI84MGj52jNfHNbXVeQLrZ0CGdjNY=" crossorigin="anonymous" title="mermaid"></script>
      

      
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.6/highlight.min.js" integrity="sha256-aYTdUrn6Ow1DDgh5JTc3aDGnnju48y/1c8s1dgkYPQ8=" crossorigin="anonymous"></script>
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.6/languages/cpp.min.js"></script>
        
      

      
      
      <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=TeX-AMS_CHTML-full" integrity="sha256-GhM+5JHb6QUzOQPXSJLEWP7R73CbkisjzK5Eyij4U9w=" crossorigin="anonymous" async></script>
      
    

    
    

    
    
    <script>hljs.initHighlightingOnLoad();</script>
    

    
    
    <script>
      const search_index_filename = "/index.json";
      const i18n = {
        'placeholder': "Search...",
        'results': "results found",
        'no_results': "No results found"
      };
      const content_type = {
        'post': "Posts",
        'project': "Projects",
        'publication' : "Publications",
        'talk' : "Talks"
        };
    </script>
    

    
    

    
    
    <script id="search-hit-fuse-template" type="text/x-template">
      <div class="search-hit" id="summary-{{key}}">
      <div class="search-hit-content">
        <div class="search-hit-name">
          <a href="{{relpermalink}}">{{title}}</a>
          <div class="article-metadata search-hit-type">{{type}}</div>
          <p class="search-hit-description">{{snippet}}</p>
        </div>
      </div>
      </div>
    </script>
    

    
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/fuse.js/3.2.1/fuse.min.js" integrity="sha256-VzgmKYmhsGNNN4Ph1kMW+BjoYJM2jV5i4IlFoeZA9XI=" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mark.js/8.11.1/jquery.mark.min.js" integrity="sha256-4HLtjeVgH0eIB3aZ9mLYF6E8oU5chNdjU6p6rrXpl9U=" crossorigin="anonymous"></script>
    

    
    

    
    
    
    
    
    
    
    
    
      
    
    
    
    
    <script src="/js/academic.min.b22d2266dab94c8508ae1f0cf6b7056c.js"></script>

    






  
  <div class="container">
    <footer class="site-footer">
  

  <p class="powered-by">
    

    Powered by the
    <a href="https://sourcethemes.com/academic/" target="_blank" rel="noopener">Academic theme</a> for
    <a href="https://gohugo.io" target="_blank" rel="noopener">Hugo</a>.

    
    <span class="float-right" aria-hidden="true">
      <a href="#" id="back_to_top">
        <span class="button_icon">
          <i class="fas fa-chevron-up fa-2x"></i>
        </span>
      </a>
    </span>
    
  </p>
</footer>

  </div>
  

  
<div id="modal" class="modal fade" role="dialog">
  <div class="modal-dialog">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title">Cite</h5>
        <button type="button" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body">
        <pre><code class="tex hljs"></code></pre>
      </div>
      <div class="modal-footer">
        <a class="btn btn-outline-primary my-1 js-copy-cite" href="#" target="_blank">
          <i class="fas fa-copy"></i> Copy
        </a>
        <a class="btn btn-outline-primary my-1 js-download-cite" href="#" target="_blank">
          <i class="fas fa-download"></i> Download
        </a>
        <div id="modal-error"></div>
      </div>
    </div>
  </div>
</div>

</body>
</html>
