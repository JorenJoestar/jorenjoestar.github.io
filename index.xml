<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Joren&#39;s</title>
    <link>/</link>
    <description>Recent content on Joren&#39;s</description>
    <generator>Source Themes Academic (https://sourcethemes.com/academic/)</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 18 Aug 2019 23:47:13 -0400</lastBuildDate>
    
	    <atom:link href="/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Writing a Shader Effect Language Part 2</title>
      <link>/post/writing_shader_effect_language_2/</link>
      <pubDate>Sun, 18 Aug 2019 23:47:13 -0400</pubDate>
      
      <guid>/post/writing_shader_effect_language_2/</guid>
      <description>

&lt;h1 id=&#34;overview&#34;&gt;Overview&lt;/h1&gt;

&lt;p&gt;In &lt;a href=&#34;https://jorenjoestar.github.io/post/writing_shader_effect_language_1/&#34; target=&#34;_blank&#34;&gt;Part 1 of this series&lt;/a&gt; we created a simple &lt;em&gt;language&lt;/em&gt; to work as &amp;lsquo;shader effect&amp;rsquo; - a shader language superset to make our life easier, by adding missing features.&lt;br&gt;
The fact that there is not an industry standard for a shader effect language leads to either hand-crafted (and secret) languages, or to hardcoded permutations, or to other gray-area solutions.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;(Personal though: part of me would like to help in contributing to the creation of a standard through these articles and code.)&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;What is the &lt;strong&gt;goal&lt;/strong&gt; of this article ?&lt;/p&gt;

&lt;p&gt;The &lt;strong&gt;goal&lt;/strong&gt; is to enrich the &lt;strong&gt;HFX language&lt;/strong&gt; to generate more code possible and/or bake data for us, namely:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Shader constants generation&lt;/li&gt;
&lt;li&gt;Shader resource bindings&lt;/li&gt;
&lt;li&gt;Render states (depth stencil, blend, rasterization)&lt;/li&gt;
&lt;li&gt;Render pass hints for a future framegraph&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;We will see Render States and Render Pass hints in a following article, because this is an already lengthy article!&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;I hope that by now the way of adding an identifier, parsing it and generating code is clearer.&lt;br&gt;
In this article we will focus more on the features than anything else, even though I will put a lot of code still.&lt;br&gt;
But before that, we need to have a big addition to our example: a rendering API!&lt;br&gt;
We will use this as target of our code generation, and it will be an amazing example to see something working.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Maybe this will spark a new FX Composer ?&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;This article will be divided in 2 parts.&lt;br&gt;
Part 1 of this article will talk about the rendering API.&lt;br&gt;
Part 2 will be about the extended HFX language.&lt;br&gt;
If you are not interested in that, jump to part 2 of this article.&lt;/p&gt;

&lt;h1 id=&#34;part-1-adding-a-low-level-rendering-api&#34;&gt;Part 1: adding a low-level rendering API&lt;/h1&gt;

&lt;p&gt;Writing articles on rendering without some sort of API to use is tricky.&lt;br&gt;
Creating a language to speed up data driven rendering, either for generating code and/or for baking data &lt;em&gt;needs&lt;/em&gt; a target API.&lt;br&gt;
The main idea is to have an abstract API to map more easily rendering concepts instead of losing ourselves in specific API needs.&lt;/p&gt;

&lt;h2 id=&#34;the-search-for-an-abstract-api&#34;&gt;The search for an abstract API&lt;/h2&gt;

&lt;p&gt;The first thing to do is to search for an existing abstract API.&lt;br&gt;
I have few criteria in mind:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Simple and clear interface&lt;/li&gt;
&lt;li&gt;Compact and clear code&lt;/li&gt;
&lt;li&gt;Vulkan and D3D12 interface&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;With those in mind, I found 2 alternatives: &lt;a href=&#34;https://github.com/bkaradzic/bgfx&#34; target=&#34;_blank&#34;&gt;BGFX&lt;/a&gt; and &lt;a href=&#34;https://github.com/floooh/sokol&#34; target=&#34;_blank&#34;&gt;Sokol&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;I am an honest fan of both, they are brilliant, robust and well written.&lt;br&gt;
But for the purpose of these articles, sadly they miss my search criteria.&lt;br&gt;
There is also a &lt;strong&gt;huge disclaimer&lt;/strong&gt; here: I used them too little, so it is possible I overlooked the usage of them.&lt;br&gt;
I will be more than glad to use either instead of my toy API!&lt;br&gt;
I respect the developers and the library a lot, they are doing an amazing job!&lt;br&gt;
But we are handcrafting something, and to properly do that I personally need to know deeply the code. And I am not.&lt;/p&gt;

&lt;p&gt;BGFX is very complete, but the interface is a little confusing for me, possibly because I never used it but just read the code few times.&lt;br&gt;
The main reason I chose not to use it is because the interface is missing the resource interface like Vulkan and D3D12 (DescriptorSets, &amp;hellip;), otherwise it would have been an amazing choice.&lt;/p&gt;

&lt;p&gt;Sokol is also very good, I love the code and the simple interface.&lt;br&gt;
Two main problems here: again no Vulkan/D3D12 resource interface, and in this case a different target: it does not support compute shaders.&lt;/p&gt;

&lt;p&gt;Again, I want to make it clear: I am not saying these are not good libraries. They are amazing. They just don&amp;rsquo;t fit my search criteria, plus I LOVE to work on rendering architecture. Well actually, it is my favourite job!&lt;/p&gt;

&lt;p&gt;So kudos to them (I also wrote to Andre Weissflog to ask for compute shader support, but it is not in his plans for now) but we are making a different choice.&lt;br&gt;&lt;/p&gt;

&lt;p&gt;If you ever find anything that I write useful guys, please let me know!&lt;/p&gt;

&lt;h2 id=&#34;hydra-graphics-design-principles&#34;&gt;Hydra Graphics: design principles&lt;/h2&gt;

&lt;p&gt;Small trivia: the name comes from my first ever graphics engine written in 2006 (I think), after devouring 3D Game Engine Design by Dave Eberly. I already knew I would write many engines and I would learn and grow stronger from every of them, so I chose the name Hydra from the Greek mythology monster.&lt;br&gt;
The other name would have been Phoenx engine, but I remember finding already some tech with that name.&lt;/p&gt;

&lt;p&gt;Anyway, design principles!&lt;br&gt;
I really loved the interface of Sokol, and often I used something similar by myself.&lt;br&gt;
I opted for a pair of header/implementation files as the only needed files.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;The backend is OpenGL for now, just because I have a working implementation in my indie project that works with pretty complex rendering, and I can use that as reference.&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&#34;interface&#34;&gt;Interface&lt;/h3&gt;

&lt;p&gt;Rendering in general is a matter of creating, modifying and combining &lt;em&gt;resources&lt;/em&gt;.&lt;br&gt;
There are mainly 2 classes that do all the rendering work:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Device&lt;/li&gt;
&lt;li&gt;Command Buffer&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;em&gt;The Device is responsible for creation, destruction, modification and query of the resources.&lt;br&gt;
The Command Buffer is responsible for the usage of resources for rendering.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;The obvious fundamental concept is &lt;strong&gt;resource&lt;/strong&gt;.&lt;br&gt;
A &lt;strong&gt;resource&lt;/strong&gt; is handled externally through handles, can be created using &lt;strong&gt;creation&lt;/strong&gt; structs and has both a common and an API-specific representation.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Buffers&lt;/strong&gt; are specialized in vertex/index/constant/&amp;hellip; depending on their creation parameters.&lt;/p&gt;

&lt;p&gt;This is a small example on creation/usage/destruction of a resource.&lt;br&gt;
First, we can create a texture:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;graphics::TextureCreation first_rt = {};
first_rt.width = 512;
first_rt.height = 512;
first_rt.render_target = 1;
first_rt.format = graphics::TextureFormat::R8G8B8A8_UNORM;

TextureHandle render_target = gfx_device.create_texture( first_rt );
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Next we can create a command buffer:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;CommandBuffer* commands = gfx_device.get_command_buffer( graphics::QueueType::Graphics, 1024 );
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Skipping other creations, we bind resources and add the commands:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;commands-&amp;gt;bind_pipeline( first_graphics_pipeline );
commands-&amp;gt;bind_resource_set( gfx_resources );
commands-&amp;gt;bind_vertex_buffer( gfx_device.get_fullscreen_vertex_buffer() );
commands-&amp;gt;draw( graphics::TopologyType::Triangle, 0, 3 );
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;At this point we can execute the command buffer to draw.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;gfx_device.execute_command_buffer( commands );
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Updating a resource can be done like that:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;hydra::graphics::MapBufferParameters map_parameters = { buffer.handle, 0, 0 };
LocalConstants* buffer_data = (LocalConstants*)device.map_buffer( map_parameters );
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Everything uses structs to perform creation/updates.&lt;br&gt;
Nothing new, but I always loved this design.&lt;/p&gt;

&lt;h3 id=&#34;resource-layout-and-resource-lists&#34;&gt;Resource layout and resource lists&lt;/h3&gt;

&lt;p&gt;I wanted to bring the Vulkan/D3D12 resource interface as first class citizens, and remove completely old concepts (like single constants, render states as single objects, single bind of a resource) and add new ones: resource layout, resource lists and command buffers. Well command buffers are not new, but &lt;em&gt;finally&lt;/em&gt; you can draw only with those!&lt;/p&gt;

&lt;p&gt;In Vulkan/D3D12 you can bind resources through the usage of &lt;em&gt;sets&lt;/em&gt;: basically tables that contains the resources used.&lt;br&gt;
This is a welcomed difference from previous APIs, and I think it is a concept not too hard to grasp but very useful to have it explicit.&lt;/p&gt;

&lt;p&gt;The first thing to define is the &lt;strong&gt;resource layout&lt;/strong&gt; describes the layout of a set of resources.&lt;br&gt;
For example, if we have a material that uses Albedo and Normals textures and a constant buffer, the layout will contain all the informations about that (like the type, the GPU registers and so on).&lt;br&gt;
This though still does not contain the resources themselves!&lt;br&gt;
Enter &lt;strong&gt;resource list&lt;/strong&gt;.&lt;br&gt;
A &lt;strong&gt;resource list&lt;/strong&gt; is a list of actual resources &lt;em&gt;relative to a layout&lt;/em&gt;.&lt;br&gt;
It sets resources using a layout.&lt;/p&gt;

&lt;p&gt;From now on, when we draw we can bind &lt;em&gt;one or more resource lists&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;In Vulkan lingo, the &lt;strong&gt;resource layout&lt;/strong&gt; is called &lt;strong&gt;descriptor set layout&lt;/strong&gt;, and a &lt;strong&gt;resource list&lt;/strong&gt; is a &lt;strong&gt;descriptor set&lt;/strong&gt;.&lt;br&gt;
Here are a couple of articles for the Vulkan side:&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://vulkan.lunarg.com/doc/view/1.0.33.0/linux/vkspec.chunked/ch13s02.html&#34; target=&#34;_blank&#34;&gt;Official Vulkan Documentation on Descriptor Layouts and Sets&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://software.intel.com/en-us/articles/api-without-secrets-introduction-to-vulkan-part-6&#34; target=&#34;_blank&#34;&gt;Intel API Without Secrets Part 6&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Similarly in D3D12 there are Root Tables and Descriptor Tables. The concepts do no map 1 to 1 but they are pretty similar:&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://docs.microsoft.com/en-us/windows/win32/direct3d12/using-descriptor-tables&#34; target=&#34;_blank&#34;&gt;D3D12 Descriptor Tables&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;I tried to map these concepts using different words that would make more sense to me, so from &lt;em&gt;Descriptor Set&lt;/em&gt; or &lt;em&gt;Root Table&lt;/em&gt; it became &lt;em&gt;Resource List&lt;/em&gt; and &lt;em&gt;Resource Layout&lt;/em&gt;.&lt;/p&gt;

&lt;h3 id=&#34;pipelines&#34;&gt;Pipelines&lt;/h3&gt;

&lt;p&gt;Finally a pipeline is the complete description of what is needed by the GPU to draw something on the screen (or to use a Compute Shader for any other purpose).&lt;br&gt;
Basically a pipeline must fill all the informations for all the GPU stages like this (thanks to &lt;a href=&#34;https://renderdoc.org&#34; target=&#34;_blank&#34;&gt;RenderDoc&lt;/a&gt;):&lt;/p&gt;







&lt;figure&gt;

  &lt;a data-fancybox=&#34;&#34; href=&#34;RenderDoc_Pipeline.png&#34; &gt;

&lt;img src=&#34;RenderDoc_Pipeline.png&#34; &gt;
&lt;/a&gt;


&lt;figcaption data-pre=&#34;Figure &#34; data-post=&#34;:&#34; &gt;
  &lt;h4&gt;RenderDoc Pipeline&lt;/h4&gt;
  
&lt;/figcaption&gt;

&lt;/figure&gt;


&lt;p&gt;What once was setup individually now is all in one place (reflecting what happened behind the scene, into the driver).&lt;br&gt;
DepthStencil, AlphaBlend, Rasterization, Shaders, all must be defined here.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;In the currrent implementation of the graphics-API a lot of states are still missing!&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Now that we say the basic principles of the target rendering API, we can finally concentrate on the new freatures of HFX.&lt;/p&gt;

&lt;h1 id=&#34;part-2-forging-the-hfx-language-features&#34;&gt;Part 2: forging the HFX language features&lt;/h1&gt;

&lt;p&gt;Our HFX language needs some properties to be added but first there is a change: HFX will generate a binary version to embed all the informations needed to create a shader.&lt;/p&gt;

&lt;h2 id=&#34;hfx-evolution-what-files-are-generated&#34;&gt;HFX evolution: what files are generated ?&lt;/h2&gt;

&lt;p&gt;In the previous article, we used a single HFX file to generate multiple glsl files, ready to be used by any OpenGL renderer:&lt;/p&gt;







&lt;figure&gt;

  &lt;a data-fancybox=&#34;&#34; href=&#34;HFX_Shader_Gen.png&#34; &gt;

&lt;img src=&#34;HFX_Shader_Gen.png&#34; &gt;
&lt;/a&gt;


&lt;figcaption data-pre=&#34;Figure &#34; data-post=&#34;:&#34; &gt;
  &lt;h4&gt;Shader Generation&lt;/h4&gt;
  
&lt;/figcaption&gt;

&lt;/figure&gt;


&lt;p&gt;Remembering the article on &lt;a href=&#34;https://jorenjoestar.github.io/post/writing_a_simple_code_generator/&#34; target=&#34;_blank&#34;&gt;Hydra Data Format&lt;/a&gt;, we instead were generating an header file.&lt;br&gt;
For our needs, we will generate an embedded HFX (binary HFX) AND a C++ header:&lt;/p&gt;







&lt;figure&gt;

  &lt;a data-fancybox=&#34;&#34; href=&#34;HFX_Gen.png&#34; &gt;

&lt;img src=&#34;HFX_Gen.png&#34; &gt;
&lt;/a&gt;


&lt;figcaption data-pre=&#34;Figure &#34; data-post=&#34;:&#34; &gt;
  &lt;h4&gt;Binary and Header Generation&lt;/h4&gt;
  
&lt;/figcaption&gt;

&lt;/figure&gt;


&lt;p&gt;What is the next step for HFX ?&lt;br&gt;
For shader generation, we want ideally to load a HFX file without having to manually stick together the single shader files, and that is why the first step is to create &lt;strong&gt;embedded HFX files&lt;/strong&gt;.&lt;br&gt;
This will contain all the information to create a shader, and this includes also the resource layouts.&lt;/p&gt;

&lt;p&gt;For constant handling, we want to have UI generated and easy update on the gpu. We want to automate these things.&lt;br&gt;
This can be done in a more code-generated way or by generating data.&lt;/p&gt;

&lt;p&gt;If we abstract the problem, all these articles are about understanding how you want to generate code or data to maximise iteration time, performances and control.&lt;br&gt;
By moving the HFX to being binary, we are effectively generating &lt;em&gt;data&lt;/em&gt; used by the renderer.&lt;br&gt;
For the shader UI, we can do both: generate code or create data. We will see the generated code part here.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s see briefly the internals of the &lt;strong&gt;Embedded HFX&lt;/strong&gt; file format:&lt;/p&gt;

&lt;h3 id=&#34;embedded-hfx&#34;&gt;Embedded HFX&lt;/h3&gt;

&lt;p&gt;As a Recap, when &lt;em&gt;parsing&lt;/em&gt; HFX we store some informations.&lt;/p&gt;

&lt;p&gt;First is the CodeFragment, including also (spoiler!) the addition of resources for the sake of this article:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// C++
//
struct CodeFragment {

    struct Resource {
        
        hydra::graphics::ResourceType::Enum type;
        StringRef               name;

    }; // struct Resource

    std::vector&amp;lt;StringRef&amp;gt;      includes;
    std::vector&amp;lt;Stage&amp;gt;          includes_stage;     // Used to separate which include is in which shader stage.
    std::vector&amp;lt;Resource&amp;gt;       resources;          // Used to generate the layout table.

    StringRef                   name;
    StringRef                   code;
    Stage                       current_stage       = Stage::Count;
    uint32_t                    ifdef_depth         = 0;
    uint32_t                    stage_ifdef_depth[Stage::Count];

}; // struct CodeFragment
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The rest is unchanged from the previous article.&lt;br&gt;
We have basically code and includes to bake the final shader.&lt;br&gt;
Remember, we are handling GLSL in these examples!&lt;/p&gt;

&lt;p&gt;Next is the Pass:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// C++
//
struct Pass {

    StringRef                   name;
    struct ShaderStage {

        const CodeFragment*     code                = nullptr;
        Stage                   stage               = Stage::Count;

    }; // struct ShaderStage

    StringRef                   name;
    std::vector&amp;lt;ShaderStage&amp;gt;    shader_stages;

}; // struct Pass
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Nothing changed here.&lt;br&gt;
A pass is a container of one of more shaders.&lt;br&gt;
In general we will use the term &lt;em&gt;shader state&lt;/em&gt; to describe the shaders that needs to be bound to the pipeline.&lt;br&gt;
Most common are the couple Vertex and Fragment shaders, or the Compute by itself.&lt;/p&gt;

&lt;p&gt;Last is the Shader itself:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// C++
//
struct Shader {

    StringRef                   name;

    std::vector&amp;lt;Pass*&amp;gt;          passes;
    std::vector&amp;lt;Property*&amp;gt;      properties;

}; // struct Shader
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Being just a collection of passes.&lt;br&gt;
Again we are seeing the properties here, that I will talk later on in the article.&lt;/p&gt;

&lt;p&gt;These will be used to &amp;lsquo;bake&amp;rsquo; data into a &amp;lsquo;bhfx&amp;rsquo; (binary HFX) file.&lt;/p&gt;

&lt;h3 id=&#34;bhfx-layout&#34;&gt;BHFX layout&lt;/h3&gt;

&lt;p&gt;In order to maximise efficiency, we are packing the data in the way we will use it.&lt;br&gt;
The file is divided in two main sections: common and passes.&lt;br&gt;
The overall layout is as follows:&lt;/p&gt;







&lt;figure&gt;

  &lt;a data-fancybox=&#34;&#34; href=&#34;BHFX_Format.png&#34; &gt;

&lt;img src=&#34;BHFX_Format.png&#34; &gt;
&lt;/a&gt;

&lt;/figure&gt;


&lt;p&gt;The trick is to have the offset for each section easy to access.&lt;/p&gt;

&lt;p&gt;The &lt;em&gt;pass section&lt;/em&gt; contains several informations as following:&lt;/p&gt;







&lt;figure&gt;

  &lt;a data-fancybox=&#34;&#34; href=&#34;BHFX_Pass.png&#34; &gt;

&lt;img src=&#34;BHFX_Pass.png&#34; &gt;
&lt;/a&gt;

&lt;/figure&gt;


&lt;p&gt;As we will see later we include shaders, resources layout and other data based on our target API (Hydra Graphics).&lt;/p&gt;

&lt;h3 id=&#34;writing-the-bhfx-file&#34;&gt;Writing the BHFX file&lt;/h3&gt;

&lt;p&gt;To write our file, we need to parse the HFX file.&lt;br&gt;
A quick code could be something like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// C++
//

...

char* text = ReadEntireFileIntoMemory( &amp;quot;..\\data\\SimpleFullscreen.hfx&amp;quot;, nullptr );
initLexer( &amp;amp;lexer, (char*)text, data_buffer );

hfx::initParser( &amp;amp;effect_parser, &amp;amp;lexer );
hfx::generateAST( &amp;amp;effect_parser );

    
hfx::initCodeGenerator( &amp;amp;hfx_code_generator, &amp;amp;effect_parser, 4096, 5 );

hfx::compileShaderEffectFile( &amp;amp;hfx_code_generator, &amp;quot;..\\data\\&amp;quot;, &amp;quot;SimpleFullscreen.bhfx&amp;quot; );
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here we are parsing the file (generateAST) and then using that to &lt;em&gt;compile&lt;/em&gt; our shader effect file. This is where the magic happens.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// C++
//
void compileShaderEffectFile( CodeGenerator* code_generator, const char* path, const char* filename ) {
    // Create the output file
    FILE* output_file;

    // Alias the StringBuffer for better readability.
    StringBuffer&amp;amp; filename_buffer = code_generator-&amp;gt;string_buffers[0];

    // Concatenate name
    filename_buffer.clear();
    filename_buffer.append( path );
    filename_buffer.append( filename );
    fopen_s( &amp;amp;output_file, filename_buffer.data, &amp;quot;wb&amp;quot; );

    if ( !output_file ) {
        printf( &amp;quot;Error opening file. Aborting. \n&amp;quot; );
        return;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Typical file creation preamble.&lt;br&gt;
Concatenate the file using the StringBuffer, and try to create it.&lt;/p&gt;

&lt;p&gt;Remember that overall the file structure is:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;File header&lt;/li&gt;
&lt;li&gt;Pass offset list&lt;/li&gt;
&lt;li&gt;Pass sections&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Let&amp;rsquo;s start with the file header:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    const uint32_t pass_count = (uint32_t)code_generator-&amp;gt;parser-&amp;gt;passes.size();
    
    ShaderEffectFile shader_effect_file;
    shader_effect_file.num_passes = pass_count;    

    fwrite( &amp;amp;shader_effect_file, sizeof(ShaderEffectFile), 1, output_file );
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In this case we are writing straight to the file, because it is an in-order operation with the file layout.&lt;br&gt;
For the rest of the file writing we will need to use String Buffers to accumulate data out-of-order and then write the file in the correct order.&lt;br&gt;
Think of the &lt;em&gt;Pass Offset List&lt;/em&gt;: to calculate the offsets we need to know the size of the passes. To know the size we need to finalize the pass data. To finalize the pass data we need to finalize shaders, and that means adding the includes.&lt;/p&gt;

&lt;p&gt;Again for code clarity I use aliases like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    StringBuffer&amp;amp; code_buffer = code_generator-&amp;gt;string_buffers[1];
    StringBuffer&amp;amp; pass_offset_buffer = code_generator-&amp;gt;string_buffers[2];
    StringBuffer&amp;amp; shader_offset_buffer = code_generator-&amp;gt;string_buffers[3];
    StringBuffer&amp;amp; pass_buffer = code_generator-&amp;gt;string_buffers[4];
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let&amp;rsquo;s continue.&lt;br&gt;
We start tracking the pass section memory offset knowing that it will be after the &lt;em&gt;header&lt;/em&gt; and the pass offset list:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    pass_offset_buffer.clear();
    pass_buffer.clear();

    // Pass memory offset starts after header and list of passes offsets.
    uint32_t pass_offset = sizeof( ShaderEffectFile ) + sizeof(uint32_t) * pass_count;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now into the most interesting part. We will avoid talking about the resource layout part, that will be added later.&lt;br&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    // Pass Section:
    // ----------------------------------------------------------------------------------------
    // Shaders count | Name | Shader Offset+Count List | Shader Code 0, Shader Code 1
    // ----------------------------------------------------------------------------------------

    ShaderEffectFile::PassHeader pass_header;

    for ( uint32_t i = 0; i &amp;lt; pass_count; i++ ) {

        pass_offset_buffer.append( &amp;amp;pass_offset, sizeof( uint32_t ) );

        const Pass&amp;amp; pass = code_generator-&amp;gt;parser-&amp;gt;passes[i];

        const uint32_t pass_shader_stages = (uint32_t)pass.shader_stages.size();
        const uint32_t pass_header_size = pass_shader_stages * sizeof( ShaderEffectFile::Chunk ) + sizeof( ShaderEffectFile::PassHeader );
        uint32_t current_shader_offset = pass_header_size;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We start iterating the passes and calculate the shader offset.&lt;br&gt;
Shader Chunks (the actual shader code) are written after the Pass Header and the dynamic list of shader chunk offset and size.&lt;br&gt;
Next we will calculate the offsets of the single shaders AFTER we finalize the code - that means after the includes are added!&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        shader_offset_buffer.clear();
        code_buffer.clear();

        for ( size_t s = 0; s &amp;lt; pass.shader_stages.size(); ++s ) {
            const Pass::ShaderStage shader_stage = pass.shader_stages[s];

            appendFinalizedCode( path, shader_stage.stage, shader_stage.code, filename_buffer, code_buffer, true, constants_buffer );
            updateOffsetTable( &amp;amp;current_shader_offset, pass_header_size, shader_offset_buffer, code_buffer );
        }

        // Update pass offset
        pass_offset += code_buffer.current_size + shader_offset;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;At this point we have code_buffer containing all the shaders of the pass one after another (null terminated) and we can update the pass offset for the next pass.&lt;br&gt;
We also calculated the single shader offsets with the &lt;em&gt;updateOffsetTable&lt;/em&gt; method in shader_offset_buffer.&lt;br&gt;
We need to finalize the Pass Header and then we can merge the pass memory in one block and proceed to the next pass:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        // Fill Pass Header
        copy( pass.name, pass_header.name, 32 );
        pass_header.num_shader_chunks = pass.num_shaders;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is a very IMPORTANT part.&lt;br&gt;
Merge in the pass_buffer all the pass section currently calculated: pass header, the single shader code offsets and the shader code itself.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        pass_buffer.append( (void*)&amp;amp;pass_header, sizeof( ShaderEffectFile::PassHeader ) );
        pass_buffer.append( shader_offset_buffer );
        pass_buffer.append( code_buffer );
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;After we finished with all the passes, we have 2 buffers: one containing the pass offset list, the other the pass sections.&lt;br&gt;
We can write them off in the correct order finally and close the file:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    fwrite( pass_offset_buffer.data, pass_offset_buffer.current_size, 1, output_file );
    fwrite( pass_buffer.data, pass_buffer.current_size, 1, output_file );
    
    fclose( output_file );
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can see &lt;em&gt;why&lt;/em&gt; we chose this format when looking at the code to actually create a &lt;em&gt;shader state&lt;/em&gt;.&lt;br&gt;
First of all this is the struct to create a shader state:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// hydra_graphics.h
//
struct ShaderCreation {

    struct Stage {

        ShaderStage::Enum           type                = ShaderStage::Compute;
        const char*                 code                = nullptr;

    }; // struct Stage

    const Stage*                    stages              = nullptr;
    const char*                     name                = nullptr;

    uint32_t                        stages_count        = 0;

}; // struct ShaderCreation
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It is very simple, each stage has a code and type.&lt;br&gt;
A shader state can have one or more stages.&lt;br&gt;
This was already the case in OpenGL - compiling shaders and linking them - so the interface is similar - but it maps well to Vulkan/D3D12 as well, in which the &lt;em&gt;Pipeline State&lt;/em&gt;, that describe almost everything the GPU needs to draw, needs an unique set of vertex/fragment/compute shaders.&lt;br&gt;
Anyway, we embed this data already in the &lt;em&gt;binary HFX file&lt;/em&gt;, and thus we can easily create a shader state like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;static void compile_shader_effect_pass( hydra::graphics::Device&amp;amp; device, char* hfx_memory, 
                                        uint16_t pass_index, hydra::graphics::ShaderHandle&amp;amp; out_shader ) {
    using namespace hydra;

    // Get pass section memory
    char* pass = hfx::getPassMemory( hfx_memory, pass_index );
    hfx::ShaderEffectFile::PassHeader* pass_header = (hfx::ShaderEffectFile::PassHeader*)pass;

    const uint32_t shader_count = pass_header-&amp;gt;num_shader_chunks;    
    graphics::ShaderCreation::Stage* stages = new graphics::ShaderCreation::Stage[shader_count];

    // Get individual shader code and type
    for ( uint16_t i = 0; i &amp;lt; shader_count; i++ ) {
        hfx::getShaderCreation( shader_count, pass, i, &amp;amp;stages[i] );
    }

    graphics::ShaderCreation first_shader = {};
    first_shader.stages = stages;
    first_shader.stages_count = shader_count;
    first_shader.name = pass_header-&amp;gt;name;

    out_shader = device.create_shader( first_shader );

    delete stages;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Nothing really interesting here, but we read the file in memory and use the offsets we store to access the different sections of the file.&lt;br&gt;&lt;/p&gt;

&lt;p&gt;To access the &lt;em&gt;Pass Section&lt;/em&gt; we first need to read its memory offset and then read from there.&lt;br&gt;
Remember from before that the offset is in the list AFTER the ShaderEffectFile header, and it is a single uint32:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;char* getPassMemory( char* hfx_memory, uint32_t index ) {
    
    // Read offset form list after the ShaderEffectFile header.
    const uint32_t pass_offset = *(uint32_t*)(hfx_memory + sizeof( ShaderEffectFile ) + (index * sizeof( uint32_t )));

    return hfx_memory + pass_offset;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;From the &lt;em&gt;pass offset&lt;/em&gt;, the list of shader chunks (that are defined as code offset and size) is right after the &lt;em&gt;pass header&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;void getShaderCreation( uint32_t shader_count, char* pass_memory, uint32_t index,
                        hydra::graphics::ShaderCreation::Stage* shader_creation ) {

    char* shader_offset_list_start = pass_memory + sizeof( ShaderEffectFile::PassHeader );
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Read the single shader offset and access the memory there:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    const uint32_t shader_offset = *(uint32_t*)(shader_offset_list_start + (index * sizeof( ShaderEffectFile::Chunk )));
    char* shader_chunk_start = pass_memory + shader_offset;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The baked informations are first the type (as a single char, but called hfx::ShaderEffectFile::ChunkHeader in case we change it) and the actual shader code is right after!&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    shader_creation-&amp;gt;type = (hydra::graphics::ShaderStage::Enum)(*shader_chunk_start);
    shader_creation-&amp;gt;code = (const char*)(shader_chunk_start + sizeof( hfx::ShaderEffectFile::ChunkHeader ));
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In this case I chose to bake the file instead of generating a header file - just cause I can reuse this code for every shader effect. I could have generated an header instead of the binary BHFX file, but then including it would mean that you need to recompile at every change.&lt;br&gt;
We will see some areas in which we can have both approaches!&lt;/p&gt;

&lt;p&gt;Finally done with the new embedded format, let&amp;rsquo;s see the new features!&lt;/p&gt;

&lt;h2 id=&#34;brainstorming-what-features-are-needed&#34;&gt;Brainstorming: what features are needed ?&lt;/h2&gt;

&lt;p&gt;We already talked about the features at the beginning of the articles, but let&amp;rsquo;s write them again to refresh our memory:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Shader constants generation&lt;/li&gt;
&lt;li&gt;Shader resource bindings&lt;/li&gt;
&lt;li&gt;Render states (depth stencil, blend, rasterization) &lt;strong&gt;(in the next article)&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;Render pass hints for a future framegraph &lt;strong&gt;(in the next article)&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;There are few articles around this subject, but the most complete is from the amazing guys at &lt;a href=&#34;https://ourmachinery.com/&#34; target=&#34;_blank&#34;&gt;OurMachinery&lt;/a&gt;, and in particular &lt;a href=&#34;https://ourmachinery.com/post/the-machinery-shader-system-part-2/&#34; target=&#34;_blank&#34;&gt;this article&lt;/a&gt;.&lt;br&gt;
These guys does (as always honestly) an amazing job in describing the problem we are facing and the solutions, and how enriching a shader language can make a huge difference in making better rendering (faster iteration time, less error prone, more artist friendly..) so I would suggest to read those articles (and in general any article/presentation/blog post they write!).&lt;/p&gt;

&lt;p&gt;We will go through each feature in depth so get ready!&lt;/p&gt;

&lt;h2 id=&#34;constants-artists-programmers-both&#34;&gt;Constants: artists, programmers, both ?&lt;/h2&gt;

&lt;p&gt;Constants&amp;hellip;uniforms&amp;hellip;whatever name you choose, they represent the same concept: &lt;em&gt;numerical properties&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Even if they are a simple concept, still it is hard to make both rendering citizens happy: artists and programmers!&lt;/p&gt;

&lt;p&gt;Artists want tweakable UI, simple variables and fast iteration.&lt;br&gt;
Programmers want optimal layout, more CPU calculated variables possible, and ultimate control.&lt;br&gt;
How to make them both happy ?&lt;/p&gt;

&lt;p&gt;I brainstormed and designed for few days (well evenings) to solve this problem.&lt;br&gt;
One thought that came to me is that artists want to create a &lt;em&gt;material interface&lt;/em&gt;, something they can tweak and change easily, and when you want to quickly prototype something, create and such, you don&amp;rsquo;t want to deal with low-level resource management and such.&lt;br&gt;
Let&amp;rsquo;s solve this first: &lt;strong&gt;give artists a simple way of creating a material interface&lt;/strong&gt;!&lt;/p&gt;

&lt;p&gt;After searching for a bit, I chose to use a syntax very similar to Unity ShaderLab. Let&amp;rsquo;s see the HFX (finally!):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// .HFX
//
// For the artist: create a material interface.
properties {

    // Using Unity ShaderLab syntax:
    // AORemapMin0(&amp;quot;AORemapMin0&amp;quot;, Range(0.0, 1.0)) = 0.0
    scale(&amp;quot;Scale&amp;quot;, Float) = 32.00
    modulo(&amp;quot;Modulo&amp;quot;, Float) = 2.0
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We added a new section in the language, named &amp;ldquo;&lt;em&gt;properties&lt;/em&gt;&amp;rdquo;.&lt;br&gt;
Why this name ?&lt;br&gt;
Because properties contains both &lt;em&gt;numerical properties and textures&lt;/em&gt;!&lt;br&gt;
The name makes sense in this way. Naming &amp;lsquo;constants&amp;rsquo; and having also textures, not.&lt;/p&gt;

&lt;p&gt;There are 2 possible &lt;em&gt;outputs&lt;/em&gt; from this, one that is pure code-generation and the other that is more data-driven.
I will dwelve into the code-generation one and talk about the data-driven one in another post.&lt;/p&gt;

&lt;p&gt;There are 3 parts for the generated code of the properties:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Properties UI&lt;/li&gt;
&lt;li&gt;GPU-ready constant buffer&lt;/li&gt;
&lt;li&gt;API-dependant buffer&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;For the Properties UI, we want to generate something like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// C++
struct LocalConstantsUI {

    float                    scale                = 32.000000f;
    float                    modulo                = 2.000000f;

    void reflectMembers() {
        ImGui::InputScalar( &amp;quot;Scale&amp;quot;, ImGuiDataType_Float, &amp;amp;scale);
        ImGui::InputScalar( &amp;quot;Modulo&amp;quot;, ImGuiDataType_Float, &amp;amp;modulo);
    }

    void reflectUI() {
        ImGui::Begin( &amp;quot;LocalConstants&amp;quot; );
        reflectMembers();
        ImGui::End();
    }

}; // struct LocalConstantsUI
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For the GPU-ready constants, we want to have a both a GPU and a CPU representation like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// C++
//
struct LocalConstants {

    float                    scale                = 32.000000f;
    float                    modulo                = 2.000000f;
    float                    pad_tail[2];

}; // struct LocalConstants

// GLSL
//
layout (std140, binding=7) uniform LocalConstants {

    float                    scale;
    float                    modulo;

    float                    pad[2];

} local_constants;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And for the API-dependant buffer, we want to create code that takes care of everything for us. This is the real deal here - and something we will revisit in next articles to show some advanced features.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;void create( hydra::graphics::Device&amp;amp; device ) {

    using namespace hydra;

    graphics::BufferCreation constants_creation = {};
    constants_creation.type = graphics::BufferType::Constant;
    constants_creation.name = &amp;quot;LocalConstants&amp;quot;;
    constants_creation.usage = graphics::ResourceUsageType::Dynamic;

    // NOTE: using LocalConstants struct - is the GPU ready one with padding and such!
    constants_creation.size = sizeof( LocalConstants );
    // Struct is initialized with default values already, so it is safe to copy it to the GPU.
    constants_creation.initial_data = &amp;amp;constants;

    buffer = device.create_buffer( constants_creation );
}

void destroy( hydra::graphics::Device&amp;amp; device ) {

    device.destroy_buffer( buffer );
}

void updateUI( hydra::graphics::Device&amp;amp; device ) {
    // Draw UI
    constantsUI.reflectUI();

    // TODO:
    // Ideally there should be a way to tell if a variable has changed and update only in that case.
    
    // Map buffer to GPU and upload parameters from the UI
    hydra::graphics::MapBufferParameters map_parameters = { buffer.handle, 0, 0 };

    LocalConstants* buffer_data = (LocalConstants*)device.map_buffer( map_parameters );

    if ( buffer_data ) {
        buffer_data-&amp;gt;scale = constantsUI.scale;
        buffer_data-&amp;gt;modulo = constantsUI.modulo;
        device.unmap_buffer( map_parameters );
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For the sake of the example this could be a possible implementation - but really depends on the rendering API.
Let&amp;rsquo;s quickly check parsing and code-generation.&lt;/p&gt;

&lt;h3 id=&#34;constants-parsing&#34;&gt;Constants Parsing&lt;/h3&gt;

&lt;p&gt;To parse the new &lt;strong&gt;property&lt;/strong&gt; section, there is the new method &lt;code&gt;void declarationProperties( Parser* parser )&lt;/code&gt; that iterates through all properties, and inside that the &lt;code&gt;void declarationProperty( Parser* parser, const StringRef&amp;amp; name )&lt;/code&gt; one.&lt;/p&gt;

&lt;p&gt;We are parsing the following HFX syntax:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// Syntax
//
identifier(string, identifier[(arguments)]) [= default_value]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;With this is an example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// HFX
//
properties {
    scale(&amp;quot;Scale&amp;quot;, Float) = 32.0
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We will add a simple backtracking to the parsing because of the optional parameters.&lt;br&gt;
Let&amp;rsquo;s check the code!&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;inline void declarationProperty( Parser* parser, const StringRef&amp;amp; name ) {
    Property* property = new Property();

    // Cache name
    property-&amp;gt;name = name;

    Token token;

    if ( !expectToken( parser-&amp;gt;lexer, token, Token::Token_OpenParen ) ) {
        return;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We just parsed the property name and the &amp;lsquo;(&amp;rsquo;. Next is the string containing the UI name:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    // Advance to the string representing the ui_name
    if ( !expectToken( parser-&amp;gt;lexer, token, Token::Token_String ) ) {
        return;
    }

    property-&amp;gt;ui_name = token.text;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Saved the ui name and then we have the type.&lt;br&gt;
Types can be &lt;em&gt;Float, Int, Range, Texture, Vector, Color&lt;/em&gt; and we will simply parse their text and convert it to an enum that we will use in the code generation phase.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    if ( !expectToken( parser-&amp;gt;lexer, token, Token::Token_Comma ) ) {
        return;
    }

    // Next is the identifier representing the type name
    if ( !expectToken( parser-&amp;gt;lexer, token, Token::Token_Identifier ) ) {
        return;
    }

    // Parse property type and convert it to an enum
    property-&amp;gt;type = propertyTypeIdentifier( token );
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now will come the most complicated part.&lt;br&gt;
We have optional &amp;lsquo;(&amp;rsquo; open parenthesis for the parameters if the type needs it.&lt;br&gt;
For the length of code and article, I skip this part and will add it in next article!&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    // If an open parenthesis is present, then parse the ui arguments.
    nextToken( parser-&amp;gt;lexer, token );
    if ( token.type == Token::Token_OpenParen ) {
        property-&amp;gt;ui_arguments = token.text;

        while ( !equalToken( parser-&amp;gt;lexer, token, Token::Token_CloseParen ) ) {
            // TODO:
            // Parse parameters!
        }

        // Advance to the last close parenthesis
        nextToken( parser-&amp;gt;lexer, token );

        property-&amp;gt;ui_arguments.length = token.text.text - property-&amp;gt;ui_arguments.text;
    }

    if ( !checkToken( parser-&amp;gt;lexer, token, Token::Token_CloseParen ) ) {
        return;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;At this point we can either be at the end of the property or we could have a &amp;lsquo;=&amp;rsquo; token to add a default value.
Being that the Lexer class is small, we can backtrack by saving the current Lexer status:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    // Cache lexer status and advance to next token.
    // If the token is &#39;=&#39; then we parse the default value.
    // Otherwise backtrack by one token.
    Lexer cached_lexer = *parser-&amp;gt;lexer;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we can advance to the next token and:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;If the token is &amp;lsquo;=&amp;rsquo;, parse the default value.&lt;/li&gt;

&lt;li&gt;&lt;p&gt;If not, backtrack the position of the Lexer and finish the parsing.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;nextToken( parser-&amp;gt;lexer, token );

// At this point only the optional default value is missing, otherwise the parsing is over.
if ( token.type == Token::Token_Equals ) {
    nextToken( parser-&amp;gt;lexer, token );
        
    if ( token.type = Token::Token_Number ) {
        // Cache the data buffer entry index into the property for later retrieval.
        property-&amp;gt;data_index = parser-&amp;gt;lexer-&amp;gt;data_buffer-&amp;gt;current_entries - 1;
    }
    else {
        // TODO:
        // Handle vectors, colors and non single number default values
    }
}
else {
    *parser-&amp;gt;lexer = cached_lexer;
}

parser-&amp;gt;shader.properties.push_back( property );
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;An interesting point is that the &lt;em&gt;numbers&lt;/em&gt; are parsed in a &lt;strong&gt;DataBuffer&lt;/strong&gt;, and during the parsing of the token we will add the number to it.&lt;br&gt;
To retrieve it, we have the &lt;code&gt;data_index&lt;/code&gt; field of the &lt;code&gt;Property&lt;/code&gt; struct.&lt;br&gt;
Also here, for the sake of &amp;lsquo;brevity&amp;rsquo;, I am handling only floats and ints. Vectors, colors and texture property should be easy to add.&lt;/p&gt;

&lt;p&gt;For vectors and colors we should parse a list of them and save them into the data buffer.&lt;/p&gt;

&lt;p&gt;For textures we should just save the default value as text and use it in the code-generation part.&lt;/p&gt;

&lt;h3 id=&#34;code-generation&#34;&gt;Code Generation&lt;/h3&gt;

&lt;p&gt;This should be pretty straight forward.&lt;br&gt;
We can iterate the properties and generate both a C++ struct and a HLSL/GLSL buffer.&lt;br&gt;
The only thing to be concerned is the padding: on the GPU normally the alignment is 16 bytes, so we can track that and insert padding when generating the code.&lt;br&gt;&lt;/p&gt;

&lt;p&gt;In the method &lt;code&gt;void generateShaderResourceHeader( CodeGenerator* code_generator, const char* path )&lt;/code&gt; we can see how we generate the different code for C++:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// C++
//
// Beginning

fprintf( output_file, &amp;quot;\n#pragma once\n#include &amp;lt;stdint.h&amp;gt;\n#include \&amp;quot;hydra_graphics.h\&amp;quot;\n\n// This file is autogenerated!\nnamespace &amp;quot; );

fwrite( shader.name.text, shader.name.length, 1, output_file );
fprintf( output_file, &amp;quot; {\n\n&amp;quot; );

// Preliminary sections
constants_ui.append( &amp;quot;struct LocalConstantsUI {\n\n&amp;quot; );

cpu_constants.append( &amp;quot;struct LocalConstants {\n\n&amp;quot; );

constants_ui_method.append(&amp;quot;\tvoid reflectMembers() {\n&amp;quot;);

buffer_class.append( &amp;quot;struct LocalConstantsBuffer {\n\n\thydra::graphics::BufferHandle\tbuffer;\n&amp;quot; );
buffer_class.append( &amp;quot;\tLocalConstants\t\t\t\t\tconstants;\n\tLocalConstantsUI\t\t\t\tconstantsUI;\n\n&amp;quot; );
buffer_class.append( &amp;quot;\tvoid create( hydra::graphics::Device&amp;amp; device ) {\n\t\tusing namespace hydra;\n\n&amp;quot; );
buffer_class.append( &amp;quot;\t\tgraphics::BufferCreation constants_creation = { graphics::BufferType::Constant, graphics::ResourceUsageType::Dynamic, sizeof( LocalConstants ), &amp;amp;constants, \&amp;quot;LocalConstants\&amp;quot; };\n&amp;quot; );
buffer_class.append( &amp;quot;\t\tbuffer = device.create_buffer( constants_creation );\n\t}\n\n&amp;quot; );
buffer_class.append( &amp;quot;\tvoid destroy( hydra::graphics::Device&amp;amp; device ) {\n\t\tdevice.destroy_buffer( buffer );\n\t}\n\n&amp;quot; );
buffer_class.append( &amp;quot;\tvoid updateUI( hydra::graphics::Device&amp;amp; device ) {\n\t\t// Draw UI\n\t\tconstantsUI.reflectUI();\n\t\t// Update constants from UI\n&amp;quot; );
buffer_class.append( &amp;quot;\t\thydra::graphics::MapBufferParameters map_parameters = { buffer.handle, 0, 0 };\n&amp;quot; );
buffer_class.append( &amp;quot;\t\tLocalConstants* buffer_data = (LocalConstants*)device.map_buffer( map_parameters );\n\t\tif (buffer_data) {\n&amp;quot; );

// For GPU the struct must be 16 bytes aligned. Track alignment
uint32_t gpu_struct_alignment = 0;

DataBuffer* data_buffer = code_generator-&amp;gt;parser-&amp;gt;lexer-&amp;gt;data_buffer;
// For each property write code
for ( size_t i = 0; i &amp;lt; shader.properties.size(); i++ ) {
    hfx::Property* property = shader.properties[i];

    switch ( property-&amp;gt;type ) {
        case Property::Float:
        {
            constants_ui.append(&amp;quot;\tfloat\t\t\t\t\t&amp;quot;);
            constants_ui.append( property-&amp;gt;name );

            cpu_constants.append( &amp;quot;\tfloat\t\t\t\t\t&amp;quot; );
            cpu_constants.append( property-&amp;gt;name );
            
            if ( property-&amp;gt;data_index != 0xffffffff ) {
                float value = 0.0f;
                getData( data_buffer, property-&amp;gt;data_index, value );
                constants_ui.append( &amp;quot;\t\t\t\t= %ff&amp;quot;, value );
                cpu_constants.append( &amp;quot;\t\t\t\t= %ff&amp;quot;, value );
            }

            constants_ui.append( &amp;quot;;\n&amp;quot; );

            cpu_constants.append( &amp;quot;;\n&amp;quot; );

            constants_ui_method.append(&amp;quot;\t\tImGui::InputScalar( \&amp;quot;&amp;quot;);
            constants_ui_method.append( property-&amp;gt;ui_name );
            constants_ui_method.append( &amp;quot;\&amp;quot;, ImGuiDataType_Float, &amp;amp;&amp;quot; );
            constants_ui_method.append( property-&amp;gt;name );
            constants_ui_method.append( &amp;quot;);\n&amp;quot; );

            // buffer_data-&amp;gt;scale = constantsUI.scale;
            buffer_class.append(&amp;quot;\t\t\tbuffer_data-&amp;gt;&amp;quot;);
            buffer_class.append( property-&amp;gt;name );
            buffer_class.append( &amp;quot; = constantsUI.&amp;quot; );
            buffer_class.append( property-&amp;gt;name );
            buffer_class.append( &amp;quot;;\n&amp;quot; );

            ++gpu_struct_alignment;

            break;
        }
    }
}

// Post-property sections
constants_ui.append( &amp;quot;\n&amp;quot; );

constants_ui_method.append( &amp;quot;\t}\n\n&amp;quot; );
constants_ui_method.append( &amp;quot;\tvoid reflectUI() {\n\t\tImGui::Begin( \&amp;quot;LocalConstants\&amp;quot; );\n&amp;quot; );
constants_ui_method.append( &amp;quot;\t\treflectMembers();\n\t\tImGui::End();\n\t}\n\n&amp;quot; );
constants_ui_method.append( &amp;quot;}; // struct LocalConstantsUI\n\n&amp;quot; );

// Add tail padding data
uint32_t tail_padding_size = 4 - (gpu_struct_alignment % 4);
cpu_constants.append( &amp;quot;\tfloat\t\t\t\t\tpad_tail[%u];\n\n&amp;quot;, tail_padding_size );

cpu_constants.append( &amp;quot;}; // struct LocalConstants\n\n&amp;quot; );

buffer_class.append( &amp;quot;\t\t\tdevice.unmap_buffer( map_parameters );\n\t\t}\n\t}\n}; // struct LocalConstantBuffer\n\n&amp;quot; );

fwrite( constants_ui.data, constants_ui.current_size, 1, output_file );
fwrite( constants_ui_method.data, constants_ui_method.current_size, 1, output_file );
fwrite( cpu_constants.data, cpu_constants.current_size, 1, output_file );
fwrite( buffer_class.data, buffer_class.current_size, 1, output_file );


// End
fprintf( output_file, &amp;quot;} // namespace &amp;quot; );
fwrite( shader.name.text, shader.name.length, 1, output_file );
fprintf( output_file, &amp;quot;\n\n&amp;quot; );

fclose( output_file );
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This piece of code will generate a constant buffer from the properties:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// GLSL
//
static void generateConstantsCode( const Shader&amp;amp; shader, StringBuffer&amp;amp; out_buffer ) {
    if ( !shader.properties.size() ) {
        return;
    }

    // Add the local constants into the code.
    out_buffer.append( &amp;quot;\n\t\tlayout (std140, binding=7) uniform LocalConstants {\n\n&amp;quot; );

    // For GPU the struct must be 16 bytes aligned. Track alignment
    uint32_t gpu_struct_alignment = 0;

    const std::vector&amp;lt;Property*&amp;gt;&amp;amp; properties = shader.properties;
    for ( size_t i = 0; i &amp;lt; shader.properties.size(); i++ ) {
        hfx::Property* property = shader.properties[i];

        switch ( property-&amp;gt;type ) {
            case Property::Float:
            {
                out_buffer.append( &amp;quot;\t\t\tfloat\t\t\t\t\t&amp;quot; );
                out_buffer.append( property-&amp;gt;name );
                out_buffer.append( &amp;quot;;\n&amp;quot; );

                ++gpu_struct_alignment;
                break;
            }
        }
    }

    uint32_t tail_padding_size = 4 - (gpu_struct_alignment % 4);
    out_buffer.append( &amp;quot;\t\t\tfloat\t\t\t\t\tpad_tail[%u];\n\n&amp;quot;, tail_padding_size );
    out_buffer.append( &amp;quot;\t\t} local_constants;\n\n&amp;quot; );
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;expert-constants-an-interesting-problem&#34;&gt;Expert constants: an interesting problem&lt;/h3&gt;

&lt;p&gt;A problem many times surfaces is that the material interface does not correspond to the buffer sent to the GPU, because the programmers will do the following:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Add &lt;em&gt;system&lt;/em&gt; constants, that don&amp;rsquo;t need a UI&lt;/li&gt;
&lt;li&gt;Change order of the constants&lt;/li&gt;
&lt;li&gt;Change constants to more GPU friendly values, calculating some stuff on the CPU&lt;/li&gt;
&lt;li&gt;Pack constants into smaller ones&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;This is an interesting topic and I&amp;rsquo;ll cover it in another article, but a simple solution would be to add a mapping between the GPU constants and the UI, so that we can separate the UI constants from the GPU ones.&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;ll give a brief example but it would be too much for this article and will not be included in the source code.&lt;/p&gt;

&lt;p&gt;Basically we are trying to create a mapping between the material interface:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// C++
struct LocalConstantsUI {

    float                    scale                = 32.000000f;
    float                    modulo                = 2.000000f;

    void reflectMembers() {
        ImGui::InputScalar( &amp;quot;Scale&amp;quot;, ImGuiDataType_Float, &amp;amp;scale);
        ImGui::InputScalar( &amp;quot;Modulo&amp;quot;, ImGuiDataType_Float, &amp;amp;modulo);
    }

    void reflectUI() {
        ImGui::Begin( &amp;quot;LocalConstants&amp;quot; );
        reflectMembers();
        ImGui::End();
    }

}; // struct LocalConstantsUI
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And the GPU constants:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// C++
struct LocalConstants {

    float                    scale                = 32.000000f;
    float                    modulo                = 2.000000f;
    float                    pad_tail[2];

}; // struct LocalConstants
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We could enhance HFX with some syntax to mark the &lt;em&gt;derivate&lt;/em&gt; properties and just add the &lt;em&gt;system&lt;/em&gt; ones in an explicit buffer layout, and add a &lt;em&gt;layout&lt;/em&gt; section in the HFX:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// HFX

properties {

    // Using Unity ShaderLab syntax:
    scale(&amp;quot;Scale&amp;quot;, Range(0.0, 100.0)) = 100.0
    modulo(&amp;quot;Modulo&amp;quot;, Float) = 2.0
}

layout {
    CBuffer LocalConstants {
        float4x4            world_view_projection;    // &#39;System&#39; variable

        float               scale01 = (scale);       // Silly normalized version of scale interface property
        float               modulo;
        float               pad[2];
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;we could completely override the automatic constant buffer generation from the properties.&lt;br&gt;
With this we can:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Add a system variable like &lt;em&gt;world_view_projection&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;Flag the property &lt;strong&gt;scale&lt;/strong&gt; as UI only, by saying that property &lt;strong&gt;scale01&lt;/strong&gt; uses it.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;I think that with this syntax both artists and programmers can be happy together!&lt;br&gt;
I will try to work on this on a later article.&lt;/p&gt;

&lt;h2 id=&#34;resource-bindings-vulkan-and-d3d12-mentality&#34;&gt;Resource bindings: Vulkan and D3D12 mentality&lt;/h2&gt;

&lt;p&gt;As stated multiple times, the shift in mentality is towards the new APIs, and that includes the concept of &lt;strong&gt;resource lists&lt;/strong&gt;.&lt;br&gt;
The problem is that we don&amp;rsquo;t want artists to have to handle this kind of things - especially if you want to quickly prototype things!&lt;br&gt;
But at the same time, we want programmers to have the possibility to optimize the shaders the artists gave them.&lt;br&gt;
What is the solution?&lt;br&gt;
Simple: creating an optional &lt;em&gt;resource layout&lt;/em&gt; section and &lt;strong&gt;automatically&lt;/strong&gt; generate it if not present, so that artists (and not only) can happily create amazing tech and THEN worry about these details!&lt;/p&gt;

&lt;h3 id=&#34;automatic-resource-layout&#34;&gt;Automatic Resource Layout&lt;/h3&gt;

&lt;p&gt;The easiest way to handle resource layout is to make them &lt;strong&gt;SIMPLE&lt;/strong&gt;. Remember the &lt;strong&gt;K.I.S.S. principle&lt;/strong&gt;.&lt;br&gt;
In this case it means that we can create a Resource List for each pass, that will contain:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;One constant/uniform buffer containing all the properties&lt;/li&gt;
&lt;li&gt;All the textures used by the shader&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;How can we achieve that ?&lt;/p&gt;

&lt;p&gt;We already saw how we can generate the constant buffer from the properties in the previous section.
For textures we have a couple of options.&lt;/p&gt;

&lt;h4 id=&#34;list-of-textures&#34;&gt;List of Textures&lt;/h4&gt;

&lt;p&gt;Being in automation land, there are 2 ways to add texture dependencies:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Use reflection mechanism from the target shader language&lt;/li&gt;
&lt;li&gt;Parse identifiers in the current finalized shader&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;For the sake of fun we will look into the second of course!&lt;br&gt;
If we go back to &lt;code&gt;void declarationGlsl( Parser* parser )&lt;/code&gt;, we can add a new method to parse the keyword:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// Parse hash for includes and defines
if ( token.type == Token::Token_Hash ) {
    // Get next token and check which directive is
    nextToken( parser-&amp;gt;lexer, token );

    directiveIdentifier( parser, token, code_fragment );
}
else if ( token.type == Token::Token_Identifier ) {        &amp;lt;------------  New Code!

    // Parse uniforms to add resource dependencies if not explicit in the HFX file.
    if ( expectKeyword( token.text, 7, &amp;quot;uniform&amp;quot; ) ) {
        nextToken( parser-&amp;gt;lexer, token );

        uniformIdentifier( parser, token, code_fragment );
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In this way it will search for the identifier &lt;em&gt;uniform&lt;/em&gt; and search for the other identifiers. This is GLSL centric of course.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;inline void uniformIdentifier( Parser* parser, const Token&amp;amp; token, CodeFragment&amp;amp; code_fragment ) {
    for ( uint32_t i = 0; i &amp;lt; token.text.length; ++i ) {
        char c = *(token.text.text + i);

        switch ( c ) {
            case &#39;i&#39;:
            {
                if ( expectKeyword( token.text, 7, &amp;quot;image2D&amp;quot; ) ) {
                    // Advance to next token to get the name
                    Token name_token;
                    nextToken( parser-&amp;gt;lexer, name_token );

                    CodeFragment::Resource resource = { hydra::graphics::ResourceType::TextureRW, name_token.text };
                    code_fragment.resources.emplace_back( resource );
                }
                break;
            }

            case &#39;s&#39;:
            {
                if ( expectKeyword( token.text, 9, &amp;quot;sampler2D&amp;quot; ) ) {
                    // Advance to next token to get the name
                    Token name_token;
                    nextToken( parser-&amp;gt;lexer, name_token );

                    CodeFragment::Resource resource = { hydra::graphics::ResourceType::Texture, name_token.text };
                    code_fragment.resources.emplace_back( resource );
                }
                break;
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Should be pretty straight-forward: if you find the identifier for texture, add a resource dependency with type and name to the current code fragment!&lt;br&gt;
Is this the ideal solution ?&lt;br&gt;
Probably not.&lt;br&gt;
But I wanted to show what we can achieve once we have fun with parsing, including the understanding on when to say &lt;strong&gt;NO&lt;/strong&gt; to it!&lt;br&gt;&lt;/p&gt;

&lt;h3 id=&#34;manual-resource-layout&#34;&gt;Manual Resource Layout&lt;/h3&gt;

&lt;p&gt;Now that the effect can work without too much programmer time, it is time to give back to programmers the control they want.&lt;br&gt;
In the previous paragraph about &lt;em&gt;Expert Constants&lt;/em&gt; we talked about adding a new section, called &lt;strong&gt;layout&lt;/strong&gt;.&lt;br&gt;
In this section we can specify the resource list for each &lt;em&gt;pass&lt;/em&gt; manually, and later on in the pass we can reference this lists as used by the pass.&lt;/p&gt;

&lt;p&gt;Going on a more complete solution, layouts &lt;strong&gt;should be included and merged when including other HFX files&lt;/strong&gt;.&lt;br&gt;
This is something we want and we&amp;rsquo;ll look in another post, we can start simple by defining something local:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// HFX
//
// For the developer
layout {
    list LocalCompute {
        cbuffer LocalConstants;

        texture2Drw(rgba8) destination_texture;
    }

    list Local {
        texture2D input_texture;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is a rather simple layout, but let&amp;rsquo;s see it.&lt;br&gt;
First of all, for each &amp;lsquo;list&amp;rsquo; keyword we define a single list with a unique name.&lt;br&gt;
With that, we can reference in the pass which list to use.&lt;br&gt;&lt;/p&gt;

&lt;p&gt;The code that does the parsing is (at this point) pretty straight-forward, both in &lt;code&gt;void declarationResourceList( Parser* parser, ResourceList&amp;amp; resource_list )&lt;/code&gt; and  &lt;code&gt;void resourceBindingIdentifier( Parser* parser, const Token&amp;amp; token, ResourceBinding&amp;amp; binding )&lt;/code&gt;.&lt;br&gt;
I will not go over it, but basically it will parse the resource lists and add them to the shader.&lt;br&gt;
The parsing itself will read the text and create the &lt;code&gt;ResourceSetLayoutCreation::Binding&lt;/code&gt; and add it to the list of the resources.&lt;br&gt;&lt;/p&gt;

&lt;p&gt;We then add a new identifier in the pass to choose which resource list to be used:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// HFX
//
pass FillTexture {

    resources = LocalCompute, ...

    dispatch = 32, 32, 1
    render_pass = compute
    compute = ComputeTest
}

pass ToScreen {

    resources = Local

    render_pass = fullscreen
    vertex = ToScreen
    fragment = ToScreen
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The parsing will happen in &lt;code&gt;void declarationPassResources( Parser* parser, Pass&amp;amp; pass )&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&#34;adding-resource-layout-data-to-binary-hfx&#34;&gt;Adding Resource Layout data to binary HFX&lt;/h3&gt;

&lt;p&gt;So after this amazing journey we are ready to embed those informations into the BHFX and use it right away into the rendering API.&lt;/p&gt;

&lt;p&gt;The big difference is &lt;strong&gt;if the hfx file contains a layout section&lt;/strong&gt;.&lt;br&gt;
If it is not present, then all the informations will be gathered automatically and will be added with the &lt;code&gt;writeAutomaticResourcesLayout&lt;/code&gt; method.&lt;/p&gt;

&lt;p&gt;First we will add the LocalConstant buffer created from the properties:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;static void writeAutomaticResourcesLayout( const hfx::Pass&amp;amp; pass, StringBuffer&amp;amp; pass_buffer, uint32_t&amp;amp; pass_offset ) {

    using namespace hydra::graphics;

    // Add the local constant buffer obtained from all the properties in the layout.
    hydra::graphics::ResourceSetLayoutCreation::Binding binding = { hydra::graphics::ResourceType::Constants, 0, 1, &amp;quot;LocalConstants&amp;quot; };

    pass_buffer.append( (void*)&amp;amp;binding, sizeof( hydra::graphics::ResourceSetLayoutCreation::Binding) );
    pass_offset += sizeof( hydra::graphics::ResourceSetLayoutCreation::Binding );
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then we will cycle through all the shader stages and write the resources into the memory:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    for ( size_t s = 0; s &amp;lt; pass.shader_stages.size(); ++s ) {
        const Pass::ShaderStage shader_stage = pass.shader_stages[s];

        for ( size_t p = 0; p &amp;lt; shader_stage.code-&amp;gt;resources.size(); p++ ) {
            const hfx::CodeFragment::Resource&amp;amp; resource = shader_stage.code-&amp;gt;resources[p];

            switch ( resource.type ) {
                case ResourceType::Texture:
                {
                    copy( resource.name, binding.name, 32 );
                    binding.type = hydra::graphics::ResourceType::Texture;

                    pass_buffer.append( (void*)&amp;amp;binding, sizeof( hydra::graphics::ResourceSetLayoutCreation::Binding ) );
                    pass_offset += sizeof( hydra::graphics::ResourceSetLayoutCreation::Binding );
                    break;
                }

                case ResourceType::TextureRW:
                {
                    copy( resource.name, binding.name, 32 );
                    binding.type = hydra::graphics::ResourceType::TextureRW;

                    pass_buffer.append( (void*)&amp;amp;binding, sizeof( hydra::graphics::ResourceSetLayoutCreation::Binding ) );
                    pass_offset += sizeof( hydra::graphics::ResourceSetLayoutCreation::Binding );
                    break;
                }
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If instead there is a layout section, the method &lt;code&gt;writeResourcesLayout&lt;/code&gt; is called and will be pretty straight-forward:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;static void writeResourcesLayout( const hfx::Pass&amp;amp; pass, StringBuffer&amp;amp; pass_buffer, uint32_t&amp;amp; pass_offset ) {

    using namespace hydra::graphics;

    for ( size_t r = 0; r &amp;lt; pass.resource_lists.size(); ++r ) {
        const ResourceList* resource_list = pass.resource_lists[r];

        const uint32_t resources_count = (uint32_t)resource_list-&amp;gt;resources.size();
        pass_buffer.append( (void*)resource_list-&amp;gt;resources.data(), sizeof(ResourceBinding) * resources_count );
        pass_offset += sizeof( ResourceBinding ) * resources_count;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And this will be put at the end of the current pass section:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;pass_buffer.append( (void*)&amp;amp;pass_header, sizeof( ShaderEffectFile::PassHeader ) );
pass_buffer.append( shader_offset_buffer );
pass_buffer.append( code_buffer );

if ( automatic_layout ) {
    writeAutomaticResourcesLayout( pass, pass_buffer, pass_offset );
}
else {
    writeResourcesLayout( pass, pass_buffer, pass_offset );
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;conclusions-and-what-s-next&#34;&gt;Conclusions and what&amp;rsquo;s next&lt;/h1&gt;

&lt;p&gt;We arrived at the end of this article, and we started seeing how we can use HFX as a more complete language to embed different rendering features.&lt;br&gt;
We saw how to embed shader code and resource lists so that the rendering API can create everything without hard-coded generation of resources. This also showed when it was useful to create data instead of code.&lt;br&gt;
On the contrary, the UI and the Constants are generated in a new header file - thus code generation.&lt;br&gt;
There are pros and cons to both approaches, but I hope that knowing how to generate code and create a custom language will let you play with the concepts and explore your own needs.&lt;/p&gt;

&lt;p&gt;As next steps, there are some questions opened: how to reload shaders ? Can I add new material properties without recompiling code ?&lt;/p&gt;

&lt;p&gt;We will also see a simple implementation of a frame-graph, that I use since my years in Codemasters and in my indie project. This will be much more data-driven than code-generated, but again, the purpose of these articles is to explore the concepts and understanding when to use what.&lt;/p&gt;

&lt;p&gt;As always please comment, feedback, share!&lt;/p&gt;

&lt;p&gt;Thanks for reading!
   Gabriel&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Writing a Shader Effect Language Part 1</title>
      <link>/post/writing_shader_effect_language_1/</link>
      <pubDate>Tue, 06 Aug 2019 13:04:15 -0400</pubDate>
      
      <guid>/post/writing_shader_effect_language_1/</guid>
      <description>

&lt;h1 id=&#34;overview&#34;&gt;Overview&lt;/h1&gt;

&lt;p&gt;In this article we will create a simple language that can encapsulate shader code (called &lt;strong&gt;code fragments&lt;/strong&gt;) and output different files for each fragment.&lt;br&gt;
This is the initial step to switch from an engine that loads single files for each &lt;strong&gt;shader stage&lt;/strong&gt; (vertex, fragment, compute, &amp;hellip;) to one that uses an effect file that contains more than one shader.&lt;/p&gt;

&lt;p&gt;We will start by motivation, then will define the language itself (very simple), then we will look at the Parser and last the Code Generator.&lt;/p&gt;

&lt;p&gt;Have a good read!&lt;/p&gt;

&lt;h1 id=&#34;motivation&#34;&gt;Motivation&lt;/h1&gt;

&lt;p&gt;In the incredible quest of &lt;em&gt;data-driven rendering&lt;/em&gt;, after we defeated the dragon of &lt;a href=&#34;https://jorenjoestar.github.io/post/writing_a_simple_code_generator/&#34; target=&#34;_blank&#34;&gt;code generation&lt;/a&gt; another multiple headed dragon arises: an hydra!
We have different options here: be the brave warrior in shiny armor that tries to cut all the heads of the hydra, built some machines that can fight for us and send them, or both built the machines AND fight.&lt;/p&gt;

&lt;p&gt;Our code is invaluable, like our energies fighting the hydra.
We need to carefully balance them and see how can we use for the BEST.&lt;/p&gt;

&lt;p&gt;Writing manual code is good, it is generally what is done, but it is slow and error prone.
Going data-driven can be fast, but can give you a sense of losing control (not personally, but I heard few people saying that).
Only generating code can quickly become a recipe for disaster: so many particular use cases need attention, that the code could be come a different kind of mess.&lt;/p&gt;

&lt;p&gt;We will try to go down the route of code generation mixed with data-driven.
As I wrote in my previous articles, it is a fine line and can be good to know when to go in which direction!&lt;/p&gt;

&lt;p&gt;I will divide the article in 2 parts.
The first part (this one) will contain the new Shader Code Generator to generate shader permutations and add include support to GLSL.
The second will require a low-level rendering library and will show Code Generation of more CPU areas of Rendering, the real goal of all these articles!&lt;/p&gt;

&lt;p&gt;The code is available here:&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/JorenJoestar/DataDrivenRendering&#34; target=&#34;_blank&#34;&gt;https://github.com/JorenJoestar/DataDrivenRendering&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;effect-file-structure&#34;&gt;Effect file structure&lt;/h1&gt;

&lt;p&gt;Looking at effects, the first thing to do is to define a file that will represent our shaders. My choice is to create a simple language to embed shaders code and generate the CPU code necessary to render it.&lt;/p&gt;

&lt;h2 id=&#34;why-not-using-json&#34;&gt;Why not using Json ?&lt;/h2&gt;

&lt;p&gt;While it is an amazing data-format, I still want a bigger degree of control of what to parse and what to generate.
The decision is based on the fact that by writing a parser for the language, I can automate some code-generation that would be more intricate with Json.
Also, this series itself is a personal exploration on the topic, so using Json was not an option for this level of complexity.&lt;/p&gt;

&lt;h2 id=&#34;the-hfx-format&#34;&gt;The HFX Format&lt;/h2&gt;

&lt;p&gt;HFX (Hydra Effects) is a new language we will define to write out shaders.
The first iteration will be barebone - it will simply be a shader permutation generator - but it will be the foundation to extensions that will allow us to write CPU rendering code that we want to automate.&lt;/p&gt;

&lt;p&gt;In defining the format, there will be few keywords that will be defined, but the general architecture will make straightforward to copy-paste shader code fragments from any language into the HFX language.
We will use the following keywords (and concepts).&lt;/p&gt;

&lt;h3 id=&#34;shader&#34;&gt;Shader&lt;/h3&gt;

&lt;p&gt;The root of a shader effect. It will contain everything we are writing.&lt;/p&gt;

&lt;h3 id=&#34;glsl-hlsl&#34;&gt;Glsl/Hlsl&lt;/h3&gt;

&lt;p&gt;These will define the actual shader code, enclosed fragments. Fragments can be composed and reused.
For Glsl in particular, code fragments needs to be embedded in defines for each stage. More on that later.&lt;/p&gt;

&lt;h3 id=&#34;pass-technique-variant&#34;&gt;Pass, Technique, Variant&lt;/h3&gt;

&lt;p&gt;This is the central part for the effects to work. I&amp;rsquo;ve researched a bit, between &lt;a href=&#34;https://docs.microsoft.com/en-us/windows/win32/direct3d9/using-an-effect&#34; target=&#34;_blank&#34;&gt;Microsoft effects&lt;/a&gt;, &lt;a href=&#34;https://docs.unity3d.com/Manual/SL-Shader.html&#34; target=&#34;_blank&#34;&gt;Unity effects&lt;/a&gt;, &lt;a href=&#34;https://github.com/BastiaanOlij/shader_tutorial/blob/master/shaders/water_3d/depth_buffer/depth_buffer_textured.shader&#34; target=&#34;_blank&#34;&gt;Godot&lt;/a&gt; and &lt;a href=&#34;http://advances.realtimerendering.com/destiny/gdc_2017/&#34; target=&#34;_blank&#34;&gt;Bungie&lt;/a&gt; and the concepts are very similar, but they seem to differ a little and also each implementation becomes very engine-specific of course.&lt;br&gt;
The presentation by Bungie is amazing and their system is by far the more extensive and complex, we will work on a much simpler shader effect system.&lt;br&gt;&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s define a pass as a combination of shader code for at least one stage of the shader pipeline. For example a single compute shader or a couple vertex-fragment shader.&lt;/p&gt;

&lt;p&gt;Variants and techniques are loose concept to help separating shader paths.
For example a &lt;em&gt;variant&lt;/em&gt; could be a different post-process shader, like different implementations of SSAO.&lt;/p&gt;

&lt;p&gt;A technique could be a whole set of passes that target a specific platform.&lt;/p&gt;

&lt;p&gt;Not having my mind set on those still, I will omit them for now, as they are concepts that are less central than the code generation, and can be very subjective opinion-wise.
Possibly I&amp;rsquo;ll get them in part 2.&lt;/p&gt;

&lt;h3 id=&#34;properties&#34;&gt;Properties&lt;/h3&gt;

&lt;p&gt;Final piece of the puzzle. This will define the resources used by the shader effect on a per-effect level.
Keeping an eye on the newer rendering APIs (DX12 and Vulkan) this defines also the layout of the resources and how they are used.
Possibly the most intense part from an automation possibility (and thus code-generation).
We will define this in part 2 of this article.&lt;/p&gt;

&lt;h1 id=&#34;high-level-workflow&#34;&gt;High level workflow&lt;/h1&gt;

&lt;p&gt;From a high level perspective what will happen in all this code is enclosed in this code:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;text = ReadEntireFileIntoMemory( &amp;quot;..\\data\\SimpleFullscreen.hfx&amp;quot;, nullptr );
initLexer( &amp;amp;lexer, (char*)text );

hfx::Parser effect_parser;
hfx::initParser( &amp;amp;effect_parser, &amp;amp;lexer );
hfx::generateAST( &amp;amp;effect_parser );

hfx::CodeGenerator hfx_code_generator;
hfx::initCodeGenerator( &amp;amp;hfx_code_generator, &amp;amp;effect_parser, 4096 );
hfx::generateShaderPermutations( &amp;amp;hfx_code_generator, &amp;quot;..\\data\\&amp;quot; );
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We separated the &lt;em&gt;Lexer&lt;/em&gt; from the &lt;em&gt;Parser&lt;/em&gt; so we can reuse the lexer functionalities, thus we can reuse it from the previous example (parsing the HydraDataFormat files).&lt;br&gt;
Then we initialize the &lt;em&gt;Parser&lt;/em&gt; and &lt;em&gt;generate the AST&lt;/em&gt;. This will save all the passes and code fragments we defined in the HFX file.&lt;br&gt;
Finally we will get the parsing informations and give them to the &lt;em&gt;code generator&lt;/em&gt;, that will write out the files for each pass and stage.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s dig into the example!&lt;/p&gt;

&lt;h1 id=&#34;parser-welcome-hfx&#34;&gt;Parser: welcome HFX!&lt;/h1&gt;

&lt;p&gt;In most rendering-API (OpenGL, Vulkan, Direct3D12, &amp;hellip;) shaders are compiled by compiling the individual stages (vertex, fragment, compute, geometry, &amp;hellip;) and in some APIs (especially the newer ones) are compiled into a &lt;strong&gt;Shader State&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;As first step of this shader language, single shader files will be created by the &lt;em&gt;shader generation&lt;/em&gt; method in our code.&lt;/p&gt;

&lt;p&gt;We will define a simple fullscreen HFX with &lt;em&gt;code fragments&lt;/em&gt; and &lt;em&gt;passes&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;First, we define the root shader (SimpleFullscreen.hfx, under folder &amp;lsquo;data&amp;rsquo;):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;shader SimpleFullscreen {
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is simply the container for all the code and passes that will define the shader effect.&lt;/p&gt;

&lt;p&gt;Now we need some actual code, so we can define a shader fragment.&lt;br&gt;
The keyword used in our language is &lt;strong&gt;glsl&lt;/strong&gt; followed by a name and an open brace:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;glsl ToScreen {
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This will define a &lt;strong&gt;code fragment&lt;/strong&gt; named &lt;em&gt;ToScreen&lt;/em&gt;, that can be referenced from the passes.&lt;br&gt;
Next we use a glsl trick to &lt;em&gt;signal our parser to use includes&lt;/em&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#pragma include &amp;quot;Platform.h&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This #pragma is actually ignored by the compiler, but will be used by the parser to actually add the include!&lt;br&gt;
BEWARE: this code will be included in BOTH &lt;em&gt;vertex&lt;/em&gt; and &lt;em&gt;fragment&lt;/em&gt; program!&lt;br&gt;
Anything outside of the VERTEX/FRAGMENT/COMPUTE macros will be, and this is done on purpose, like defining an interpolator struct only once or for common includes.&lt;/p&gt;

&lt;p&gt;Next we define the vertex program.&lt;br&gt;
BEWARE: vertex only code must be enclosed in &lt;strong&gt;VERTEX&lt;/strong&gt; define!&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#if defined VERTEX

out vec4 vTexCoord;

void main() {

   vTexCoord.xy = vec2((gl_VertexID &amp;lt;&amp;lt; 1) &amp;amp; 2, gl_VertexID &amp;amp; 2);
   vTexCoord.zw = vTexCoord.xy;
   gl_Position = vec4(vTexCoord.xy * 2.0f + -1.0f, 0.0f, 1.0f);
}

#endif // VERTEX
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This code is a simple fullscreen triangle that does not require any vertex buffer, but uses the vertex id to draw. Nothing fancy.&lt;/p&gt;

&lt;p&gt;Next is the fragment program, and again enclosed in &lt;strong&gt;FRAGMENT&lt;/strong&gt; define:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#if defined FRAGMENT

in vec4 vTexCoord;

out vec4 outColor;

layout(binding=0) uniform sampler2D input_texture;

void main() {

    vec3 color = texture2D(input_texture, vTexCoord.xy).xyz;
    outColor = vec4(color, 1);
}

#endif // FRAGMENT

} // glsl ToScreen

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This code simply reads a texture and outputs it to the screen.&lt;/p&gt;

&lt;p&gt;We defined the code fragment ToScreen, containing both a vertex and a fragment program, and now we can actually generate the permutation that we need.&lt;br&gt;
The code for this in our effect file is:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;pass ToScreen {
   vertex = ToScreen
   fragment = ToScreen
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We are simply defining a pass with the vertex and fragment program defined in the ToScreen code fragment (yes I don&amp;rsquo;t like this term too).&lt;/p&gt;

&lt;p&gt;Running the &lt;strong&gt;code generator&lt;/strong&gt; on this simple effect file will generate the two files ToScreen.vert and ToScreen.frag.&lt;/p&gt;

&lt;p&gt;These can be read directly into your favourite OpenGL renderer and used as is!&lt;/p&gt;

&lt;h2 id=&#34;the-parser&#34;&gt;The Parser&lt;/h2&gt;

&lt;p&gt;Now that we have defined the effect and we know what is the outcome of generating code from the effect file, let&amp;rsquo;s look into the different component of the parser and code generator needed.&lt;/p&gt;

&lt;p&gt;By design, we chose the Lexer to know nothing about the language, so that we can use it between different languages.
The entry point to parse the effect is the method generateAST:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;void generateAST( Parser* parser ) {

    // Read source text until the end.
    // The main body can be a list of declarations.
    bool parsing = true;

    while ( parsing ) {

        Token token;
        nextToken( parser-&amp;gt;lexer, token );

        switch ( token.type ) {

            case Token::Token_Identifier:
            {
                identifier( parser, token );
                break;
            }

            case Token::Type::Token_EndOfStream:
            {
                parsing = false;
                break;
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This code simply process the file- using the lexer- until the end of it, and reads only identifiers.&lt;br&gt;
It is the same as the previous article and the previous parser. What changes drastically is the &lt;strong&gt;identifier&lt;/strong&gt; method!&lt;br&gt;
We will have 3 different set of identifiers, usable in different parts of the HFX file:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Main identifiers, &amp;lsquo;shader&amp;rsquo;, &amp;lsquo;glsl&amp;rsquo;, &amp;lsquo;pass&amp;rsquo;&lt;/li&gt;
&lt;li&gt;Pass identifiers, &amp;lsquo;compute&amp;rsquo;, &amp;lsquo;vertex&amp;rsquo;, &amp;lsquo;fragment&amp;rsquo;&lt;/li&gt;
&lt;li&gt;Directive identifiers, &amp;lsquo;if defined&amp;rsquo;, &amp;lsquo;pragma include&amp;rsquo;, &amp;lsquo;endif&amp;rsquo;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Let&amp;rsquo;s have a look at the code for parsing the main identifiers:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;inline void identifier( Parser* parser, const Token&amp;amp; token ) {

    // Scan the name to know which 
    for ( uint32_t i = 0; i &amp;lt; token.text.length; ++i ) {
        char c = *(token.text.text + i);

        switch ( c ) {
            case &#39;s&#39;:
            {
                if ( expectKeyword( token.text, 6, &amp;quot;shader&amp;quot; ) ) {
                    declarationShader( parser );
                    return;
                }

                break;
            }

            case &#39;g&#39;:
            {
                if ( expectKeyword( token.text, 4, &amp;quot;glsl&amp;quot; ) ) {
                    declarationGlsl( parser );
                    return;
                }
                break;
            }

            case &#39;p&#39;:
            {
                if ( expectKeyword( token.text, 4, &amp;quot;pass&amp;quot; ) ) {
                    declarationPass( parser );
                    return;
                }
                break;
            }

        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This code simply defers the parsing of a particular identifier using the &lt;strong&gt;declaration&lt;/strong&gt; method corresponding to the identifier.
We will look into detail on each method.&lt;/p&gt;

&lt;h3 id=&#34;parsing-shader&#34;&gt;Parsing &amp;lsquo;shader&amp;rsquo;&lt;/h3&gt;

&lt;p&gt;We are parsing now the following part from the HFX file:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// HFX

shader SimpleFullscreen {
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is the entry point of the effect itself.&lt;br&gt;
What should the parser do here ?&lt;br&gt;
Simply iterate through the main identifiers, &amp;lsquo;glsl&amp;rsquo; and &amp;lsquo;pass&amp;rsquo;.&lt;br&gt;
Technically I could have separated the methods to have one with parsing shader only and the others parsing &amp;lsquo;glsl&amp;rsquo; and &amp;lsquo;pass&amp;rsquo;, but did not want to complicate the code further.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s look at how we parse the identifier &amp;lsquo;shader&amp;rsquo;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// C++

inline void declarationShader( Parser* parser ) {
    // Parse name
    Token token;
    if ( !expectToken( parser-&amp;gt;lexer, token, Token::Token_Identifier ) ) {
        return;
    }

    // Cache name string
    StringRef name = token.text;

    if ( !expectToken( parser-&amp;gt;lexer, token, Token::Token_OpenBrace ) ) {
        return;
    }

    while ( !equalToken( parser-&amp;gt;lexer, token, Token::Token_CloseBrace ) ) {

        identifier( parser, token );
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As the previous article&amp;rsquo;s code, this will get the tokens from the lexer and generate data if the syntax is correct.&lt;br&gt;
When we enter the method the Lexer will be just at the beginning of the name (SimpleFullscreen), so the code will parse the name, the open brace, and parse everything else until it encounter the close brace.&lt;/p&gt;

&lt;p&gt;The method identifier will parse also identifiers &amp;lsquo;glsl&amp;rsquo; and &amp;lsquo;pass&amp;rsquo;.&lt;/p&gt;

&lt;h3 id=&#34;parsing-glsl&#34;&gt;Parsing &amp;lsquo;glsl&amp;rsquo;&lt;/h3&gt;

&lt;p&gt;This is the most complex parsing in the code.&lt;br&gt;
I will put both the HFX part and C++ code so hopefully it will be clearer what the parser is doing and why.&lt;/p&gt;

&lt;p&gt;As a refresh and reference, this is the &lt;strong&gt;code fragment&lt;/strong&gt; ToScreen defined in SimpleFullscreen.hfx:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// HFX

glsl ToScreen {

    #pragma include &amp;quot;Platform.h&amp;quot;

    #if defined VERTEX
    out vec4 vTexCoord;

    void main() {

        vTexCoord.xy = vec2((gl_VertexID &amp;lt;&amp;lt; 1) &amp;amp; 2, gl_VertexID &amp;amp; 2);
        vTexCoord.zw = vTexCoord.xy;

        gl_Position = vec4(vTexCoord.xy * 2.0f + -1.0f, 0.0f, 1.0f);
    }
    #endif // VERTEX

    #if defined FRAGMENT

    in vec4 vTexCoord;

    out vec4 outColor;

    layout(binding=0) uniform sampler2D input_texture;

    void main() {
        vec3 color = texture2D(input_texture, vTexCoord.xy).xyz;
        outColor = vec4(1, 1, 0, 1);
        outColor = vec4(color, 1);
    }
    #endif // FRAGMENT
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let&amp;rsquo;s start from the beginning.&lt;br&gt;
When the parser finds the &amp;lsquo;glsl&amp;rsquo; keyword in the identifier method:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// C++

case &#39;g&#39;:
{
    if ( expectKeyword( token.text, 4, &amp;quot;glsl&amp;quot; ) ) {
        declarationGlsl( parser );
        return;
    }
    break;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It calls the method &lt;strong&gt;void declarationGlsl( Parser* parser )&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;The lexer reading the HFX is after the glsl keyword when entering the method, just before the ToScreen identifier:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// HFX

glsl (Here!)ToScreen {
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let&amp;rsquo;s see the C++ code step by step.&lt;br&gt;
First parsing the name &amp;lsquo;ToScreen&amp;rsquo;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// C++

inline void declarationGlsl( Parser* parser ) {

    // Parse name
    Token token;
    if ( !expectToken( parser-&amp;gt;lexer, token, Token::Token_Identifier ) ) {
        return;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;as seen in other methods as well.&lt;br&gt;
We are defining a new &lt;strong&gt;code fragment&lt;/strong&gt;, thus we need to initialize it. There is tracking of the #ifdef depths to manage when some code must be included in a code fragment and when not:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    CodeFragment code_fragment = {};
    // Cache name string
    code_fragment.name = token.text;

    for ( size_t i = 0; i &amp;lt; CodeFragment::Count; i++ ) {
        code_fragment.stage_ifdef_depth[i] = 0xffffffff;
    }

    if ( !expectToken( parser-&amp;gt;lexer, token, Token::Token_OpenBrace ) ) {
        return;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Next is simply arriving at the first token that contains all the glsl code:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    // Advance token and cache the starting point of the code.
    nextToken( parser-&amp;gt;lexer, token );
    code_fragment.code = token.text;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And now some more parsing craftmanship.&lt;br&gt;
We cannot use anymore the simple check to end parsing when encountering a closed brace, because there can be different structs defined that will break that mechanism.&lt;br&gt;
Instead we track the number of open braces and when we close the last one, we consider finished the parsing of the &lt;strong&gt;code fragment&lt;/strong&gt;!&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    uint32_t open_braces = 1;

    // Scan until close brace token
    while ( open_braces ) {

        if ( token.type == Token::Token_OpenBrace )
            ++open_braces;
        else if ( token.type == Token::Token_CloseBrace )
            --open_braces;

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The only token that we care inside the code fragment is the &lt;strong&gt;hash&lt;/strong&gt;, signalling either an include or a define, used for separating &lt;em&gt;per-stage code&lt;/em&gt;.&lt;br&gt;
The parsing of the &lt;em&gt;hash&lt;/em&gt; token will be done inside the &lt;strong&gt;directiveIdentifier&lt;/strong&gt; method:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        // Parse hash for includes and defines
        if ( token.type == Token::Token_Hash ) {
            // Get next token and check which directive is
            nextToken( parser-&amp;gt;lexer, token );

            directiveIdentifier( parser, token, code_fragment );
        }

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Before diving deep into the &lt;strong&gt;directive identifiers&lt;/strong&gt;, let&amp;rsquo;s finish the main parsing routine.&lt;br&gt;
We advance to the next token until we close all the braces, and then save the text length of all the code fragment:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        nextToken( parser-&amp;gt;lexer, token );
    }
    
    // Calculate code string length
    code_fragment.code.length = token.text.text - code_fragment.code.text;

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Final step is to save the newly parsed code fragment into the parser data:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    parser-&amp;gt;code_fragments.emplace_back( code_fragment );
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can now dive deep into the parsing of directives, namely #if defined, #pragma include and #endif.&lt;/p&gt;

&lt;h4 id=&#34;parsing-if-defined&#34;&gt;Parsing &amp;lsquo;#if defined&amp;rsquo;&lt;/h4&gt;

&lt;p&gt;When we encounter the &lt;strong&gt;Hash&lt;/strong&gt; token within the &lt;strong&gt;glsl&lt;/strong&gt; part, we need to parse further to understand the other keywords.&lt;br&gt;
&lt;strong&gt;#if defined&lt;/strong&gt; is the most important directive for us, because it will tell the parser which &lt;strong&gt;shader stage&lt;/strong&gt; we are parsing currently and thus where to direct the text!&lt;br&gt;
It starts from a common/shared stage, for shared code, and when encounters a #if defined it can signal a stage specific code.&lt;br&gt;&lt;/p&gt;

&lt;p&gt;Namely when parsing the following line in HFX:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// HFX

#(Here!)if defined VERTEX
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The parser needs to check 2 other identifiers. Remember that the parser is currently AFTER the &lt;strong&gt;Hash&lt;/strong&gt; token, as beautifully written in the previous snippet!&lt;br&gt;
Let&amp;rsquo;s look at the code:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// C++

inline void directiveIdentifier( Parser* parser, const Token&amp;amp; token, CodeFragment&amp;amp; code_fragment ) {
    
    Token new_token;
    for ( uint32_t i = 0; i &amp;lt; token.text.length; ++i ) {
        char c = *(token.text.text + i);

        switch ( c ) {
            case &#39;i&#39;:
            {
                // Search for the pattern &#39;if defined&#39;
                if ( expectKeyword( token.text, 2, &amp;quot;if&amp;quot; ) ) {
                    nextToken( parser-&amp;gt;lexer, new_token );

                    if ( expectKeyword( new_token.text, 7, &amp;quot;defined&amp;quot; ) ) {
                        nextToken( parser-&amp;gt;lexer, new_token );

                        // Use 0 as not set value for the ifdef depth.
                        ++code_fragment.ifdef_depth;

                        if ( expectKeyword( new_token.text, 6, &amp;quot;VERTEX&amp;quot; ) ) {

                            code_fragment.stage_ifdef_depth[CodeFragment::Vertex] = code_fragment.ifdef_depth;
                            code_fragment.current_stage = CodeFragment::Vertex;
                        }
                        else if ( expectKeyword( new_token.text, 8, &amp;quot;FRAGMENT&amp;quot; ) ) {

                            code_fragment.stage_ifdef_depth[CodeFragment::Fragment] = code_fragment.ifdef_depth;
                            code_fragment.current_stage = CodeFragment::Fragment;
                        }
                        else if ( expectKeyword( new_token.text, 7, &amp;quot;COMPUTE&amp;quot; ) ) {

                            code_fragment.stage_ifdef_depth[CodeFragment::Compute] = code_fragment.ifdef_depth;
                            code_fragment.current_stage = CodeFragment::Compute;
                        }
                    }

                    return;
                }
                break;
            }

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let&amp;rsquo;s dissect this code!&lt;/p&gt;

&lt;p&gt;Starting from the current token, just after the &lt;strong&gt;#(Hash)&lt;/strong&gt;, we need to check the correct composition of the keywords.&lt;br&gt;
We expect &amp;lsquo;if&amp;rsquo;, and then if found we go to the next token:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;if ( expectKeyword( token.text, 2, &amp;quot;if&amp;quot; ) ) {
    nextToken( parser-&amp;gt;lexer, new_token );
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We search for the &amp;lsquo;defined&amp;rsquo; identifier and if found we go to the next identifier:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;if ( expectKeyword( new_token.text, 7, &amp;quot;defined&amp;quot; ) ) {
    nextToken( parser-&amp;gt;lexer, new_token );
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The parser is currently here:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#if defined (Here!)VERTEX
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And thus the last step is to check which &lt;strong&gt;shader stage&lt;/strong&gt; is currently starting.
This is done here:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;if ( expectKeyword( new_token.text, 6, &amp;quot;VERTEX&amp;quot; ) ) {

    code_fragment.stage_ifdef_depth[CodeFragment::Vertex] = code_fragment.ifdef_depth;
    code_fragment.current_stage = CodeFragment::Vertex;
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In this central piece of code, we set the current stage to Vertex (because we found the keyword &amp;lsquo;VERTEX&amp;rsquo;) and we save the current ifdef depth.&lt;br&gt;
Why that ? &lt;br&gt;
Because when we will parse #endif, we will do the same for the open/close braces depth in the main glsl parser: we want to be sure that the defines are paired correctly and we are saving the per-stage code in the correct way!&lt;br&gt;
This will be more clear when we see the #endif parsing.&lt;/p&gt;

&lt;p&gt;Moving on, we will do the same for all the other keywords (&amp;lsquo;FRAGMENT&amp;rsquo; and &amp;lsquo;COMPUTE&amp;rsquo; for now):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;else if ( expectKeyword( new_token.text, 8, &amp;quot;FRAGMENT&amp;quot; ) ) {

    code_fragment.stage_ifdef_depth[CodeFragment::Fragment] = code_fragment.ifdef_depth;
    code_fragment.current_stage = CodeFragment::Fragment;
}
else if ( expectKeyword( new_token.text, 7, &amp;quot;COMPUTE&amp;quot; ) ) {

    code_fragment.stage_ifdef_depth[CodeFragment::Compute] = code_fragment.ifdef_depth;
    code_fragment.current_stage = CodeFragment::Compute;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And the parsing of &lt;strong&gt;#if defined&lt;/strong&gt; is over!&lt;br&gt;&lt;/p&gt;

&lt;h4 id=&#34;parsing-pragma-include&#34;&gt;Parsing &amp;lsquo;#pragma include&amp;rsquo;&lt;/h4&gt;

&lt;p&gt;In HFX we are parsing the following:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// HFX

#pragma include &amp;quot;Platform.h&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;With the following code (inside &lt;em&gt;directiveIdentifier&lt;/em&gt; method):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// C++

case &#39;p&#39;:
{
    if ( expectKeyword( token.text, 6, &amp;quot;pragma&amp;quot; ) ) {
        nextToken( parser-&amp;gt;lexer, new_token );

        if ( expectKeyword( new_token.text, 7, &amp;quot;include&amp;quot; ) ) {
            nextToken( parser-&amp;gt;lexer, new_token );

            code_fragment.includes.emplace_back( new_token.text );
            code_fragment.includes_stage.emplace_back( code_fragment.current_stage );
        }

        return;
    }
    break;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is simply saving the filename after the include, that being surrounded by &amp;ldquo;&amp;rdquo; is classified as string, and is using the current stage to know which stage should include that file!&lt;br&gt;&lt;/p&gt;

&lt;h4 id=&#34;parsing-endif&#34;&gt;Parsing &amp;lsquo;#endif&amp;rsquo;&lt;/h4&gt;

&lt;p&gt;Final part is the &lt;strong&gt;#endif&lt;/strong&gt; identifier:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;case &#39;e&#39;:
{
    if ( expectKeyword( token.text, 5, &amp;quot;endif&amp;quot; ) ) {

        if ( code_fragment.stage_ifdef_depth[CodeFragment::Vertex] == code_fragment.ifdef_depth ) {
            
            code_fragment.stage_ifdef_depth[CodeFragment::Vertex] = 0xffffffff;
            code_fragment.current_stage = CodeFragment::Common;
        }
        else if ( code_fragment.stage_ifdef_depth[CodeFragment::Fragment] == code_fragment.ifdef_depth ) {

            code_fragment.stage_ifdef_depth[CodeFragment::Fragment] = 0xffffffff;
            code_fragment.current_stage = CodeFragment::Common;
        }
        else if ( code_fragment.stage_ifdef_depth[CodeFragment::Compute] == code_fragment.ifdef_depth ) {

            code_fragment.stage_ifdef_depth[CodeFragment::Compute] = 0xffffffff;
            code_fragment.current_stage = CodeFragment::Common;
        }

        --code_fragment.ifdef_depth;

        return;
    }
    break;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is mirroring the &lt;strong&gt;#if defined&lt;/strong&gt; and simply goes back to set the current stage to common/shared and reset the per-stage ifdef depth.&lt;/p&gt;

&lt;p&gt;We can now proceed to the final part of the parsing, the &lt;strong&gt;passes&lt;/strong&gt;!&lt;br&gt;
This is the glue to generate the different files from the code fragments.&lt;/p&gt;

&lt;h3 id=&#34;parsing-pass&#34;&gt;Parsing &amp;lsquo;pass&amp;rsquo;&lt;/h3&gt;

&lt;p&gt;Reading the HFX file, we are now in the final part of the file:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// HFX

pass ToScreen {
   vertex = ToScreen
   fragment = ToScreen
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A pass is simply a collection of &lt;strong&gt;code fragments&lt;/strong&gt; associated with each shader stage (vertex, fragment, compute).&lt;br&gt;
When we parsed the fragments, we saved them in the parser to be retrieved.&lt;/p&gt;

&lt;p&gt;To refresh our memory, this is the actual &lt;strong&gt;Pass struct&lt;/strong&gt; in C++:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// C++

struct Pass {

    StringRef                   name;

    const CodeFragment*         vs                  = nullptr;
    const CodeFragment*         fs                  = nullptr;
    const CodeFragment*         cs                  = nullptr;

}; // struct Pass
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Going back to the main directive method, we call the &lt;strong&gt;declarationPass&lt;/strong&gt; method when we encounter the &amp;lsquo;pass&amp;rsquo; identifier.&lt;br&gt;
We will parse the following line:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// HFX

pass ToScreen {
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;With the following code (similar to everything else, it should be easier to read now):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// C++

inline void declarationPass( Parser* parser ) {

    Token token;
    if ( !expectToken( parser-&amp;gt;lexer, token, Token::Token_Identifier ) ) {
        return;
    }

    Pass pass = {};
    // Cache name string
    pass.name = token.text;

    if ( !expectToken( parser-&amp;gt;lexer, token, Token::Token_OpenBrace ) ) {
        return;
    }

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;After we saved the pass name we can start reading the individual stages using the &lt;strong&gt;passIdentifier&lt;/strong&gt; method:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    while ( !equalToken( parser-&amp;gt;lexer, token, Token::Token_CloseBrace ) ) {
        passIdentifier( parser, token, pass );
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And then save the newly parsed pass.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    parser-&amp;gt;passes.emplace_back( pass );
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For each identifier now, we will check which stage we are parsing.&lt;br&gt;
Currently we are here, after the open brace and all the whitespace:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// HFX

pass ToScreen {
   (Here!)vertex = ToScreen
   fragment = ToScreen
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;What is next is thus checking the identifier and filling the corresponding &lt;strong&gt;shader stage&lt;/strong&gt; of the &lt;strong&gt;pass&lt;/strong&gt;.&lt;br&gt;
I will post all the code of the method, because is similar to most code we seen and should be straightforward:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// C++

inline void passIdentifier( Parser* parser, const Token&amp;amp; token, Pass&amp;amp; pass ) {
    // Scan the name to know which stage we are parsing    
    for ( uint32_t i = 0; i &amp;lt; token.text.length; ++i ) {
        char c = *(token.text.text + i);

        switch ( c ) {
            
            case &#39;c&#39;:
            {
                if ( expectKeyword( token.text, 7, &amp;quot;compute&amp;quot;) ) {
                    declarationShaderStage( parser, &amp;amp;pass.cs );
                    return;
                }
                break;
            }

            case &#39;v&#39;:
            {
                if ( expectKeyword( token.text, 6, &amp;quot;vertex&amp;quot; ) ) {
                    declarationShaderStage( parser, &amp;amp;pass.vs );
                    return;
                }
                break;
            }

            case &#39;f&#39;:
            {
                if ( expectKeyword( token.text, 8, &amp;quot;fragment&amp;quot; ) ) {
                    declarationShaderStage( parser, &amp;amp;pass.fs );
                    return;
                }
                break;
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The real &amp;lsquo;magic&amp;rsquo; here is the &amp;lsquo;declarationShaderStage&amp;rsquo; method.&lt;br&gt;
This method parses the couple &amp;lsquo;identifier&amp;rsquo; &amp;lsquo;=&amp;rsquo; &amp;lsquo;identifier&amp;rsquo;, and searches the &lt;strong&gt;code fragment&lt;/strong&gt; with the same name:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;inline void declarationShaderStage( Parser* parser, const CodeFragment** out_fragment ) {

    Token token;
    if ( !expectToken( parser-&amp;gt;lexer, token, Token::Token_Equals ) ) {
        return;
    }

    if ( !expectToken( parser-&amp;gt;lexer, token, Token::Token_Identifier ) ) {
        return;
    }

    *out_fragment = findCodeFragment( parser, token.text );
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;After all the stages of the current pass are parsed, we save the pass and finish parsing the file!&lt;br&gt;&lt;/p&gt;

&lt;h1 id=&#34;shader-permutation-generation&#34;&gt;Shader Permutation Generation&lt;/h1&gt;

&lt;p&gt;The final step of this amazing journey is the simplest, and it is actually to generate the single files we need.&lt;br&gt;
In our case another specific class, &lt;strong&gt;CodeGenerator&lt;/strong&gt;, will generate the different files from the parsed HFX file.&lt;/p&gt;

&lt;p&gt;After we&amp;rsquo;ve done with the parsing, we can call the &lt;strong&gt;generateShaderPermutations&lt;/strong&gt; method that will generate files for each shader stage in each pass:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;void generateShaderPermutations( CodeGenerator* code_generator, const char* path ) {

    code_generator-&amp;gt;string_buffer_0.clear();
    code_generator-&amp;gt;string_buffer_1.clear();
    code_generator-&amp;gt;string_buffer_2.clear();

    // For each pass and for each pass generate permutation file.
    const uint32_t pass_count = (uint32_t)code_generator-&amp;gt;parser-&amp;gt;passes.size();
    for ( uint32_t i = 0; i &amp;lt; pass_count; i++ ) {

        // Create one file for each code fragment
        const Pass&amp;amp; pass = code_generator-&amp;gt;parser-&amp;gt;passes[i];
        
        if ( pass.cs ) {
            outputCodeFragment( code_generator, path, CodeFragment::Compute, pass.cs );
        }

        if ( pass.fs ) {
            outputCodeFragment( code_generator, path, CodeFragment::Fragment, pass.fs );
        }

        if ( pass.vs ) {
            outputCodeFragment( code_generator, path, CodeFragment::Vertex, pass.vs );
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The code should be straightforward, and the real action happens into the &lt;strong&gt;outputCodeFragment&lt;/strong&gt; method.&lt;br&gt;
Let&amp;rsquo;s have a look at the code.&lt;br&gt;&lt;/p&gt;

&lt;p&gt;First we define some data, like the file extensions for each shader stage or the defines to compile the code:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// Additional data to be added to output shaders.
static const char*              s_shader_file_extension[CodeFragment::Count] = { &amp;quot;.vert&amp;quot;, &amp;quot;.frag&amp;quot;, &amp;quot;.compute&amp;quot;, &amp;quot;.h&amp;quot; };
static const char*              s_shader_stage_defines[CodeFragment::Count] = { &amp;quot;#define VERTEX\r\n&amp;quot;, &amp;quot;#define FRAGMENT\r\n&amp;quot;, &amp;quot;#define COMPUTE\r\n&amp;quot;, &amp;quot;&amp;quot; };
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then we start to write the file.&lt;br&gt;
We will use the &lt;em&gt;string_buffer_0&lt;/em&gt; to dynamically generate the path of the file without allocating memory:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;void outputCodeFragment( CodeGenerator* code_generator, const char* path, CodeFragment::Stage stage, const CodeFragment* code_fragment ) {
    // Create file
    FILE* output_file;

    code_generator-&amp;gt;string_buffer_0.clear();
    code_generator-&amp;gt;string_buffer_0.append( path );
    code_generator-&amp;gt;string_buffer_0.append( code_fragment-&amp;gt;name );
    code_generator-&amp;gt;string_buffer_0.append( s_shader_file_extension[stage] );
    fopen_s( &amp;amp;output_file, code_generator-&amp;gt;string_buffer_0.data, &amp;quot;wb&amp;quot; );

    if ( !output_file ) {
        printf( &amp;quot;Error opening file. Aborting. \n&amp;quot; );
        return;
    }

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And then use &lt;em&gt;string_buffer_1&lt;/em&gt; to instead generate the actual code into the file.&lt;br&gt;
First, and most important, we will add all the includes for this particular stage by opening the file, reading it into memory and adding it into the final code buffer.&lt;/p&gt;

&lt;p&gt;We will still use &lt;em&gt;string_buffer_0&lt;/em&gt; to generate the path of the file:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    code_generator-&amp;gt;string_buffer_1.clear();

    // Append includes for the current stage.
    for ( size_t i = 0; i &amp;lt; code_fragment-&amp;gt;includes.size(); i++ ) {
        if ( code_fragment-&amp;gt;includes_stage[i] != stage &amp;amp;&amp;amp; code_fragment-&amp;gt;includes_stage[i] != CodeFragment::Common ) {
            continue;
        }

        // Open and read file
        code_generator-&amp;gt;string_buffer_0.clear();
        code_generator-&amp;gt;string_buffer_0.append( path );
        code_generator-&amp;gt;string_buffer_0.append( code_fragment-&amp;gt;includes[i] );
        char* include_code = ReadEntireFileIntoMemory( code_generator-&amp;gt;string_buffer_0.data, nullptr );

        code_generator-&amp;gt;string_buffer_1.append( include_code );
        code_generator-&amp;gt;string_buffer_1.append( &amp;quot;\r\n&amp;quot; );
    }

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;After that is done we can copy the define needed for the current shader stage:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    code_generator-&amp;gt;string_buffer_1.append( &amp;quot;\t\t&amp;quot; );
    code_generator-&amp;gt;string_buffer_1.append( s_shader_stage_defines[stage] );

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And finally the actual code:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    code_generator-&amp;gt;string_buffer_1.append( &amp;quot;\r\n\t\t&amp;quot; );
    code_generator-&amp;gt;string_buffer_1.append( code_fragment-&amp;gt;code );

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Write to file and close it and we are done!&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    fprintf( output_file, &amp;quot;%s&amp;quot;, code_generator-&amp;gt;string_buffer_1.data );

    fclose( output_file );
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And this will generate the shader permutations for each pass with a single file, using the standard GLSL convention for files extensions.&lt;/p&gt;

&lt;h1 id=&#34;conclusions-and-next-part&#34;&gt;Conclusions and next part&lt;/h1&gt;

&lt;p&gt;We parsed our simple &lt;em&gt;shader language&lt;/em&gt; to enhance and embed &lt;em&gt;glsl&lt;/em&gt; code fragments into our codebase by generating single files that can be used into any OpenGL based renderer.&lt;br&gt;
We also laid out the foundation for a more powerful tool - namely code generation - even though there are some intermediate steps to be taken to arrive there.&lt;br&gt;
First of all, we will need a target rendering library (something like the amazing &lt;a href=&#34;https://github.com/floooh/sokol&#34; target=&#34;_blank&#34;&gt;Sokol&lt;/a&gt;), so we can specialize our CPU rendering code. I already wrote something like Sokol but with a more Vulkan/D3D12 interface in mind, and I will use that. Still unsure if I will write a specific post on that.&lt;/p&gt;

&lt;p&gt;In the next article we will add support for the new graphics library and develop the language more to generate code that will manage Constant buffers, automatically creating a CPU-side class, adding UI to edit it in realtime and possibly load/save the values.&lt;/p&gt;

&lt;p&gt;Of course, any feedback/improvements/suggestions on anything related here (article, code, etc) please let me know.&lt;/p&gt;

&lt;p&gt;Stay tuned!
   Gabriel&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Writing a simple Code Generator</title>
      <link>/post/writing_a_simple_code_generator/</link>
      <pubDate>Sat, 27 Jul 2019 18:46:03 -0400</pubDate>
      
      <guid>/post/writing_a_simple_code_generator/</guid>
      <description>







&lt;figure&gt;

  &lt;a data-fancybox=&#34;&#34; href=&#34;front.png&#34; &gt;

&lt;img src=&#34;front.png&#34; &gt;
&lt;/a&gt;


&lt;figcaption data-pre=&#34;Figure &#34; data-post=&#34;:&#34; &gt;
  &lt;h4&gt;UI using ImGUI, SDL and the code generated with this article.&lt;/h4&gt;
  
&lt;/figcaption&gt;

&lt;/figure&gt;


&lt;h1 id=&#34;motivation&#34;&gt;Motivation&lt;/h1&gt;

&lt;p&gt;Following my previous article about Flatbuffers and data reflection the quest for Data-Driven Rendering continues!&lt;br&gt;
In this article I want to show how to write a very simple code-generator to help you automate writing of code in any language.&lt;br&gt;
The code is here:&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/JorenJoestar/DataDrivenRendering&#34; target=&#34;_blank&#34;&gt;https://github.com/JorenJoestar/DataDrivenRendering&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;There is a balance that constantly needs to be found between code and data, and having a code-generator in my opinion helps tremendously in focus on the code that is necessary to be written.&lt;br&gt;
From a data perspective, normally the baking pipeline is a series of DCC formats as source transformed into very project specific and optimized data.&lt;br&gt;
Code-wise, depending on the engine/technology you are using, baking of the code is more uncommon.&lt;br&gt;
In a time in which iteration time has become almost more important than the tech itself, playing with this balance can be the key for any successful software. It could sound exaggerated, but I really believe in that.&lt;br&gt;
As always, both ImGui and SDL will be our sword and shields for this adventure.&lt;br&gt;
This will be the second step into data-driven rendering: code generation.&lt;br&gt;&lt;/p&gt;

&lt;h2 id=&#34;are-we-writing-a-compiler&#34;&gt;Are we writing a compiler ?&lt;/h2&gt;

&lt;p&gt;Short answer: yes!&lt;/p&gt;

&lt;p&gt;Long answer: we will be writing the simplest possible compiler that reads a source file and transform in a destination file, like Flatbuffers.&lt;/p&gt;

&lt;p&gt;There are few links on both theory and practice that can help shed some light on the subject:
The Dragon Book (called because of the dragon in the cover) is still THE to-go in compiler writing as far as I know.&lt;br&gt;
It is an intense book and explores writing a full compiler with depth, starting from &lt;em&gt;Automata theory&lt;/em&gt; (just reminds me of how everything you study can be useful, I did 2 exams at University about that, wondering when I would use it! Hello prof &lt;a href=&#34;http://www.dia.uniroma3.it/~compunet/www/view/person.php?id=gdb&#34; target=&#34;_blank&#34;&gt;Di Battista!&lt;/a&gt;) to full code examples:&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://www.amazon.com/Compilers-Principles-Techniques-Tools-2nd/dp/0321486811&#34; target=&#34;_blank&#34;&gt;https://www.amazon.com/Compilers-Principles-Techniques-Tools-2nd/dp/0321486811&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;This is for me the best website on the subject, very precise and readable and follows closely what is inside the Dragon Book:&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://craftinginterpreters.com/&#34; target=&#34;_blank&#34;&gt;https://craftinginterpreters.com/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;And github page:&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/munificent/craftinginterpreters&#34; target=&#34;_blank&#34;&gt;https://github.com/munificent/craftinginterpreters&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;My interest was rekindled in 2015, when I was following the amazing Casey Muratori and his &lt;a href=&#34;https://handmadehero.org/&#34; target=&#34;_blank&#34;&gt;Handmade Hero&lt;/a&gt;.&lt;br&gt;
He generates code for introspection purposes, and really show a simple and effective way of generating code that works for you.&lt;/p&gt;

&lt;p&gt;Wikipedia itself also contains a lot of good articles on the subject. The more you know about the it, the more you want to know.
It is fascinating and very, very deep!&lt;/p&gt;

&lt;h1 id=&#34;compiler-101&#34;&gt;Compiler 101&lt;/h1&gt;

&lt;p&gt;A real compiler is a very complex and fascinating subject/software so I will try to get the simplest possible approach giving my (flawed and incomplete) perspective.&lt;/p&gt;

&lt;p&gt;A compiler is a series of transformations applied to data (you can apply this definition to every software actually).&lt;/p&gt;

&lt;p&gt;The input data is a text, and normally the output is still text, but with very different meaning.&lt;/p&gt;

&lt;p&gt;The raw depth of the subject is astonishing, consider that we are defining a grammar and thus a language, and how to express concepts into it.&lt;/p&gt;

&lt;p&gt;The main steps are the following:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Lexer/scanner/tokenizer&lt;/li&gt;
&lt;li&gt;Parser&lt;/li&gt;
&lt;li&gt;Code generation&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;We will define the code generator from a custom language called HDF (&lt;strong&gt;Hydra Definition Format&lt;/strong&gt;) to C++.
HDF will be a subset of &lt;strong&gt;Flatbuffers&lt;/strong&gt; in this exercise, but once the concepts are clear it can be expanded to more stuff.&lt;/p&gt;

&lt;h1 id=&#34;lexer-scanner-tokenizer&#34;&gt;Lexer/Scanner/Tokenizer&lt;/h1&gt;

&lt;p&gt;A &lt;strong&gt;lexer&lt;/strong&gt; or &lt;strong&gt;scanner&lt;/strong&gt; (or &lt;strong&gt;tokenizer&lt;/strong&gt;) is a software that translates an input string into a list of Tokens based on Lexemes.
A &lt;strong&gt;Lexeme&lt;/strong&gt; is one or more characters that create a Token. Think of a keyword (like if, class, static ).&lt;/p&gt;

&lt;p&gt;A Token is identified by a unique Lexeme and abstracts the Lexeme itself.
It normally contains a type and some attributes, for example it can save where that lexeme is into the input text, the line. The final structure of the token can vary a bit.&lt;/p&gt;

&lt;p&gt;In trying to find a simple definition for this step:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;The act of Tokenizing is the act of abstracting the input text.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;For example, given the following input text:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;static void amazing_method() {};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It will generate the list of tokens &lt;strong&gt;keyword, identifier, identifier, open parenthesis, close parenthesis, open brace, close brace, semicolon&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;This IS abstracting the text!&lt;/p&gt;

&lt;p&gt;Normally a lexer/scanner is used by the parser to go through the code and retrieve a token and use it in some way. Lets start seeing what a lexer could be!&lt;/p&gt;

&lt;h2 id=&#34;code&#34;&gt;Code&lt;/h2&gt;

&lt;p&gt;Let&amp;rsquo;s see the code used by the lexer.&lt;/p&gt;

&lt;p&gt;First thing will be to define the Token:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// Lexer/Tokenizer code. It is abstract enough so is not grammar specific.
//
struct Token {

    enum Type {
        Token_Unknown,

        Token_OpenParen,
        Token_CloseParen,
        Token_Colon,
        Token_Semicolon,
        Token_Asterisk,
        Token_OpenBracket,
        Token_CloseBracket,
        Token_OpenBrace,
        Token_CloseBrace,
        Token_OpenAngleBracket,
        Token_CloseAngleBracket,

        Token_String,
        Token_Identifier,
        Token_Number,

        Token_EndOfStream,
    }; // enum Type

    Type                            type;
    StringRef                       text;

}; // struct Token
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It is basically a enum with a StringRef.&lt;br&gt;
A StringRef is basically a substring - used to avoid allocations when parsing by simply saving where the Token is in the parsed text and how long it is.&lt;/p&gt;

&lt;p&gt;Next is the Lexer itself:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//
// The role of the Lexer is to divide the input string into a list of Tokens.
struct Lexer {
    
    char*                           position            = nullptr;    
    uint32_t                        line                = 0;
    uint32_t                        column              = 0;

    bool                            error               = false;
    uint32_t                        error_line          = 0;

}; // struct Lexer
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The most important variable is &lt;strong&gt;position&lt;/strong&gt; - it saves where the Lexer is in the current text for parsing.&lt;/p&gt;

&lt;p&gt;From now on there will be only methods.&lt;/p&gt;

&lt;p&gt;First some character classification that will help the Lexer:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//
// All those methods are to classify a character.
//
inline bool IsEndOfLine( char c ) {
    bool Result = ((c == &#39;\n&#39;) || (c == &#39;\r&#39;));
    return(Result);
}

inline bool IsWhitespace( char c ) {
    bool Result = ((c == &#39; &#39;) || (c == &#39;\t&#39;) || (c == &#39;\v&#39;) || (c == &#39;\f&#39;) || IsEndOfLine( c ));
    return(Result);
}

inline bool IsAlpha( char c ) {
    bool Result = (((c &amp;gt;= &#39;a&#39;) &amp;amp;&amp;amp; (c &amp;lt;= &#39;z&#39;)) || ((c &amp;gt;= &#39;A&#39;) &amp;amp;&amp;amp; (c &amp;lt;= &#39;Z&#39;)));
    return(Result);
}

inline bool IsNumber( char c ) {
    bool Result = ((c &amp;gt;= &#39;0&#39;) &amp;amp;&amp;amp; (c &amp;lt;= &#39;9&#39;));
    return(Result);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;These should be quite straightforward.&lt;/p&gt;

&lt;p&gt;Then we have &lt;strong&gt;the most important method for the lexer: nextToken&lt;/strong&gt;.&lt;br&gt;
This method will contain all the logic to go to the next token, and we will see it step by step.&lt;/p&gt;

&lt;p&gt;First is skipping all the whitespaces (empty characters, tabs, returns, etc) to arrive at the correct character in the text.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//
// This is the main method. Skip whitespaces and get next token. Save also the current position in the input string.
//
void nextToken( Lexer* lexer, Token&amp;amp; token ) {

    // Skip all whitespace first so that the token is without them.
    skipWhitespace( lexer );
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The code for skipping the whitespace is pretty straight-forward.
First it checks if it is a pure whitespace:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;void skipWhitespace( Lexer* lexer ) {
    // Scan text until whitespace is finished.
    for ( ;; ) {
        // Check if it is a pure whitespace first.
        if ( IsWhitespace( lexer-&amp;gt;position[0] ) ) {
            // Handle change of line
            if ( IsEndOfLine( lexer-&amp;gt;position[0] ) )
                ++lexer-&amp;gt;line;

            // Advance to next character
            ++lexer-&amp;gt;position;

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then it checks if it is a single line comment:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        } // Check for single line comments (&amp;quot;//&amp;quot;)
        else if ( (lexer-&amp;gt;position[0] == &#39;/&#39;) &amp;amp;&amp;amp; (lexer-&amp;gt;position[1] == &#39;/&#39;) ) {
            lexer-&amp;gt;position += 2;
            while ( lexer-&amp;gt;position[0] &amp;amp;&amp;amp; !IsEndOfLine( lexer-&amp;gt;position[0] ) ) {
                ++lexer-&amp;gt;position;
            }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And last it checks for c-style multiline comments:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        } // Check for c-style multi-lines comments
        else if ( (lexer-&amp;gt;position[0] == &#39;/&#39;) &amp;amp;&amp;amp; (lexer-&amp;gt;position[1] == &#39;*&#39;) ) {
            lexer-&amp;gt;position += 2;

            // Advance until the string is closed. Remember to check if line is changed.
            while ( !((lexer-&amp;gt;position[0] == &#39;*&#39;) &amp;amp;&amp;amp; (lexer-&amp;gt;position[1] == &#39;/&#39;)) ) {
                // Handle change of line
                if ( IsEndOfLine( lexer-&amp;gt;position[0] ) )
                    ++lexer-&amp;gt;line;

                // Advance to next character
                ++lexer-&amp;gt;position;
            }

            if ( lexer-&amp;gt;position[0] == &#39;*&#39; ) {
                lexer-&amp;gt;position += 2;
            }
        }
        else {
            break;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;After skipped all the whitespaces, we initialize the new token:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    // Initialize token
    token.type = Token::Token_Unknown;
    token.text.text = lexer-&amp;gt;position;
    token.text.length = 1;
    token.line = lexer-&amp;gt;line;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We get the current character and advance the position, so we can analize it.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    char c = lexer-&amp;gt;position[0];
    ++lexer-&amp;gt;position;

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here comes the character analisys using a simple &lt;strong&gt;switch&lt;/strong&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
    switch ( c ) {
        case &#39;\0&#39;:
        {
            token.type = Token::Token_EndOfStream;
        } break;
        case &#39;(&#39;:
        {
            token.type = Token::Token_OpenParen;
        } break;
        case &#39;)&#39;:
        {
            token.type = Token::Token_CloseParen;
        } break;
        case &#39;:&#39;:
        {
            token.type = Token::Token_Colon;
        } break;
        case &#39;;&#39;:
        {
            token.type = Token::Token_Semicolon;
        } break;
        case &#39;*&#39;:
        {
            token.type = Token::Token_Asterisk;
        } break;
        case &#39;[&#39;:
        {
            token.type = Token::Token_OpenBracket;
        } break;
        case &#39;]&#39;:
        {
            token.type = Token::Token_CloseBracket;
        } break;
        case &#39;{&#39;:
        {
            token.type = Token::Token_OpenBrace;
        } break;
        case &#39;}&#39;:
        {
            token.type = Token::Token_CloseBrace;
        } break;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There are some special cases left.&lt;br&gt;
First parsing a string starting from a &amp;lsquo;&amp;ldquo;&amp;rsquo; character.&lt;br&gt;
It requires to scan the text until it finds another &amp;lsquo;&amp;ldquo;&amp;rsquo; to indicate the end of the string.&lt;br&gt;
It also supports multiple-line strings with the characters &amp;ldquo;\&amp;rdquo; (double back-slash)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
        case &#39;&amp;quot;&#39;:
        {
            token.type = Token::Token_String;

            token.text.text = lexer-&amp;gt;position;

            while ( lexer-&amp;gt;position[0] &amp;amp;&amp;amp;
                    lexer-&amp;gt;position[0] != &#39;&amp;quot;&#39; )
            {
                if ( (lexer-&amp;gt;position[0] == &#39;\\&#39;) &amp;amp;&amp;amp;
                     lexer-&amp;gt;position[1] )
                {
                    ++lexer-&amp;gt;position;
                }
                ++lexer-&amp;gt;position;
            }

            // Saves total string length
            token.text.length = lexer-&amp;gt;position - token.text.text;

            if ( lexer-&amp;gt;position[0] == &#39;&amp;quot;&#39; ) {
                ++lexer-&amp;gt;position;
            }
        } break;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then the final classification step: first is checking if the token is an identifier (a string literal that starts with a character and is followed by characters, underscores or numbers).&lt;br&gt;
If not a identifier, check to see if it is a number. This should be expanded to correctly parse numbers, but for now is not used.&lt;br&gt;.
If everything else fails, than we don&amp;rsquo;t recognize the token.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        default:
        {
            // Identifier/keywords
            if ( IsAlpha( c ) ) {
                token.type = Token::Token_Identifier;

                while ( IsAlpha( lexer-&amp;gt;position[0] ) || IsNumber( lexer-&amp;gt;position[0] ) || (lexer-&amp;gt;position[0] == &#39;_&#39;) ) {
                    ++lexer-&amp;gt;position;
                }

                token.text.length = lexer-&amp;gt;position - token.text.text;
            } // Numbers
            else if ( IsNumber( c ) ) {
                token.type = Token::Token_Number;
            }
            else {
                token.type = Token::Token_Unknown;
            }
        } break;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;With this code we already have a working Lexer!&lt;br&gt;
I like to use the lexer in an abstract way - not knowing anything about the underlying language - so that it can be reused for different custom languages (Dr.Wily eyebrows movement goes here).&lt;br&gt;&lt;/p&gt;

&lt;p&gt;If you want to dive deeper into this, the amazing Crafting Interpreters contains a great page on scanning:&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://www.craftinginterpreters.com/scanning.html&#34; target=&#34;_blank&#34;&gt;https://www.craftinginterpreters.com/scanning.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Also, some c-style parsing can be found here from the amazing &lt;a href=&#34;https://twitter.com/niklasfrykholm&#34; target=&#34;_blank&#34;&gt;Niklas Frykohlm&lt;/a&gt;:&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/niklasfrykholm/nflibs/blob/master/nf_json_parser.c&#34; target=&#34;_blank&#34;&gt;https://github.com/niklasfrykholm/nflibs/blob/master/nf_json_parser.c&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;And another amazing parser from STB:&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/nothings/stb/blob/master/stb_c_lexer.h&#34; target=&#34;_blank&#34;&gt;https://github.com/nothings/stb/blob/master/stb_c_lexer.h&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;parser&#34;&gt;Parser&lt;/h1&gt;

&lt;p&gt;So far we have abstracted the input text into a list of &lt;strong&gt;Tokens&lt;/strong&gt;, and now we need to generate some more information before arriving at generating new code.&lt;/p&gt;

&lt;p&gt;As far as &lt;em&gt;I understood it&lt;/em&gt;, a parser reads the tokens and generates an &lt;strong&gt;Abstract Syntax Tree&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Sometimes, and in simpler parsers, the act of parsing itself can generates a new code if the language we are targeting is simple.
Again, I prefer to separate Lexer and Parser to reuse the Lexer for different languages and separate the responsabilities!&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Given a list of tokens and a grammar, a parser generates an Abstract Syntax Tree.&lt;/p&gt;

&lt;p&gt;It gives meaning to the input text, and is responsible to check the syntax correctness.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;A simple definition for a grammar is the following:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;A grammar is a set of production rules that transforms a series of non-terminals into terminals.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Putting everything in the perspective of data and transformations we can define:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Terminals&lt;/strong&gt; are finalized data&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Non-terminals&lt;/strong&gt; are data that must be transformed&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Production rules&lt;/strong&gt; are transformations of &lt;strong&gt;non-terminals&lt;/strong&gt; to &lt;strong&gt;terminals&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Another definition of a parser than it could be :&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;A parser is a software that transforms non-terminals in terminals following production rules.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;grammar&#34;&gt;Grammar&lt;/h2&gt;

&lt;p&gt;It is time to write the formal grammar (a context-free grammar) and see how it maps to code.&lt;br&gt;
It will be very simple  much simpler than many examples you find around  but it is a starting point.&lt;br&gt;
We will not deal with any expression, statements and such, not in the context of this code generator. I will point out some examples for more complex stuff, but I want to study more the subject for that to be more precise about the subject.&lt;br&gt;&lt;/p&gt;

&lt;p&gt;Each line will be a &lt;strong&gt;production rule&lt;/strong&gt; (a transformation), with the left-side being always a non-terminal.&lt;br&gt;
We are using regular expressions syntax here:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;alphabet  [a-zA-z]&lt;/li&gt;
&lt;li&gt;number [09]&lt;/li&gt;
&lt;li&gt;identifier  alphabet (alphabet | number | _)*&lt;/li&gt;
&lt;li&gt;variable_declaration  identifier identifier ;&lt;/li&gt;
&lt;li&gt;struct_declaration  struct identifier { (variable_declaration)+ } ;&lt;/li&gt;
&lt;li&gt;enum_declaration  enum identifier { (identifier)+ }&lt;/li&gt;
&lt;li&gt;module  (struct_declaration | enum_declaration)+*&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;First we define what an identifier is  a sequence of alpha-numerical characters that can contains also the underscore character.&lt;br&gt;Notice that with the identifier production rule, the identifier cannot start with an underscore.&lt;br&gt;
A variable then is declared simply by two identifiers: the first for the type and the second for the name, following a semicolon.&lt;br&gt;
A struct is simply a list of variable declarations. Notice the + in the rule  this means that at least one element must be present.&lt;br&gt;
Enums are literally a name for the enum and a list of identifiers in curly braces.&lt;br&gt;
Finally the module is the root of our grammar. It will contain all the declarations we describe. See it as the data file we are writing to generate the code  one file is one module.&lt;br&gt;
Now that we defined a simple grammar, we can move to the theory behind the parser.&lt;br&gt;&lt;/p&gt;

&lt;h2 id=&#34;predictive-recursive-descent-parser&#34;&gt;Predictive Recursive Descent Parser&lt;/h2&gt;

&lt;p&gt;The grammar we defined is a context-free-grammar.&lt;br&gt;
Depending on the type of grammar we can write different parsers.&lt;br&gt;
One of the most common type of parser (and easier to start with) is the &lt;a href=&#34;https://en.wikipedia.org/wiki/Recursive_descent_parser&#34; target=&#34;_blank&#34;&gt;Predictive Recursive Descent Parser&lt;/a&gt;, and that is what we will write given our grammar. You can dive into all the details of writing a context-free grammar, writing a &lt;a href=&#34;https://en.wikipedia.org/wiki/LL_parser&#34; target=&#34;_blank&#34;&gt;Left-to-right Leftmost-derivation grammar (LL(k))&lt;/a&gt; and such and be amazed by all the concepts behind.&lt;br&gt;&lt;/p&gt;

&lt;p&gt;Again, I am personally starting on this subject, so my knowledge is not deep.&lt;/p&gt;

&lt;p&gt;Back to the parser, the main characteristics of this parser are:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Descent = top-down. Start from root and generate the Abstract Syntax Tree.&lt;/li&gt;
&lt;li&gt;Recursive = the parser has mutually recursive methods, one for each non-terminal.&lt;/li&gt;
&lt;li&gt;Predictive = no backtracking needed. For our simple grammar we do not need any backtracking.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;So the parser will start from the root (module non-terminal) and by sequentially reading all the tokens will generate a tree that represent our syntax.&lt;/p&gt;

&lt;p&gt;Lets see some code!&lt;/p&gt;

&lt;h2 id=&#34;code-1&#34;&gt;Code&lt;/h2&gt;

&lt;p&gt;The central piece of code is the Parser.&lt;br&gt;
It uses the Lexer and saves the Types by parsing the input text.&lt;br&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//
// The Parser parses Tokens using the Lexer and generate an Abstract Syntax Tree.
struct Parser {

    Lexer*                          lexer               = nullptr;

    ast::Type*                      types               = nullptr;
    uint32_t                        types_count         = 0;
    uint32_t                        types_max           = 0;

}; // struct Parser
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let&amp;rsquo;s have a look at the class &lt;strong&gt;Type&lt;/strong&gt;.&lt;br&gt;
This class will let us identify correctly primitive types, enums, struct and &lt;em&gt;commands&lt;/em&gt; - a special keyword I create to show a concept that can be used away from the canonical C/C++ languages.&lt;br&gt;
By saving a list of names and types we can successfully parse all the types listed above.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//
// Define the language specific structures.
namespace ast {

    struct Type {

        enum Types {
            Types_Primitive, Types_Enum, Types_Struct, Types_Command, Types_None
        };

        enum PrimitiveTypes {
            Primitive_Int32, Primitive_Uint32, Primitive_Int16, Primitive_Uint16, Primitive_Int8, Primitive_Uint8, Primitive_Int64, Primitive_Uint64, Primitive_Float, Primitive_Double, Primitive_Bool, Primitive_None
        };

        Types                       type;
        PrimitiveTypes              primitive_type;
        StringRef                   name;

        std::vector&amp;lt;StringRef&amp;gt;      names;
        std::vector&amp;lt;const Type*&amp;gt;    types;
        bool                        exportable = true;

    }; // struct Type

} // namespace ast
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And now the actual code making the magic happens!&lt;br&gt;
Entry point for the parsing is generateAST.&lt;br&gt;
It simply goes through ALL the tokens until it reaches the end of the file.&lt;br&gt;
At this level of parsing, we parse only identifiers (keywords like &amp;lsquo;struct&amp;rsquo;, &amp;lsquo;enum&amp;rsquo;, &amp;hellip;).&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;void generateAST( Parser* parser ) {

    // Read source text until the end.
    // The main body can be a list of declarations.
    bool parsing = true;

    while ( parsing ) {

        Token token;
        nextToken( parser-&amp;gt;lexer, token );

        switch ( token.type ) {

            case Token::Token_Identifier:
            {
                identifier( parser, token );
                break;
            }

            case Token::Type::Token_EndOfStream:
            {
                parsing = false;
                break;
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The method &amp;lsquo;identifier&amp;rsquo; searches for the language keywords and acts accordingly.&lt;br&gt;
The method &amp;lsquo;expectKeyword&amp;rsquo; simply checks that the keywords are the same.&lt;br&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;inline void identifier( Parser* parser, const Token&amp;amp; token ) {

    // Scan the name to know which 
    for ( uint32_t i = 0; i &amp;lt; token.text.length; ++i ) {
        char c = *(token.text.text + i);

        switch ( c ) {
            case &#39;s&#39;:
            {
                if ( expectKeyword( token.text, 6, &amp;quot;struct&amp;quot; ) ) {
                    declarationStruct( parser );
                    return;
                }
                    
                break;
            }

            case &#39;e&#39;:
            {
                if ( expectKeyword( token.text, 4, &amp;quot;enum&amp;quot; ) ) {
                    declarationEnum( parser );
                    return;
                }
                break;
            }

            case &#39;c&#39;:
            {
                if ( expectKeyword( token.text, 7, &amp;quot;command&amp;quot; ) ) {
                    declarationCommand( parser );
                    return;
                }
                break;
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The next methods are the real core of parsing a language.
When declaring a struct, the token we have are:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Identifier &amp;lsquo;struct&amp;rsquo; (parsed already by generateAST method)&lt;/li&gt;
&lt;li&gt;Name of the struct&lt;/li&gt;
&lt;li&gt;Open braces&lt;/li&gt;
&lt;li&gt;Zero or more variables&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;The method expectToken checks the presence of the expected token and saves the line if an error occurs.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;inline void declarationStruct( Parser* parser ) {
    // name
    Token token;
    if ( !expectToken( parser-&amp;gt;lexer, token, Token::Token_Identifier ) ) {
        return;
    }

    // Cache name string
    StringRef name = token.text;
    
    if ( !expectToken( parser-&amp;gt;lexer, token, Token::Token_OpenBrace ) ) {
        return;
    }

    // Add new type
    ast::Type&amp;amp; type = parser-&amp;gt;types[parser-&amp;gt;types_count++];
    type.name = name;
    type.type = ast::Type::Types_Struct;
    type.exportable = true;

    // Parse struct internals
    while ( !equalToken( parser-&amp;gt;lexer, token, Token::Token_CloseBrace ) ) {

        if ( token.type == Token::Token_Identifier ) {
            declarationVariable( parser, token.text, type );
        }
    }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The parsing of a variable is even simpler, just a type followed by the name.
When reading the type, it searches through the list of all types saved until then.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;inline void declarationVariable( Parser* parser, const StringRef&amp;amp; type_name, ast::Type&amp;amp; type ) {
    const ast::Type* variable_type = findType( parser, type_name );
    Token token;
    // Name
    if ( !expectToken( parser-&amp;gt;lexer, token, Token::Token_Identifier ) ) {
        return;
    }

    // Cache name string
    StringRef name = token.text;

    if ( !expectToken( parser-&amp;gt;lexer, token, Token::Token_Semicolon ) ) {
        return;
    }

    type.types.emplace_back( variable_type );
    type.names.emplace_back( name );
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The parsing of the enum is:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&amp;lsquo;enum&amp;rsquo; keyword&lt;/li&gt;
&lt;li&gt;Enum name&lt;/li&gt;
&lt;li&gt;(optional) Semicolon and type, taken from Flatbuffers syntax&lt;/li&gt;
&lt;li&gt;Open brace&lt;/li&gt;
&lt;li&gt;List of identifiers that corresponds to the enum values&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
inline void declarationEnum( Parser* parser ) {
    Token token;
    // Name
    if ( !expectToken( parser-&amp;gt;lexer, token, Token::Token_Identifier ) ) {
        return;
    }

    // Cache name string
    StringRef name = token.text;

    // Optional &#39;: type&#39; for the enum
    nextToken( parser-&amp;gt;lexer, token );
    if ( token.type == Token::Token_Colon ) {
        // Skip to open brace
        nextToken( parser-&amp;gt;lexer, token );
        // Token now contains type_name
        nextToken( parser-&amp;gt;lexer, token );
        // Token now contains open brace.
    }
    
    if ( token.type != Token::Token_OpenBrace ) {
        return;
    }

    // Add new type
    ast::Type&amp;amp; type = parser-&amp;gt;types[parser-&amp;gt;types_count++];
    type.name = name;
    type.type = ast::Type::Types_Enum;
    type.exportable = true;

    // Parse struct internals
    while ( !equalToken( parser-&amp;gt;lexer, token, Token::Token_CloseBrace ) ) {

        if ( token.type == Token::Token_Identifier ) {
            type.names.emplace_back( token.text );
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A command is a special construct that I use in my code, normally with a CommandBuffer, and with the current syntax from HDF:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;command WindowEvents {
    Click {
      int16 x;
      int16 y;
      int16 button;
    }
    Move {
      int16 x;
      int16 y;
    }
    Wheel {
       int16 z;
    }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And this is the parsing of the command.&lt;br&gt;
I think this can be the best example of mapping between the language and the parsing.&lt;br&gt;
Parsing is:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Name&lt;/li&gt;
&lt;li&gt;Open brace&lt;/li&gt;
&lt;li&gt;Scan of identifiers until close brace&lt;/li&gt;
&lt;li&gt;For each identifier, add a type and scan for internal variables.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;inline void declarationCommand( Parser* parser ) {
    // name
    Token token;
    if ( !expectToken( parser-&amp;gt;lexer, token, Token::Token_Identifier ) ) {
        return;
    }

    // Cache name string
    StringRef name = token.text;

    if ( !expectToken( parser-&amp;gt;lexer, token, Token::Token_OpenBrace ) ) {
        return;
    }

    // Add new type
    ast::Type&amp;amp; command_type = parser-&amp;gt;types[parser-&amp;gt;types_count++];
    command_type.name = name;
    command_type.type = ast::Type::Types_Command;
    command_type.exportable = true;

    // Parse struct internals
    while ( !equalToken( parser-&amp;gt;lexer, token, Token::Token_CloseBrace ) ) {

        if ( token.type == Token::Token_Identifier ) {
            // Create a new type for each command
            // Add new type
            ast::Type&amp;amp; type = parser-&amp;gt;types[parser-&amp;gt;types_count++];
            type.name = token.text;
            type.type = ast::Type::Types_Struct;
            type.exportable = false;

            while ( !equalToken( parser-&amp;gt;lexer, token, Token::Token_CloseBrace ) ) {
                if ( token.type == Token::Token_Identifier ) {
                    declarationVariable( parser, token.text, type );
                }
            }

            command_type.names.emplace_back( type.name );
            command_type.types.emplace_back( &amp;amp;type );
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;abstract-syntax-tree&#34;&gt;Abstract Syntax Tree&lt;/h2&gt;

&lt;p&gt;We choose to simply have data definitions, and Ive decided that the nodes of the tree will be types.&lt;br&gt;
A type can be a primitive type, a container of variables (like a Struct in C, but without methods) enums and commands.&lt;br&gt;
Commands are just a way of showing the creation of a construct that I use and requires some boilerplate code, but I dont want to write that code.&lt;br&gt;
If we remember the definition of the class Type from the code before, it all boils down to a name,a list of names and optionally types.&lt;br&gt;
With this simple definition I can express primitive types, structs and enums all in one!&lt;br&gt;
For enums, I save the anme of the enum and in the name list all the different values. That is enough to later generate the code.&lt;br&gt;
For structs, again the name is saved, and then the variables. A variable is a tuple of identifiers type, name. When parsing them, the type is searched in the registered ones.&lt;br&gt;
A trick here is to initialize the parser with primitive types, and then add each type (both struct and enums) when parsing them.&lt;br&gt;&lt;/p&gt;

&lt;h1 id=&#34;code-generation&#34;&gt;Code Generation&lt;/h1&gt;

&lt;p&gt;The last stage will generate the files in the language that we want, using the informations from the &lt;strong&gt;AST&lt;/strong&gt;.&lt;br&gt;
This part will literally write the code for us, the all purpose of this code.&lt;br&gt;
The most fundamental question is: &lt;em&gt;what code do I want to generate?&lt;/em&gt;.&lt;br&gt;
A simple but deep question.&lt;br&gt;
We are trying to remove the writing of boilerplate code from or lives, so anything that you consider boilerplate and easy to automate goes here.
Even if until here we wrote in C++, the final output can be any language.&lt;br&gt;
This means that you can define data and translate it to multiple languages!&lt;br&gt;&lt;/p&gt;

&lt;p&gt;For our example, we will output C++ code and add UI using ImGui, similar to the Flatbuffers example I wrote before.&lt;br&gt;
Lets see the three different construct we can output with our language.&lt;br&gt;&lt;/p&gt;

&lt;h2 id=&#34;enum&#34;&gt;Enum&lt;/h2&gt;

&lt;p&gt;We defined an enum as a name and a list of named values.
For the simplicity of this example, we are not assigning manual values to the enum, but it is something easily changeable, and I will do it in the future.
Given the enum in HDF:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;enum BlendOperation : byte { Add, Subtract, RevSubtract, Min, Max }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Which code do we want to generate ?&lt;/p&gt;

&lt;p&gt;When I write enums, I almost always need the stringed version of the values. Also I want to add a last value, Count, so that I can use it if I need to allocate anything based on the enum.&lt;br&gt;
As a bonus, I can create a second enum with the bit shifts  called mask  for some use cases.&lt;br&gt;
All of this will be automatically done by the code generator, starting with a simple enum!&lt;br&gt;
In this piece of code, I will use three different streams for the different parts of the enum (enum itself, value names and mask) and combine them into the final generated file.&lt;br&gt;
Also to note that the strings here are String Ref  basically a string that points to the input source code and stores the length of the string, so that there is no need to allocate it newly.&lt;br&gt;
I will use a temporary buffer to null terminate it and write into the output file.&lt;br&gt;&lt;/p&gt;

&lt;p&gt;This will be the generated code:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;namespace BlendOperation {
	enum Enum {
		Add, Subtract, RevSubtract, Min, Max, Count
	};

	enum Mask {
		Add_mask = 1 &amp;lt;&amp;lt; 0, Subtract_mask = 1 &amp;lt;&amp;lt; 1, RevSubtract_mask = 1 &amp;lt;&amp;lt; 2, Min_mask = 1 &amp;lt;&amp;lt; 3, Max_mask = 1 &amp;lt;&amp;lt; 4, Count_mask = 1 &amp;lt;&amp;lt; 5
	};

	static const char* s_value_names[] = {
		&amp;quot;Add&amp;quot;, &amp;quot;Subtract&amp;quot;, &amp;quot;RevSubtract&amp;quot;, &amp;quot;Min&amp;quot;, &amp;quot;Max&amp;quot;, &amp;quot;Count&amp;quot;
	};

	static const char* ToString( Enum e ) {
		return s_value_names[(int)e];
	}
} // namespace BlendOperation
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The enum itself (inside a namespace), a mask and the string version for debugging purposes.&lt;br&gt;
All generated from that one line!&lt;br&gt;&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s go into a step by step review of the code.&lt;br&gt;
First there is the initialization of some auxiliary buffers to handle dynamic strings without allocating memory.&lt;br&gt;
These are the usages:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Values will contain all the enum comma separated values&lt;/li&gt;
&lt;li&gt;Value_names will contain the string version of the values&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Value_masks will contain an optional bitmask for the values.
&lt;br&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;void outputCPPEnum( CodeGenerator* code_generator, FILE* output, const ast::Type&amp;amp; type ) {

// Empty enum: skip output.
if ( type.names.size() == 0 )
    return;

code_generator-&amp;gt;string_buffer_0.clear();
code_generator-&amp;gt;string_buffer_1.clear();
code_generator-&amp;gt;string_buffer_2.clear();

StringBuffer&amp;amp; values = code_generator-&amp;gt;string_buffer_0;
StringBuffer&amp;amp; value_names = code_generator-&amp;gt;string_buffer_1;
StringBuffer&amp;amp; value_masks = code_generator-&amp;gt;string_buffer_2;
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;We start by adding the character &amp;lsquo;&amp;ldquo;&amp;rsquo; in the names - they will be C strings!&lt;br&gt;
Then we have a couple of options, just as demonstration: add mask (for the bitmask) and add max, that adds a last element to the generated enum.&lt;br&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    value_names.append( &amp;quot;\&amp;quot;&amp;quot; );

    bool add_max = true;
    bool add_mask = true;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Next step is the core: go through all the names saved in the enum &lt;strong&gt;ast::Type&lt;/strong&gt; during the &lt;strong&gt;parsing&lt;/strong&gt; phase, and add the literal as is in the enum, the literal in string version and optional mask.&lt;br&gt;
We also need to take care of the enum with 1 values, they behave in a different way.&lt;br&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    char name_buffer[256];

    // Enums with more than 1 values
    if ( type.names.size() &amp;gt; 1 ) {
        const uint32_t max_values = type.names.size() - 1;
        for ( uint32_t v = 0; v &amp;lt; max_values; ++v ) {

            if ( add_mask ) {
                value_masks.append( type.names[v] );
                value_masks.append( &amp;quot;_mask = 1 &amp;lt;&amp;lt; &amp;quot; );
                value_masks.append( _itoa( v, name_buffer, 10 ) );
                value_masks.append( &amp;quot;, &amp;quot; );
            }

            values.append( type.names[v] );
            values.append( &amp;quot;, &amp;quot; );

            value_names.append( type.names[v] );
            value_names.append( &amp;quot;\&amp;quot;, \&amp;quot;&amp;quot; );
        }

        if ( add_mask ) {
            value_masks.append( type.names[max_values] );
            value_masks.append( &amp;quot;_mask = 1 &amp;lt;&amp;lt; &amp;quot; );
            value_masks.append( _itoa( max_values, name_buffer, 10 ) );
        }

        values.append( type.names[max_values] );

        value_names.append( type.names[max_values] );
        value_names.append( &amp;quot;\&amp;quot;&amp;quot; );
    }
    else {
        
        if ( add_mask ) {
            value_masks.append( type.names[0] );
            value_masks.append( &amp;quot;_mask = 1 &amp;lt;&amp;lt; &amp;quot; );
            value_masks.append( _itoa( 0, name_buffer, 10 ) );
        }

        values.append( type.names[0] );

        value_names.append( type.names[0] );
        value_names.append( &amp;quot;\&amp;quot;&amp;quot; );
    }

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;After writing all the values we can add the optional max value in the output:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    if ( add_max ) {
        values.append( &amp;quot;, Count&amp;quot; );

        value_names.append( &amp;quot;, \&amp;quot;Count\&amp;quot;&amp;quot; );

        if ( add_mask ) {
            value_masks.append( &amp;quot;, Count_mask = 1 &amp;lt;&amp;lt; &amp;quot; );
            value_masks.append( _itoa( type.names.size(), name_buffer, 10 ) );
        }
    }
    
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Until now we just saved all those values in the StringBuffers, but still not in the file.&lt;br&gt;
The final piece of code output to file the enum with all the additional data:&lt;br&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    copy( type.name, name_buffer, 256 );

    fprintf( output, &amp;quot;namespace %s {\n&amp;quot;, name_buffer );

    fprintf( output, &amp;quot;\tenum Enum {\n&amp;quot; );
    fprintf( output, &amp;quot;\t\t%s\n&amp;quot;, values.data );
    fprintf( output, &amp;quot;\t};\n&amp;quot; );

    // Write the mask
    if ( add_mask ) {
        fprintf( output, &amp;quot;\n\tenum Mask {\n&amp;quot; );
        fprintf( output, &amp;quot;\t\t%s\n&amp;quot;, value_masks.data );
        fprintf( output, &amp;quot;\t};\n&amp;quot; );
    }

    // Write the string values
    fprintf( output, &amp;quot;\n\tstatic const char* s_value_names[] = {\n&amp;quot; );
    fprintf( output, &amp;quot;\t\t%s\n&amp;quot;, value_names.data );
    fprintf( output, &amp;quot;\t};\n&amp;quot; );

    fprintf( output, &amp;quot;\n\tstatic const char* ToString( Enum e ) {\n&amp;quot; );
    fprintf( output, &amp;quot;\t\treturn s_value_names[(int)e];\n&amp;quot; );
    fprintf( output, &amp;quot;\t}\n&amp;quot; );

    fprintf( output, &amp;quot;} // namespace %s\n\n&amp;quot;, name_buffer );
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;struct&#34;&gt;Struct&lt;/h2&gt;

&lt;p&gt;Structs are the bread-and-butter of data definition.
In this simple example we do not handle pointers or references, so it is pretty straight-forward, but as a start in coding generation this could already be powerful for many cases.
Lets start with a definition for our dream Data-Driven-Rendering:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// file.hdf
struct RenderTarget {
    uint16 			width;
    uint16 			height;
    float 			scale_x;
    float 			scale_y;
    TextureFormat 	format;
};

struct RenderPass {
    RenderTarget 	rt0;
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We want to generate both the ready to use header in C++ and UI using ImGui.&lt;br&gt;
The output for this struct will be obtained by simply iterating through all its members and, based on the type of the member, write some code.&lt;br&gt;
For primitive types there is a translation that must be done to the C++ language  thus we saved a list of c++ primitive types keyword into the code.&lt;br&gt;
For the UI area we will define two methods: reflectMembers, that simply adds the ImGui commands needed, and reflectUI, that embeds the members into a Window. This is done so that when starting from a root type I can create a window that let me edit its value, and recursively it can add other members UI if they are coming from another struct.&lt;br&gt;
This is shown with the RenderPass struct.&lt;br&gt;&lt;/p&gt;

&lt;p&gt;This will be the generated code, that includes ImGui too:&lt;br&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// CodeGenerated.h

struct RenderTarget {

	uint16_t width;
	uint16_t height;
	float scale_x;
	float scale_y;
	TextureFormat::Enum format;

	void reflectMembers() {
		ImGui::InputScalar( &amp;quot;width&amp;quot;, ImGuiDataType_U16, &amp;amp;width );
		ImGui::InputScalar( &amp;quot;height&amp;quot;, ImGuiDataType_U16, &amp;amp;height );
		ImGui::InputScalar( &amp;quot;scale_x&amp;quot;, ImGuiDataType_Float, &amp;amp;scale_x );
		ImGui::InputScalar( &amp;quot;scale_y&amp;quot;, ImGuiDataType_Float, &amp;amp;scale_y );
		ImGui::Combo( &amp;quot;format&amp;quot;, (int32_t*)&amp;amp;format, TextureFormat::s_value_names, TextureFormat::Count );
	}

	void reflectUI() {
		ImGui::Begin(&amp;quot;RenderTarget&amp;quot;);
		reflectMembers();
		ImGui::End();
	}


}; // struct RenderTarget
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now let&amp;rsquo;s have a look at the code that will generate that.&lt;br&gt;
First some init steps: clear and alias the StringBuffer, allocate some char buffers on the stack, copy the StringRef into the name buffer:&lt;br&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
void outputCPPStruct( CodeGenerator* code_generator, FILE* output, const ast::Type&amp;amp; type ) {
    const char* tabs = &amp;quot;&amp;quot;;

    code_generator-&amp;gt;string_buffer_0.clear();

    StringBuffer&amp;amp; ui_code = code_generator-&amp;gt;string_buffer_0;

    char name_buffer[256], member_name_buffer[256], member_type_buffer[256];
    copy( type.name, name_buffer, 256 );

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Next is already a powerful piece of code.&lt;br&gt;
Outputting the UI code and iterating through each member.&lt;br&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    if ( code_generator-&amp;gt;generate_imgui ) {
        ui_code.append( &amp;quot;\n\tvoid reflectMembers() {\n&amp;quot; );
    }

    fprintf( output, &amp;quot;%sstruct %s {\n\n&amp;quot;, tabs, name_buffer );

    for ( int i = 0; i &amp;lt; type.types.size(); ++i ) {
        const ast::Type&amp;amp; member_type = *type.types[i];
        const StringRef&amp;amp; member_name = type.names[i];

        copy( member_name, member_name_buffer, 256 );

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We are in the middle of the loop, and we want to check if the current member type is a primitive one, then it needs some work to do.&lt;br&gt;
First, output the language specific primitive type keyword (using the s_primitive_type_cpp array).&lt;br&gt;
Second, add some ImGui code to edit the field directly.&lt;br&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
        // Translate type name based on output language.
        switch ( member_type.type ) {
            case ast::Type::Types_Primitive:
            {
                strcpy_s( member_type_buffer, 256, s_primitive_type_cpp[member_type.primitive_type] );
                fprintf( output, &amp;quot;%s\t%s %s;\n&amp;quot;, tabs, member_type_buffer, member_name_buffer );
                
                if ( code_generator-&amp;gt;generate_imgui ) {
                    switch ( member_type.primitive_type ) {
                        case ast::Type::Primitive_Int8:
                        case ast::Type::Primitive_Uint8:
                        case ast::Type::Primitive_Int16:
                        case ast::Type::Primitive_Uint16:
                        case ast::Type::Primitive_Int32:
                        case ast::Type::Primitive_Uint32:
                        case ast::Type::Primitive_Int64:
                        case ast::Type::Primitive_Uint64:
                        case ast::Type::Primitive_Float:
                        case ast::Type::Primitive_Double:
                        {
                            ui_code.append( &amp;quot;\t\tImGui::InputScalar( \&amp;quot;%s\&amp;quot;, %s, &amp;amp;%s );\n&amp;quot;, member_name_buffer, s_primitive_type_imgui[member_type.primitive_type], member_name_buffer );
                            
                            break;
                        }
                        
                        case ast::Type::Primitive_Bool:
                        {
                            ui_code.append( &amp;quot;\t\tImGui::Checkbox( \&amp;quot;%s\&amp;quot;, &amp;amp;%s );\n&amp;quot;, member_name_buffer, member_name_buffer );
                            break;
                        }
                    }
                }

                break;
            }

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In case of a struct as a member, use the typename as is and call the &amp;lsquo;reflectMembers&amp;rsquo; method for the UI generation:&lt;br&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;            case ast::Type::Types_Struct:
            {
                copy( member_type.name, member_type_buffer, 256 );
                fprintf( output, &amp;quot;%s\t%s %s;\n&amp;quot;, tabs, member_type_buffer, member_name_buffer );

                if ( code_generator-&amp;gt;generate_imgui ) {
                    ui_code.append( &amp;quot;\t\tImGui::Text(\&amp;quot;%s\&amp;quot;);\n&amp;quot;, member_name_buffer );
                    ui_code.append( &amp;quot;\t\t%s.reflectMembers();\n&amp;quot;, member_name_buffer );
                }

                break;
            }

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For enums use the format namespace::Enum that comes with the generated code (and can be anything else) and add a Combo for ImGui. The combo is using the string array generated previously! This is powerful!&lt;br&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;            case ast::Type::Types_Enum:
            {
                copy( member_type.name, member_type_buffer, 256 );
                fprintf( output, &amp;quot;%s\t%s::Enum %s;\n&amp;quot;, tabs, member_type_buffer, member_name_buffer );

                if ( code_generator-&amp;gt;generate_imgui ) {
                    ui_code.append( &amp;quot;\t\tImGui::Combo( \&amp;quot;%s\&amp;quot;, (int32_t*)&amp;amp;%s, %s::s_value_names, %s::Count );\n&amp;quot;, member_name_buffer, member_name_buffer, member_type_buffer, member_type_buffer );
                }

                break;
            }

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To finish up simlpy add the reflectUI method, that embed the members reflection in a window and finish.&lt;br&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;            default:
            {
                break;
            }
        }
    }

    ui_code.append( &amp;quot;\t}&amp;quot; );
    ui_code.append( &amp;quot;\n\n\tvoid reflectUI() {\n\t\tImGui::Begin(\&amp;quot;%s\&amp;quot;);\n\t\treflectMembers();\n\t\tImGui::End();\n\t}\n&amp;quot;, name_buffer );

    fprintf( output, &amp;quot;%s\n&amp;quot;, ui_code.data );

    fprintf( output, &amp;quot;\n%s}; // struct %s\n\n&amp;quot;, tabs, name_buffer );
}

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;command&#34;&gt;Command&lt;/h2&gt;

&lt;p&gt;I wanted to include an example of something that does not exist in any language, but it shows the power of removing boilerplate code.&lt;/p&gt;

&lt;p&gt;I define commands as little structs with a type used anytime I need to do some command parsing, normally from a ring buffer.&lt;/p&gt;

&lt;p&gt;The command should have an enum with all the types already, and each struct should have its type assigned.
The type is normally used to cycle through the commands and do something accordingly.&lt;/p&gt;

&lt;p&gt;It will output structs because of the need to allocate them in the ring buffer, thus must be simple.&lt;/p&gt;

&lt;p&gt;First let&amp;rsquo;s see the HDF file. The example are window events commands:&lt;br&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;command WindowEvents {

	Click {
		int16 x;
        int16 y;
        int16 button;
	}

	Move {
		int16 x;
		int16 y;
	}

    Wheel {
        int16 z;
    }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The generated code will be:&lt;br&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;namespace WindowEvents {
	enum Type {
		Type_Click, Type_Move, Type_Wheel
	};

	struct Click {

		int16_t x;
		int16_t y;
		int16_t button;

		static Type GetType() { return Type_Click; }

	}; // struct Wheel

	struct Move {

		int16_t x;
		int16_t y;

		static Type GetType() { return Type_Move; }

	}; // struct Wheel

	struct Wheel {

		int16_t z;

		static Type GetType() { return Type_Wheel; }

	}; // struct Wheel

}; // namespace WindowEvents
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And finally the C++ code that generates the output.&lt;br&gt;
The output starts with an enum with all the types, that I normally use to switch commands:&lt;br&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;void outputCPPCommand( CodeGenerator* code_generator, FILE* output, const ast::Type&amp;amp; type ) {

    char name_buffer[256], member_name_buffer[256], member_type_buffer[256];
    copy( type.name, name_buffer, 256 );

    fprintf( output, &amp;quot;namespace %s {\n&amp;quot;, name_buffer );

    // Add enum with all types
    fprintf( output, &amp;quot;\tenum Type {\n&amp;quot; );
    fprintf( output, &amp;quot;\t\t&amp;quot; );
    for ( int i = 0; i &amp;lt; type.types.size() - 1; ++i ) {
        const ast::Type&amp;amp; command_type = *type.types[i];
        copy( command_type.name, name_buffer, 256 );
        fprintf( output, &amp;quot;Type_%s, &amp;quot;, name_buffer );
    }

    const ast::Type* last_type = type.types[type.types.size() - 1];
    copy( last_type-&amp;gt;name, name_buffer, 256 );
    fprintf( output, &amp;quot;Type_%s&amp;quot;, name_buffer );
    fprintf( output, &amp;quot;\n\t};\n\n&amp;quot; );
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then we output all the command structs (like Click, Move, &amp;hellip;).&lt;br&gt;
For each command type we output a struct with all its members. This is similar to the output of the structs:&lt;br&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    const char* tabs = &amp;quot;\t&amp;quot;;

    for ( int i = 0; i &amp;lt; type.types.size(); ++i ) {
        const ast::Type&amp;amp; command_type = *type.types[i];

        copy( command_type.name, member_type_buffer, 256 );
        fprintf( output, &amp;quot;%sstruct %s {\n\n&amp;quot;, tabs, member_type_buffer );
        
        for ( int i = 0; i &amp;lt; command_type.types.size(); ++i ) {
            const ast::Type&amp;amp; member_type = *command_type.types[i];
            const StringRef&amp;amp; member_name = command_type.names[i];

            copy( member_name, member_name_buffer, 256 );

            // Translate type name based on output language.
            switch ( member_type.type ) {
                case ast::Type::Types_Primitive:
                {
                    strcpy_s( member_type_buffer, 256, s_primitive_type_cpp[member_type.primitive_type] );
                    fprintf( output, &amp;quot;%s\t%s %s;\n&amp;quot;, tabs, member_type_buffer, member_name_buffer );

                    break;
                }

                case ast::Type::Types_Struct:
                {
                    copy( member_type.name, member_type_buffer, 256 );
                    fprintf( output, &amp;quot;%s\t%s %s;\n&amp;quot;, tabs, member_type_buffer, member_name_buffer );

                    break;
                }

                case ast::Type::Types_Enum:
                {
                    copy( member_type.name, member_type_buffer, 256 );
                    fprintf( output, &amp;quot;%s\t%s::Enum %s;\n&amp;quot;, tabs, member_type_buffer, member_name_buffer );

                    break;
                }

                default:
                {
                    break;
                }
            }
        }

        copy( command_type.name, member_type_buffer, 256 );

        fprintf( output, &amp;quot;\n%s\tstatic Type GetType() { return Type_%s; }\n&amp;quot;, tabs, member_type_buffer );
        fprintf( output, &amp;quot;\n%s}; // struct %s\n\n&amp;quot;, tabs, name_buffer );
    }

    copy( type.name, name_buffer, 256 );
    fprintf( output, &amp;quot;}; // namespace %s\n\n&amp;quot;, name_buffer );

}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;conclusions&#34;&gt;Conclusions&lt;/h1&gt;

&lt;p&gt;We learnt how to write a complete Code Generator, an incredible tool that can speed up the development if used correctly and remove most boilerplate code possible.&lt;/p&gt;

&lt;p&gt;The usage of the &lt;em&gt;command&lt;/em&gt; keyword was an example of something I use and I dont want to write code, something that is custom enough and hopefully will give you more ideas on how you can break free from languages constriction when you writeyour own language!&lt;/p&gt;

&lt;p&gt;In the quest for data-driven rendering, the next step will be to use the knowledge from code generation to create a &lt;em&gt;shader effect language&lt;/em&gt;, that can generate both CPU and GPU code for you.&lt;/p&gt;

&lt;p&gt;This article is the longest and more code-heavy I have ever written. There are many concepts that I am beginning to be familiar with, but still not so used to.&lt;/p&gt;

&lt;p&gt;So please comment, give feedback, share!
Thank you for reading!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Emulation: where to start? A use case.</title>
      <link>/post/emulation_where_to_start/</link>
      <pubDate>Sat, 27 Jul 2019 18:45:35 -0400</pubDate>
      
      <guid>/post/emulation_where_to_start/</guid>
      <description>







&lt;figure&gt;

  &lt;a data-fancybox=&#34;&#34; href=&#34;front.png&#34; &gt;

&lt;img src=&#34;front.png&#34; &gt;
&lt;/a&gt;


&lt;figcaption data-pre=&#34;Figure &#34; data-post=&#34;:&#34; &gt;
  &lt;h4&gt;Some of the UI for the Hydra NES emulator, using ImGUI.&lt;/h4&gt;
  
&lt;/figcaption&gt;

&lt;/figure&gt;


&lt;p&gt;Writing an emulator is an incredibly fun learning experience.&lt;/p&gt;

&lt;p&gt;It is an exquisite exercise in reverse-engineering from both documentation and code.&lt;/p&gt;

&lt;p&gt;In this post I want to share some tips on how and where to start based on my experience on the NES emulator I am writing.&lt;/p&gt;

&lt;h1 id=&#34;information&#34;&gt;Information&lt;/h1&gt;

&lt;p&gt;The gathering of information is the most important (and hard!) process that will live through all the writing process.&lt;/p&gt;

&lt;p&gt;Luckily for use there are many websites that are coming to rescue us:&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://wiki.nesdev.com/w/index.php/NES_reference_guide&#34; target=&#34;_blank&#34;&gt;https://wiki.nesdev.com/w/index.php/NES_reference_guide&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://forums.nesdev.com/&#34; target=&#34;_blank&#34;&gt;http://forums.nesdev.com/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://obelisk.me.uk/6502/reference.html&#34; target=&#34;_blank&#34;&gt;http://obelisk.me.uk/6502/reference.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.oxyron.de/html/opcodes02.html&#34; target=&#34;_blank&#34;&gt;http://www.oxyron.de/html/opcodes02.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;It is paramount to create a list of websites and resources (maybe through some notes, like in Evernote or such) about different topics regarding the hardware to be emulated.&lt;/p&gt;

&lt;p&gt;Having a central hub is powerful and counteract the sparseness of the different informations (some in txt files, different websites, forum blogposts, ).&lt;/p&gt;

&lt;p&gt;I cant stress enough how important it is.&lt;br&gt;
Luckily for us the amazing NesDev Wiki is the hub you need!&lt;br&gt;
Almost every possible information you need is there.&lt;/p&gt;

&lt;h1 id=&#34;architecture&#34;&gt;Architecture&lt;/h1&gt;

&lt;p&gt;Next step is to understand the architecture.&lt;br&gt;
Write diagrams, take notes, search for the relationships of the component.&lt;br&gt;
What does every hardware component do ?&lt;br&gt;
What can that specific hardware piece access to ?&lt;br&gt;&lt;/p&gt;

&lt;p&gt;As you will see, writing the emulator is an iterative process of improving each component until you have something that works very well, and then refine for an infinite amount of time.&lt;br&gt;
On a very basic level, there should be a CPU, some form of GPU (PPU, Picture Processing Unit), some audio chip, some input peripheral and cartridge/disc/rom.&lt;/p&gt;

&lt;h1 id=&#34;nes-architecture&#34;&gt;NES architecture&lt;/h1&gt;

&lt;p&gt;The NES is a beautiful machine equipped with the following:&lt;/p&gt;

&lt;h4 id=&#34;cpu-ricoh-rp2a03-ntsc-rp2a07-pal&#34;&gt;CPU : Ricoh RP2A03 (NTSC) / RP2A07 (PAL)&lt;/h4&gt;

&lt;p&gt;8 bit processor that contains both CPU and APU (audio) hardware. The addresses are 16 bit, but the data is 8.
It contains only specific registers: 2 indices, accumulator, stack pointer, program counter and status.&lt;/p&gt;

&lt;h4 id=&#34;ppu-ricoh-rp2c02-ntsc-rp2c07-pal&#34;&gt;PPU : Ricoh RP2C02 (NTSC) / RP2C07 (PAL)&lt;/h4&gt;

&lt;p&gt;This is what today would be called GPU.
It outputs to a 256x240 pixels buffer, it has 2kib or RAM, 32 bytes for palette RAM and 288 bytes for sprite RAM.
The PPU is tile based and it takes 8 PPU cycles to load a line of a background tile.
Sprites are sent through DMA and background is filled during Vertical Blank state normally.
A frame lasts more scanline that the one visible, so that the game can upload data to the PPU when not rendering.&lt;/p&gt;

&lt;h4 id=&#34;apu-ricoh-rp2a03-ntsc-rp2a07-pal-contained-in-the-cpu-itself&#34;&gt;APU : Ricoh RP2A03 (NTSC) / RP2A07 (PAL) (Contained in the CPU itself.)&lt;/h4&gt;

&lt;p&gt;The sound is analogic and it comes from 5 different channels: 2 pulse, 1 triangle, 1 noise and 1 DMC. All the channels aside from the DMC create signals that are combined to output the sounds and music.
The DMC loads samples using the DMA.&lt;/p&gt;

&lt;h4 id=&#34;cartridge-mappers&#34;&gt;Cartridge/Mappers :&lt;/h4&gt;

&lt;p&gt;This is a very unique topic strict to the NES as far as I know.
Cartridges had unique hardware and they were used to swap banks of memory in realtime to access different parts of the cartridge.
There are hundred of mappers that have unique behaviours!
The biggest gist of the mappers is how they switch banks: by WRITING to the address where the execution code is it triggers the bank-switching logic.
There can be internal batteries and working RAMs too, but they are very rare.&lt;/p&gt;

&lt;h4 id=&#34;memory-mapped-i-o&#34;&gt;Memory mapped I/O&lt;/h4&gt;

&lt;p&gt;The different hardware access using memory mapped I/O, that is a way of saying that when you read or write to a specific address it could be memory or it could be an hardware-component.&lt;/p&gt;

&lt;p&gt;Examples: reading from address &lt;strong&gt;0x4016&lt;/strong&gt; gives you the &lt;strong&gt;gamepad&lt;/strong&gt; status, while reading from &lt;strong&gt;0x1000&lt;/strong&gt; reads from the &lt;strong&gt;CPU ram&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Having clear these accesses will help in understanding even better the machine.&lt;/p&gt;

&lt;p&gt;Both CPU and PPU have different memory maps. Let&amp;rsquo;s see them, it will help in understanding the internal of the NES better.&lt;/p&gt;

&lt;h2 id=&#34;cpu-memory-map&#34;&gt;CPU Memory Map&lt;/h2&gt;







&lt;figure&gt;

  &lt;a data-fancybox=&#34;&#34; href=&#34;cpu_map.png&#34; &gt;

&lt;img src=&#34;cpu_map.png&#34; &gt;
&lt;/a&gt;

&lt;/figure&gt;


&lt;p&gt;The &lt;strong&gt;CPU&lt;/strong&gt; can access basically every hardware component in the NES.&lt;br&gt;
&lt;strong&gt;PPU, APU, gamepads&lt;/strong&gt;, both read and write.&lt;br&gt;&lt;/p&gt;

&lt;p&gt;It reads the &lt;strong&gt;ROM&lt;/strong&gt; part of a cartridge (called &lt;strong&gt;PRG&lt;/strong&gt;) and executes its instructions.&lt;br&gt;
Through &lt;strong&gt;PPU&lt;/strong&gt; registers it can instruct the &lt;strong&gt;PPU&lt;/strong&gt; to read graphical informations from the &lt;strong&gt;CHR&lt;/strong&gt; part of the cartridge.&lt;br&gt;
It can upload sprites on the &lt;strong&gt;PPU Sprite Memory&lt;/strong&gt; through &lt;strong&gt;DMA&lt;/strong&gt;, upload data to the &lt;strong&gt;APU&lt;/strong&gt;, or manage its internal RAM.&lt;/p&gt;

&lt;p&gt;From the source code, this is a working example of CPU Reading method:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;uint8 Nes::MemoryController::CpuRead( uint16 address ) {

    if ( address &amp;lt; 0x2000 ) {
        return cpu-&amp;gt;ram[address &amp;amp; 0x7FF];
    }
    else if ( address &amp;lt; 0x4000 ) {
        return ppu-&amp;gt;CpuRead( address );
    }
    else if ( address &amp;lt; 0x4014 ) {
        return apu-&amp;gt;CpuRead( address );
    }
    else if ( address &amp;gt;= 0x4018 ) {
        return mapper-&amp;gt;PrgRead( address );
    }

    switch ( address ) {
        case 0x4015: {
            return apu-&amp;gt;ReadStatus();
            break;
        }

        case 0x4016: {
            return controllers-&amp;gt;ReadState();
            break;
        }
                     
        case 0x4017: {
            return 0x40;
            break;
        }
    }

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And CPU Write:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;void Nes::MemoryController::CpuWrite( uint16 address, uint8 data ) {

    if ( address &amp;lt; 0x2000 ) {
        cpu-&amp;gt;ram[address &amp;amp; 0x7FF] = data;
    }
    else if ( address &amp;lt; 0x4000 ) {
        ppu-&amp;gt;CpuWrite( address, data );
        return;
    }
    else if ( address &amp;lt; 0x4014 ) {
        return apu-&amp;gt;CpuWrite( address, data );
    }
    else if ( address &amp;gt;= 0x4018 ) {
        mapper-&amp;gt;PrgWrite( address, data );
        return;
    }

    switch ( address ) {
        // Sprite DMA
        case 0x4014: {
            cpu-&amp;gt;ExecuteSpriteDMA( data );
            return;
            break;
        }

        case 0x4015:
        case 0x4017: {
            apu-&amp;gt;CpuWrite( address, data );
            return;
            break;
        }

        case 0x4016: {
            controllers-&amp;gt;WriteState( data );
            return;
            break;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The pattern is always the same: check the address of the instruction and choose which hardware component to interact with.&lt;/p&gt;

&lt;p&gt;Hopefully its clear that based on the address different components can be accessed.
Let&amp;rsquo;s have a look at the PPU too.&lt;/p&gt;

&lt;h2 id=&#34;ppu-memory-map&#34;&gt;PPU Memory Map&lt;/h2&gt;







&lt;figure&gt;

  &lt;a data-fancybox=&#34;&#34; href=&#34;ppu_map.png&#34; &gt;

&lt;img src=&#34;ppu_map.png&#34; &gt;
&lt;/a&gt;

&lt;/figure&gt;


&lt;p&gt;Similar to the &lt;strong&gt;CPU&lt;/strong&gt;, reading and writing on the &lt;strong&gt;PPU&lt;/strong&gt; access different components, even though they are far less.&lt;br&gt;
The &lt;strong&gt;PPU&lt;/strong&gt; either accesses its 2 rams (&lt;strong&gt;palette&lt;/strong&gt; and &lt;strong&gt;nametable&lt;/strong&gt;, normally from the &lt;strong&gt;CPU&lt;/strong&gt;) or reads the &lt;strong&gt;CHR&lt;/strong&gt; (that is the graphical data stored in the cartridge) memory.&lt;/p&gt;

&lt;p&gt;Reading:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;uint8 Nes::MemoryController::PpuRead( uint16 address ) {
    
    address &amp;amp;= 0X3FFF;

    if ( address &amp;lt;= 0x1FFF ) {
        return mapper-&amp;gt;ChrRead( address );
    }
    else if ( address &amp;lt;= 0x3EFF ) {
        return ppu-&amp;gt;nametableRam[NameTableMirroring( address, mapper-&amp;gt;mirroring )];
    }
    else if ( address &amp;lt;= 0x3FFF ) {
        // Palette mirroring is handled in the write code.
        return ppu-&amp;gt;paletteRam[address &amp;amp; 0x1F] &amp;amp; ((ppu-&amp;gt;mask &amp;amp; Nes::Ppu::MaskFlag_GreyScale ? 0x30 : 0xFF));
    }
    return 0;
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;On the writing side, there the code shows the intricancy of emulation.
When writing to the paletter ram, there is a mirroring mechanism happening in the hardware that is emulated with a lookup table.
Something to look out to: &lt;strong&gt;writing to CHR is 99% of the time useless, unless there is an additional RAM in the cartdige&lt;/strong&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;void Nes::MemoryController::PpuWrite( uint16 address, uint8 data ) {

    address &amp;amp;= 0X3FFF;

    if ( address &amp;lt;= 0x1FFF ) {
        mapper-&amp;gt;ChrWrite( address, data );
        return;
    }
    else if ( address &amp;lt;= 0x3EFF ) {
        ppu-&amp;gt;nametableRam[NameTableMirroring( address, mapper-&amp;gt;mirroring )] = data;
        return;
    }
    else if ( address &amp;lt;= 0x3FFF ) {

        static uint8 const palette_write_mirror[0x20] = { 
            0x10, 0x01, 0x02, 0x03, 0x14, 0x05, 0x06, 0x07,
            0x18, 0x09, 0x0A, 0x0B, 0x1C, 0x0D, 0x0E, 0x0F,
            0x00, 0x11, 0x12, 0x13, 0x04, 0x15, 0x16, 0x17,
            0x08, 0x19, 0x1A, 0x1B, 0x0C, 0x1D, 0x1E, 0x1F };

        ppu-&amp;gt;paletteRam[palette_write_mirror[address &amp;amp; 0x1F]] = data;
        return;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;takeaways&#34;&gt;Takeaways&lt;/h2&gt;

&lt;p&gt;I created the &lt;strong&gt;memory controller&lt;/strong&gt; as the main dispatcher of data between hardware components, to separate the duties better.
We can see the following relationships based on that:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;CPU can access PPU, APU, controllers and cartridge (PRG)&lt;/li&gt;
&lt;li&gt;PPU can access screen, its own rams and cartridge (CHR)&lt;/li&gt;
&lt;li&gt;memory controller is the hub that connects everything&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;I am not sure this is the best emulator architecture, but that is what I figured out.&lt;/p&gt;

&lt;h1 id=&#34;test-roms&#34;&gt;Test roms&lt;/h1&gt;

&lt;p&gt;A fundamental approach to create a robust emulator is to have some tests to rely on.&lt;br&gt;
Sadly it is not common for all hardware, but again the NES provide plenty of roms that tests almost every aspect of your emulator!&lt;br&gt;
It quickly becomes a test-driven development.&lt;br&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://wiki.nesdev.com/w/index.php/Emulator_tests&#34; target=&#34;_blank&#34;&gt;NES test roms link&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Find roms, read the source code and try to understand what they are doing and why.&lt;/p&gt;

&lt;h1 id=&#34;coding-start&#34;&gt;Coding start&lt;/h1&gt;

&lt;p&gt;If you are writing your first emulator, I suggest to focus mostly on the emulation part.&lt;/p&gt;

&lt;p&gt;What do I mean by that ?&lt;br&gt;
Avoid trying too many things at once!&lt;br&gt;
Focus your energies towards the emulation.&lt;br&gt;
Use libraries that are reliable and simple and that you know.&lt;br&gt;
GLFW, SDL2, etc are your friends here.&lt;br&gt;
You want to eliminate most unknowns unknowns before hand.&lt;br&gt;
Of course, if you are brave enough, you can also write an emulator in a new language.&lt;/p&gt;

&lt;p&gt;But for me, I preferred to concentrate on the emulation side first, in C++, using my core library, especially knowing that I could dedicate some night-time here and there,
No surprises (not really true, still some happened!).&lt;/p&gt;

&lt;p&gt;I will possibly port the emulator to use SDL if needed, but right now the emulation code is the most important.&lt;/p&gt;

&lt;p&gt;This is the mantra that helped me concentrate only on the emulation code. Again, writing-wise I am not happy about the code quality. But what I am learning from different perspectives is invaluable!&lt;/p&gt;

&lt;h1 id=&#34;nes-coding-start&#34;&gt;NES coding start&lt;/h1&gt;

&lt;p&gt;The quintessential basic steps to start a NES emulator coding are:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Write CPU basics (fetch/decode/execute loop, registers)&lt;/li&gt;
&lt;li&gt;Basic memory bus (read/write to/from memory and registers)&lt;/li&gt;
&lt;li&gt;Load a rom and start executing instruction step by step.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;It is already a lot, and it will require to read multiple times the different wiki pages and forum posts.&lt;/p&gt;

&lt;p&gt;For a typical console, the main loop (simplified) can be something like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;void CpuTick() {
    uint8_t opcode = Read(program_counter++);
    uint8_t operand = FetchOperand(opcode);
    ExecuteOpcode(opcode, operand);
}

void ExecuteFrame() {
    uint32_t cycles_per_frame = 
 
    while (cycles_per_frame  ) {
        CpuTick();
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To jumpstart your NES emulator you can use the majestic rom nestest.nes and its log file: it gives you a test of all instructions of the CPU and prints the status of the CPU after each one.&lt;/p&gt;

&lt;p&gt;Also it does not require any PPU rendering: compare the status of your CPU with the text file line by line and its done!&lt;/p&gt;

&lt;p&gt;You can see some ugly but useful code in &lt;a href=&#34;https://github.com/JorenJoestar/HydraNes/blob/68d705ef400c1ab930dce0fa51c5353aa8b32396/src/main.cpp#L607&#34; target=&#34;_blank&#34;&gt;MainState::ExecuteCpuTest&lt;/a&gt; in my emulator for an idea.&lt;/p&gt;

&lt;p&gt;A line from the nestest.log file looks like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// C000 4C F5 C5 JMP $C5F5 A:00 X:00 Y:00 P:24 SP:FD PPU: 0, 0 CYC:7
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;it gives you the ProgramCounter (C000), byte code (1, 2 or 3 bytes depending on the instructions), human-readable-instruction (JMP) , the CPU register contents (A, X, Y, P, SP) and the theorethical PPU scanline, pixel and clock cycle.&lt;/p&gt;

&lt;p&gt;There are two interesting points:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;The ProgramCounter before execution should be set to C000 for this rom only and only when logging.&lt;/li&gt;
&lt;li&gt;The CPU cycles STARTS at 7. In a power-up/reset method there is some work done BEFORE executing any code. This is needed only if you want to have a precise cycle-to-cycle comparison.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;You can create a simple test method like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;void TestEmulatorCPU() {
    Reset();
 
    while(true) {
        CpuTick();
        CompareCpuStatusWithLog();
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and catch the problems in your CPU instructions implementation!&lt;/p&gt;

&lt;h1 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h1&gt;

&lt;p&gt;This is a little help in understanding how to start with an emulator.&lt;/p&gt;

&lt;p&gt;It is a beautiful journey, but it is full of trial and errors.&lt;/p&gt;

&lt;p&gt;I am myself far from over with my emulator, and also far from being happy on HOW I write the emulator itself.&lt;/p&gt;

&lt;p&gt;There are emulators of much more complex machines out there (almost every machine you can imagine!) and it blows my mind to know there are people that can emulate such complex hardware.&lt;/p&gt;

&lt;p&gt;The ideal situation would be to being able of not being lost in visual emulation of the circuitry, but for now that is out of my league.&lt;/p&gt;

&lt;p&gt;I am thinking of creating some a series of videos and code associated starting from scratch, if anyone is interested.
Please leave a comment/feedback on the article, the source code, anything!&lt;/p&gt;

&lt;p&gt;I hope it will help.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Flatbuffers, Reflection and Data-Driven Rendering</title>
      <link>/post/flatbuffers_reflection_data_driven_rendering/</link>
      <pubDate>Fri, 26 Jul 2019 07:37:26 -0400</pubDate>
      
      <guid>/post/flatbuffers_reflection_data_driven_rendering/</guid>
      <description>







&lt;figure&gt;

  &lt;a data-fancybox=&#34;&#34; href=&#34;front.png&#34; &gt;

&lt;img src=&#34;front.png&#34; &gt;
&lt;/a&gt;


&lt;figcaption data-pre=&#34;Figure &#34; data-post=&#34;:&#34; &gt;
  &lt;h4&gt;Auto generated UI from Flatbuffers files.&lt;/h4&gt;
  
&lt;/figcaption&gt;

&lt;/figure&gt;


&lt;h1 id=&#34;motivation&#34;&gt;Motivation&lt;/h1&gt;

&lt;p&gt;Finding a good balance between code and data in Rendering.&lt;br&gt;
What is the necessary code that should be written ?&lt;br&gt;
Why ?&lt;br&gt;&lt;/p&gt;

&lt;p&gt;In rendering many areas can be described in a fast and robust way using data.&lt;br&gt;
A &lt;em&gt;pipeline (in D3D12/Vulkan lingo)&lt;/em&gt; for example is a collection of different states: &lt;em&gt;depth stencil, alpha blend, rasterizer, shaders&lt;/em&gt;, etc.&lt;br&gt;
All those state can be &lt;em&gt;hard-coded&lt;/em&gt; or defined in &lt;em&gt;data&lt;/em&gt;.&lt;br&gt;
Moving them to data can help with the visibility of them, that instead of being buried somewhere into the code can be retrieved before even running the application.&lt;/p&gt;

&lt;p&gt;As a bigger-scope example, a &lt;em&gt;frame-graph&lt;/em&gt; can be implicitly defined inside the code, if different areas, or in data.&lt;br&gt;
Recent posts about it started raising attention to the problem, especially after the introduction of lower-level APIs like D3D12 and Vulkan and their resource barriers.&lt;br&gt;
Ive personally used something like &lt;em&gt;json&lt;/em&gt; (xml back in the day) since 2009, after asking myself the very silly question:&lt;br&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;what is the biggest dependency in rendering?&lt;br&gt;Render Targets!&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Since then I saw only in the Codemasters postprocess system (since Dirt 2) a similar approach, and have never being able to advocate towards it.&lt;br&gt;
The only full use case I have is my personal indie game (a full deferred rendering pipeline with many different rendering needs) all defined in a json file (render_pipeline.json).&lt;br&gt;
Anyway, a couple of examples of this data-driven mentality can be found here:&lt;/p&gt;

&lt;p&gt;&lt;iframe src=&#34;//www.slideshare.net/slideshow/embed_code/key/CfeEFT3zVraiZO&#34; width=&#34;595&#34; height=&#34;485&#34; frameborder=&#34;0&#34; marginwidth=&#34;0&#34; marginheight=&#34;0&#34; scrolling=&#34;no&#34; style=&#34;border:1px solid #CCC; border-width:1px; margin-bottom:5px; max-width: 100%;&#34; allowfullscreen&gt; &lt;/iframe&gt; &lt;div style=&#34;margin-bottom:5px&#34;&gt; &lt;strong&gt; &lt;a href=&#34;//www.slideshare.net/DICEStudio/framegraph-extensible-rendering-architecture-in-frostbite&#34; title=&#34;FrameGraph: Extensible Rendering Architecture in Frostbite&#34; target=&#34;_blank&#34;&gt;FrameGraph: Extensible Rendering Architecture in Frostbite&lt;/a&gt; &lt;/strong&gt; from &lt;strong&gt;&lt;a href=&#34;https://www.slideshare.net/DICEStudio&#34; target=&#34;_blank&#34;&gt;Electronic Arts / DICE&lt;/a&gt;&lt;/strong&gt; &lt;/div&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://bitsquid.blogspot.com/2017/03/stingray-renderer-walkthrough-7-data.html&#34; target=&#34;_blank&#34;&gt;http://bitsquid.blogspot.com/2017/03/stingray-renderer-walkthrough-7-data.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;I chose to see what is a good way of &lt;em&gt;describing low-level rendering resources, the bricks towards data-driven rendering&lt;/em&gt;.&lt;br&gt;
Ive already tried defining them in a json file, but wanted something more direct  something I can copy easily with minimal parsing.&lt;/p&gt;

&lt;p&gt;I found 4 possible approaches:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Custom data language&lt;/li&gt;
&lt;li&gt;Already existing data language&lt;/li&gt;
&lt;li&gt;Json (already used)&lt;/li&gt;
&lt;li&gt;Hard-coding everything&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;In this experiment Ive chosen &lt;strong&gt;Flatbuffers&lt;/strong&gt; for the easy of use, the good performances and the feature set that seems complete.&lt;br&gt;
As an exercise, I wanted to create some UI based on the data coming from Flatbuffers without having to write too much code.&lt;/p&gt;

&lt;h1 id=&#34;flatbuffers&#34;&gt;Flatbuffers&lt;/h1&gt;

&lt;p&gt;Flatbuffers is a serialization library developer by Google used by many companies.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://google.github.io/flatbuffers/&#34; target=&#34;_blank&#34;&gt;https://google.github.io/flatbuffers/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Compared to &lt;strong&gt;Protocol Buffers&lt;/strong&gt; (still developed by Google) it tries to go towards a very simple parsing/unpacking (actually ABSENT in Flatbuffers, so much faster to read/write) and serialization speed.&lt;/p&gt;

&lt;p&gt;Flatbuffers is mainly a compiler that accepts .fbs (FlatBuffers Schema) files and can generate code for serialization purposes.&lt;/p&gt;

&lt;p&gt;The advantage is that it automatically generates the parsing files in the language you prefer (C++, Java, C#, Go, C, Lua, Javascript, Rust) without you needing to write the always tedious serialize/deserialize methods.&lt;/p&gt;

&lt;p&gt;It is largely based on either simple c-structs or tables with offsets for more complex object.&lt;/p&gt;

&lt;p&gt;The objective here will be to create a schema file, define a couple of resources (like textures) and use those to automatically generate UI.&lt;br&gt;
I will be using the SDL + ImGUI sample from the amazing ImGUI as a base.&lt;br&gt;&lt;/p&gt;

&lt;p&gt;The flow will be the following:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Write schema files&lt;/li&gt;
&lt;li&gt;Generate reflection informations&lt;/li&gt;
&lt;li&gt;Parse schemas&lt;/li&gt;
&lt;li&gt;Generate UI&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&#34;schema-files&#34;&gt;Schema Files&lt;/h1&gt;

&lt;p&gt;Lets write our first schema file.
A bigger version (that I am using for my low-level renderer) is included in the &lt;a href=&#34;https://github.com/JorenJoestar/FlatbuffersReflection&#34; target=&#34;_blank&#34;&gt;github&lt;/a&gt; repository.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;namespace rendering;

enum TextureFormat : ushort { UNKNOWN, R32G32B32A32_TYPELESS, R32G32B32A32_FLOAT, R32G32B32A32_UINT, R32G32B32A32_SINT, R32G32B32_TYPELESS, R32G32B32_FLOAT, R32G32B32_UINT, R32G32B32_SINT, R16G16B16A16_TYPELESS, R16G16B16A16_FLOAT, R16G16B16A16_UNORM, R16G16B16A16_UINT, R16G16B16A16_SNORM, R16G16B16A16_SINT, R32G32_TYPELESS, R32G32_FLOAT, R32G32_UINT, R32G32_SINT, R10G10B10A2_TYPELESS, R10G10B10A2_UNORM, R10G10B10A2_UINT, R11G11B10_FLOAT, R8G8B8A8_TYPELESS, R8G8B8A8_UNORM, R8G8B8A8_UNORM_SRGB, R8G8B8A8_UINT, R8G8B8A8_SNORM, R8G8B8A8_SINT, R16G16_TYPELESS, R16G16_FLOAT, R16G16_UNORM, R16G16_UINT, R16G16_SNORM, R16G16_SINT, R32_TYPELESS, R32_FLOAT, R32_UINT, R32_SINT, R8G8_TYPELESS, R8G8_UNORM, R8G8_UINT, R8G8_SNORM, R8G8_SINT, R16_TYPELESS, R16_FLOAT, R16_UNORM, R16_UINT, R16_SNORM, R16_SINT, R8_TYPELESS, R8_UNORM, R8_UINT, R8_SNORM, R8_SINT, R9G9B9E5_SHAREDEXP, D32_FLOAT_S8X24_UINT, D32_FLOAT, D24_UNORM_S8_UINT, D24_UNORM_X8_UINT, D16_UNORM, S8_UINT, BC1_TYPELESS, BC1_UNORM, BC1_UNORM_SRGB, BC2_TYPELESS, BC2_UNORM, BC2_UNORM_SRGB, BC3_TYPELESS, BC3_UNORM, BC3_UNORM_SRGB, BC4_TYPELESS, BC4_UNORM, BC4_SNORM, BC5_TYPELESS, BC5_UNORM, BC5_SNORM, B5G6R5_UNORM, B5G5R5A1_UNORM, B8G8R8A8_UNORM, B8G8R8X8_UNORM, R10G10B10_XR_BIAS_A2_UNORM, B8G8R8A8_TYPELESS, B8G8R8A8_UNORM_SRGB, B8G8R8X8_TYPELESS, B8G8R8X8_UNORM_SRGB, BC6H_TYPELESS, BC6H_UF16, BC6H_SF16, BC7_TYPELESS, BC7_UNORM, BC7_UNORM_SRGB, FORCE_UINT }

attribute &amp;quot;ui&amp;quot;;

struct RenderTarget {
    width                   : ushort (ui: &amp;quot;min:1, max:16384&amp;quot;);
    height                  : ushort;
    scale_x                 : float;
    scale_y                 : float;
    format                  : TextureFormat;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There are few things here to discuss.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Enums. Flatbuffers can generate enums with string version of each values and conversions between enum and string.&lt;/li&gt;
&lt;li&gt;Struct. It is exactly like C/C++: a simple struct that can be memcopied. Different than a Table (that can point to other structs and Tables).&lt;/li&gt;
&lt;li&gt;Attributes. This can be used to define custom parsable attributes linked to a member of a struct/table. They can be used, for example, to drive the UI generation.&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&#34;generating-reflection-informations&#34;&gt;Generating Reflection Informations&lt;/h1&gt;

&lt;p&gt;After we generated the schema file, we can serialize it and load/save it from disk.
But we need reflection data to be able to automatically generate the UI we need!
There are two main reflection mechanisms in Flatbuffers: mini-reflection and full-reflection.
We will use both to generate a UI using ImGUI and see the differences.&lt;/p&gt;

&lt;h2 id=&#34;mini-reflection&#34;&gt;Mini-Reflection&lt;/h2&gt;

&lt;p&gt;This is the simplest of the two and works by generating an additional header file for each .fbs file we use.
The command line is the following:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;flatc --cpp RenderDefinitions.fbs --reflect-names
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This will generate the &lt;em&gt;RenderDefinitions_Generated.h&lt;/em&gt; file that must be included in your application and has the downside of needing you to recompile every time you change the data.&lt;/p&gt;

&lt;p&gt;Also, and this is the biggest downside, I could not find any way to parse custom per-member attributes.&lt;/p&gt;

&lt;p&gt;I hope I am wrong, but could not find any documentation on the topic: everything seems to point towards the full reflection mechanism.&lt;/p&gt;

&lt;p&gt;So why bothering with the &lt;strong&gt;mini-reflection&lt;/strong&gt; ?&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Mini-reflection&lt;/strong&gt; generates code, and this became useful for one of the most tedious C/C++ code to write: &lt;strong&gt;enums&lt;/strong&gt;!&lt;/p&gt;

&lt;p&gt;I cant count how many times I wrote an enum, I wanted the string with the same value for it (for example to read from a json file and get the proper enum value) and every time an enum is changed is painful.&lt;/p&gt;

&lt;p&gt;So a lesson from the mini-reflection is to have a code-generator for enums for C/C++, and I will show an example soon in another article.&lt;/p&gt;

&lt;p&gt;Back to the enums, Flatbuffers generates:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Enum&lt;/li&gt;
&lt;li&gt;Name array&lt;/li&gt;
&lt;li&gt;Value array&lt;/li&gt;
&lt;li&gt;Enum to name method&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;A nice property of the generated code for the enum is that it is easy to copy-paste in any c++ file  no Flatbuffers involved!&lt;/p&gt;

&lt;p&gt;This is my first choice now when I want to write an enum in any c++ application.&lt;/p&gt;

&lt;h2 id=&#34;full-reflection&#34;&gt;Full-reflection&lt;/h2&gt;

&lt;p&gt;This is the most used (or at least documented) form of reflection in Flatbuffers.&lt;/p&gt;

&lt;p&gt;It use a very elegant solution, totally data-driven: &lt;em&gt;it reads a reflection schema file that can parseANY other schema&lt;/em&gt;!&lt;/p&gt;

&lt;p&gt;This very Inception-esque mechanism gives the full access to all the types, including Attributes.&lt;/p&gt;

&lt;p&gt;By executing this command:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;flatc.exe -b --schema reflection.fbs RenderDefinitions.fbs
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;the RenderDefinitions.bfbs (binary fbs) file is generated.&lt;/p&gt;

&lt;p&gt;This is the file that needs to be read to fully reflect the types inside the .fbs file.
The order of operations is the following:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Generate a binary fbs with flatc (with the command line shown)&lt;/li&gt;
&lt;li&gt;Load the bfbs file generated&lt;/li&gt;
&lt;li&gt;Load the schema from the bfbs&lt;/li&gt;
&lt;li&gt;Reflect&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;The fbfs file contains all the informations from the schema: types, enums, attributes.&lt;/p&gt;

&lt;h1 id=&#34;parsing-schemas-and-generating-ui&#34;&gt;Parsing schemas and Generating UI&lt;/h1&gt;

&lt;p&gt;For both reflection mechanisms the objective is the same: given a type (RenderTarget) generate an editor that can edit properties and potentially load/save them.&lt;/p&gt;

&lt;h2 id=&#34;mini-reflection-1&#34;&gt;Mini-Reflection&lt;/h2&gt;

&lt;p&gt;The UI generation is pretty straightforward with mini-reflection.&lt;/p&gt;

&lt;p&gt;Each type defined in the .fbs file contains a type_name-TypeTable() method that gives accent to a TypeTable.&lt;/p&gt;

&lt;p&gt;This contains a list of per-member type, name and default values.&lt;/p&gt;

&lt;p&gt;What is really missing here is the attributes, that could be used to generate custom UI in a more specific way (eg. adding a min/max/step to a slider).&lt;/p&gt;

&lt;p&gt;The code doing this is in the github sample.&lt;/p&gt;

&lt;p&gt;There are few interesting points here.&lt;/p&gt;

&lt;h3 id=&#34;imgui-usability&#34;&gt;ImGui usability&lt;/h3&gt;

&lt;p&gt;In order to use ImGui to modify a struct, I had to create the class FlatBuffersReflectionTable to instantiate a struct with a similar layout than the Flatbuffers struct.&lt;/p&gt;

&lt;p&gt;This is annoying but I could not find a way around different than this.&lt;/p&gt;

&lt;p&gt;With this in-place, a ImGUI slider can point to a memory area that can be used to save/load the data.
Lets begin by retrieving the TypeTable:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;const TypeTable* rt_table = rendering::RenderTargetTypeTable();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The TypeTable is what is included in the generated header and contains the reflection informations.
Listing the members and their type is pretty straight-forward:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;for ( uint32_t i = 0; i &amp;lt; type_table.num_elems; ++i ) {
    const flatbuffers::TypeCode&amp;amp; type_code = type_table.type_codes[i];
    ImGui::Text( &amp;quot;%s: %s&amp;quot;, type_table.names[i], flatbuffers::ElementaryTypeNames()[type_code.base_type] );
    sprintf_s( s_string_buffer, 128, &amp;quot;%s&amp;quot;, type_table.names[i] );
    
    if ( type_code.sequence_ref == 0 ) {
        if ( type_table.type_refs[type_code.sequence_ref] ) {
            const flatbuffers::TypeTable* enum_type = type_table.type_refs[type_code.sequence_ref]();
             ImGui::Combo( s_string_buffer, (int32_t*)reflection_table.GetData( i ), enum_type-&amp;gt;names, enum_type-&amp;gt;num_elems );
        }
    }
    else {
        switch ( type_code.base_type ) {
             case flatbuffers::ET_BOOL:
            {
                ImGui::Checkbox( s_string_buffer, (bool*)reflection_table.GetData( i ) );
                break;
            }
         }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The interesting parts:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;flatbuffers::TypeCode&lt;/strong&gt;* contains the reflection information for a type.&lt;/p&gt;

&lt;p&gt;Given a &lt;strong&gt;type_code&lt;/strong&gt;, &lt;strong&gt;sequence_ref&lt;/strong&gt; can be used to check if it is an enum, pointer, or primitive type. In this case is used for enum, showing a combo with all the selectable values.&lt;/p&gt;

&lt;p&gt;Base_type contains instead the primitive type. In this example a bool can be mapped to a checkbox. This uses the custom reflection_table class to have a memory area for ImGUI.&lt;/p&gt;

&lt;p&gt;For mini-reflection this is basically it.&lt;/p&gt;

&lt;h2 id=&#34;full-reflection-1&#34;&gt;Full-reflection&lt;/h2&gt;

&lt;p&gt;Code here is longer but it follows the 4 steps highlighted before.&lt;/p&gt;

&lt;p&gt;All the code is inside the ReflectUIFull method.&lt;/p&gt;

&lt;p&gt;Here the binary fbs file and its corresponding schema are loaded.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// 1. Obtain the schema from the binary fbs generated
std::string bfbsfile;    
flatbuffers::LoadFile(&amp;quot;..\\data\\RenderDefinitions.bfbs&amp;quot;, true, &amp;amp;bfbsfile );     
const reflection::Schema&amp;amp; schema = *reflection::GetSchema( bfbsfile.c_str() );
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The schema can be used to list the types:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// 2. List all the types present in the fbs.    
auto types = schema.objects();    
for ( size_t i = 0; i &amp;lt; types-&amp;gt;Length(); i++ ) {        
   const reflection::Object* type = types-&amp;gt;Get( i );
   ImGui::Text( &amp;quot;    %s&amp;quot;, type-&amp;gt;name()-&amp;gt;c_str() );    
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(Using the auto here because I am lazy. The type is some multiple templates of offsets)
We can also list all the enums:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;auto enums = schema.enums();    
for ( size_t i = 0; i &amp;lt; enums-&amp;gt;Length(); i++ ) {        
    const reflection::Enum* enum_ = enums-&amp;gt;Get( i );
    ImGui::Text( &amp;quot;    %s&amp;quot;, enum_-&amp;gt;name()-&amp;gt;c_str() );    
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A problem I found (with a workaround in the code) is that enums do not have an easily to access array of string values.&lt;/p&gt;

&lt;p&gt;So I generated one for the sake of example, but I am far from happy with the solution!&lt;/p&gt;

&lt;p&gt;Going forward, we can get the type we want to reflect (notice the full namespace.type):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;auto render_target_type = types-&amp;gt;LookupByKey( &amp;quot;rendering.RenderTarget&amp;quot; );
and begin the work on each field:
auto fields = render_target_type-&amp;gt;fields();    
if ( fields ) {
    // 5.1. List all the fields        
    for ( size_t i = 0; i &amp;lt; fields-&amp;gt;Length(); i++ ) {
            auto field = fields-&amp;gt;Get( i );
            ...

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and the UI can be generated.&lt;/p&gt;

&lt;p&gt;For each field, the primitive type can be accessed with the following:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;reflection::BaseType field_base_type = field-&amp;gt;type()-&amp;gt;base_type();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and again, I found a workaround to know if a type is primitive or an enum.&lt;/p&gt;

&lt;p&gt;Last piece of the puzzle: attributes!&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;auto field_attributes = field-&amp;gt;attributes();
if ( field_attributes ) {
    auto ui = field_attributes-&amp;gt;LookupByKey( &amp;quot;ui&amp;quot; );
    if ( ui ) {
      ImGui::Text(&amp;quot;UI attribute: %s&amp;quot;, ui-&amp;gt;value()-&amp;gt;c_str());
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;These can be parsed as strings and can be used to drive UI code (like a slider with min, max and steps).&lt;/p&gt;

&lt;h1 id=&#34;conclusions&#34;&gt;Conclusions&lt;/h1&gt;

&lt;p&gt;In the end, Ive managed to generate UI based on a type without too much code.&lt;/p&gt;

&lt;p&gt;There was some reverse-engineering to do because I could not find proper documentation (I possibly miss some links to a in-depth example of reflection!) but nothing major.&lt;/p&gt;

&lt;p&gt;The full source code:&lt;/p&gt;

&lt;p&gt;(&lt;a href=&#34;https://github.com/JorenJoestar/FlatbuffersReflection&#34; target=&#34;_blank&#34;&gt;https://github.com/JorenJoestar/FlatbuffersReflection&lt;/a&gt;)&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Releasing NES Emulator Source</title>
      <link>/post/releasing_nes_emulator_source/</link>
      <pubDate>Tue, 23 Jul 2019 02:04:50 -0400</pubDate>
      
      <guid>/post/releasing_nes_emulator_source/</guid>
      <description>







&lt;figure&gt;

  &lt;a data-fancybox=&#34;&#34; href=&#34;ZeldaNESEmulated.png&#34; &gt;

&lt;img src=&#34;ZeldaNESEmulated.png&#34; &gt;
&lt;/a&gt;


&lt;figcaption data-pre=&#34;Figure &#34; data-post=&#34;:&#34; &gt;
  &lt;h4&gt;Legend of Zelda emulated plus debugging windows.&lt;/h4&gt;
  
&lt;/figcaption&gt;

&lt;/figure&gt;


&lt;p&gt;Hello everyone!&lt;/p&gt;

&lt;p&gt;Today I release the source code of my bare-bone NES emulator, written in C++.&lt;/p&gt;

&lt;p&gt;I had the idea to write an emulator of one of my favorite console (after the SNES) years ago, and started in 2015 to write the first code (actually in 2008, but it was too daunting even to start).
Then I concentrated on my other big project (still ongoing) and left all the NES code on a side.
Years passed and finally last winter I decided to give it a go to arrive at a usable emulator level and release the source code.&lt;/p&gt;

&lt;p&gt;Here it is!
(&lt;a href=&#34;https://github.com/JorenJoestar/HydraNes&#34; target=&#34;_blank&#34;&gt;https://github.com/JorenJoestar/HydraNes&lt;/a&gt;)&lt;/p&gt;

&lt;h2 id=&#34;motivation&#34;&gt;Motivation&lt;/h2&gt;

&lt;p&gt;Main motivation both to write and to share this code is &lt;em&gt;knowledge&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;I shamelessly wrote bad code just with the purpose of seeing something on screen as fast as I could.
And I am very honest about that: not happy for the form, but happy for the knowledge I gained!
Also, I think that this code is compact enough to be followed and to understand the basics of NES emulation coding.&lt;/p&gt;

&lt;h2 id=&#34;the-code&#34;&gt;The code&lt;/h2&gt;

&lt;p&gt;The &lt;strong&gt;NES code&lt;/strong&gt; lives in the Nes.h/.cpp pair of files.
The &lt;strong&gt;APU&lt;/strong&gt; is implemented using &lt;strong&gt;Blarggs implementation&lt;/strong&gt;: when Ill have other time I will attemp to finish my own implementation, but for now it is ok like that.&lt;/p&gt;

&lt;p&gt;The flow is the following:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;NES is initialized&lt;/li&gt;
&lt;li&gt;After loading a rom (from the Cartridge window) the mapper will be selected and memory copied to local buffers.&lt;/li&gt;
&lt;li&gt;CPU starts its continuous emulation.&lt;/li&gt;
&lt;li&gt;CPU will execute until a frame is produced. This is checked by the PPU frame changing.&lt;/li&gt;
&lt;li&gt;PPU execution is bound to memory accesses, both read and write.&lt;/li&gt;
&lt;li&gt;Each CPU memory access corresponds to 3 PPU cycles (in NTSC, the only region emulated).&lt;/li&gt;
&lt;li&gt;After the frame is ended the APU emulation is advanced.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;interesting-spots&#34;&gt;Interesting spots&lt;/h2&gt;

&lt;p&gt;There are different areas of the code that are interesting, but I would like to highlight some.&lt;/p&gt;

&lt;h3 id=&#34;cpu-step&#34;&gt;Cpu::Step()&lt;/h3&gt;

&lt;p&gt;This is where all the &lt;strong&gt;CPU&lt;/strong&gt; instructions are executed. I opted for a macro based approach instead of tables of function pointers.&lt;/p&gt;

&lt;p&gt;For each cpu cycle:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Fetch the instruction opcode&lt;/li&gt;
&lt;li&gt;Calculate the operand address (called effectiveAddress)&lt;/li&gt;
&lt;li&gt;Execute the operation&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;All the operations and addressing modes are in the Nes.h file.
&lt;em&gt;Addressing modes&lt;/em&gt; are the way the NES gets its operand for each operation.
Operations are the instruction themselves  using those operands.&lt;/p&gt;

&lt;h3 id=&#34;ppu-step&#34;&gt;Ppu::Step()&lt;/h3&gt;

&lt;p&gt;PPU by itself is the most difficult part to emulate (APU is easier on the channels, but harder on the mix and signal generation!).&lt;/p&gt;

&lt;p&gt;I will make a post about that soon, but in the meantime here the code is and implements the behaviours described here:&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://wiki.nesdev.com/w/index.php/File:Ntsc_timing.png&#34; target=&#34;_blank&#34;&gt;https://wiki.nesdev.com/w/index.php/File:Ntsc_timing.png&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;The &lt;strong&gt;PPU&lt;/strong&gt; draws in tiles of &lt;strong&gt;8x8 pixels&lt;/strong&gt;, so for each pixels created on the screen there will be a gathering of all the data necessary to calculate the final color.&lt;/p&gt;

&lt;p&gt;The rendering is divided in &lt;strong&gt;background&lt;/strong&gt; and &lt;strong&gt;sprites&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Background is just &lt;strong&gt;8x8 pixel per tile&lt;/strong&gt; choosen from the &lt;strong&gt;nametable&lt;/strong&gt; (a screen table of which tiles are visible) and &lt;strong&gt;sprites&lt;/strong&gt; are either 8x8 or 8x16 rectangles coming from a different memory area (uploaded using &lt;strong&gt;DMA&lt;/strong&gt;).&lt;/p&gt;

&lt;p&gt;There are many quirks and uniqueness about the &lt;strong&gt;PPU&lt;/strong&gt;, like the &lt;strong&gt;pattern table&lt;/strong&gt; (a 16x16 grid storing the higher 2 bits of all the underlying background pixels), or the vertical blank period, or the open bus.&lt;/p&gt;

&lt;h3 id=&#34;ppu-drawpixel&#34;&gt;Ppu::DrawPixel()&lt;/h3&gt;

&lt;p&gt;The color of a pixel comes from one of the 16 entries of the &lt;strong&gt;palette VRAM&lt;/strong&gt;, and to do so 4 bits must be calculated for background and for sprites.&lt;/p&gt;

&lt;p&gt;For background tiles, 2 pixels comes from the texture (&lt;strong&gt;CHR-ROM&lt;/strong&gt;) and 2 from the attribute table.
&lt;/br&gt;Sprites contains all those informations together.&lt;/p&gt;

&lt;p&gt;The output is a silly &lt;em&gt;SSBO&lt;/em&gt; that contains RGBA colors to be used in a compute shader that outputs to the screen.&lt;/p&gt;

&lt;h3 id=&#34;cpuread-write-ppuread-write&#34;&gt;CpuRead/Write, PpuRead/Write&lt;/h3&gt;

&lt;p&gt;All those methods are essential because the NES uses memory mapping i/o to access the different hardware.&lt;/p&gt;

&lt;p&gt;For example the &lt;strong&gt;PPU&lt;/strong&gt; access the cartridge through the mapper in the memory controller to read drawing informations, the &lt;strong&gt;CPU&lt;/strong&gt; writes to the &lt;strong&gt;PPU&lt;/strong&gt; using address $2007, etc.&lt;/p&gt;

&lt;h2 id=&#34;ending-notes&#34;&gt;Ending notes&lt;/h2&gt;

&lt;p&gt;I will prepare more detailed posts about the &lt;strong&gt;NES architecture and emulation&lt;/strong&gt;, even though there are still some concepts that are not clear to me and require a deeper investigation.&lt;/p&gt;

&lt;p&gt;So far this is the most &lt;em&gt;satisfactory&lt;/em&gt; personal project Ive done, and one of the few that arrived at a usable level.&lt;/p&gt;

&lt;p&gt;In the future I want to improve this emulator and use the knowledge to explore the writing of a SNES emulator!&lt;/p&gt;

&lt;p&gt;Any question or comment please let me know!&lt;/p&gt;

&lt;p&gt;Gabriel&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
