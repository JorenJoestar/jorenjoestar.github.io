<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>shaders on Gabriel&#39;s Virtual Tavern</title>
    <link>https://jorenjoestar.github.io/tags/shaders/</link>
    <description>Recent content in shaders on Gabriel&#39;s Virtual Tavern</description>
    <generator>Source Themes Academic (https://sourcethemes.com/academic/)</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 16 Mar 2020 12:11:37 -0400</lastBuildDate>
    
	    <atom:link href="https://jorenjoestar.github.io/tags/shaders/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Augmenting shader languages for modern rendering APIs</title>
      <link>https://jorenjoestar.github.io/post/shader_augment_for_pipelines/shader_augment_for_pipelines/</link>
      <pubDate>Mon, 16 Mar 2020 12:11:37 -0400</pubDate>
      
      <guid>https://jorenjoestar.github.io/post/shader_augment_for_pipelines/shader_augment_for_pipelines/</guid>
      <description>&lt;h1 id=&#34;overview&#34;&gt;Overview&lt;/h1&gt;
&lt;p&gt;In the last articles we looked at progressively building tools to move rendering code towards data.&lt;!-- raw HTML omitted --&gt;
We looked on how to create a simple &lt;strong&gt;lexer&lt;/strong&gt;, a simple &lt;strong&gt;parser&lt;/strong&gt; and a &lt;strong&gt;code generator&lt;/strong&gt;.&lt;!-- raw HTML omitted --&gt;
With those we were able to create a very simple language to &lt;strong&gt;augment&lt;/strong&gt; shaders.&lt;/p&gt;
&lt;p&gt;Why that ?&lt;/p&gt;
&lt;p&gt;There are few reasons:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Shader languages misses any way of linking multiple programs&lt;/li&gt;
&lt;li&gt;Shader languages misses any way to define render states&lt;/li&gt;
&lt;li&gt;CGFX and Microsoft FX are mostly dead&lt;/li&gt;
&lt;li&gt;Ability to use ANY shader language - and just add the infrastructure&lt;/li&gt;
&lt;li&gt;Ability to generate permutations without manually creating them&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Hydra FX aims to add all the missing features and becoming just an augmentation to ANY shader language.&lt;/p&gt;
&lt;p&gt;There is also a fundamental reason for me:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Define all the rendering informations needed as soon as possible!&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;With this reason then defining everything inside an HFX file, with the possibility of overriding some properties, it is paramount.&lt;/p&gt;
&lt;p&gt;This is by far a new concept, and with the newer Graphics APIs (Vulkan and D3D12) it is becoming more and more of a need.&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;p&gt;In this article we will see how we have all those features and add the missing ones. I will try to define everything in a more API-Independent way, so it can be adapted to any engine needs.&lt;/p&gt;
&lt;h1 id=&#34;why-we-need-shader-augmentation&#34;&gt;Why we need shader augmentation&lt;/h1&gt;
&lt;p&gt;The augmentation that I have in mind is needed for different reasons, not only if you are targeting the newer APIs.&lt;!-- raw HTML omitted --&gt;
Some of the reasons are the following:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Write the NECESSARY code. Nothing more.&lt;/li&gt;
&lt;li&gt;Logically group shaders in the same file.&lt;/li&gt;
&lt;li&gt;Describe a priori all the STATIC parts of rendering.&lt;/li&gt;
&lt;li&gt;Being more data driven, improve iteration time.&lt;/li&gt;
&lt;li&gt;Being more data driven, encourage rendering experimentation.&lt;/li&gt;
&lt;li&gt;Easiness of debugging.&lt;/li&gt;
&lt;li&gt;Encourages less hardcoded data.&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;write-the-necessary-code-nothing-more&#34;&gt;Write the NECESSARY code. Nothing more.&lt;/h2&gt;
&lt;p&gt;As I wrote in previous articles writing code is our biggest power and liability.&lt;!-- raw HTML omitted --&gt;
Wasting time writing useless code is like slowly typing with one finger, without any clue of a design nor knowledge of the subject.&lt;!-- raw HTML omitted --&gt;
Of course this is very personal, but any time I have to reiterate some steps (in anything in my life) for no purpose but bad-design/bad-architecture/technical-debt it really makes me feel bad.&lt;!-- raw HTML omitted --&gt;
Again, it is like playing Diablo and clicking all the time to attack, instead of knowing that you can hold the mouse button!&lt;/p&gt;
&lt;p&gt;Finally to the topic: shader augmentation means moving to data what many times is expressed in code.&lt;!-- raw HTML omitted --&gt;
We can both have a data-driven rendering, or even generate code for us, or a combination of both.&lt;!-- raw HTML omitted --&gt;
There is not right or wrong, and this will change in the future!&lt;!-- raw HTML omitted --&gt;
The best solution is the one that solves your (incredibly well described) problem.&lt;/p&gt;
&lt;p&gt;Adding render states, vertex inputs, render graph informations let a simple text file to find its space into your awesome rendering quite easily.&lt;/p&gt;
&lt;h2 id=&#34;logically-group-shaders-in-the-same-file&#34;&gt;Logically group shaders in the same file.&lt;/h2&gt;
&lt;p&gt;Having to write separated files it can be ok, but many times having everything in one file (well divided) will be easier to logically connects the shader themselves.&lt;!-- raw HTML omitted --&gt;
Sometimes you can get lost into the combination of shaders quite easily.&lt;!-- raw HTML omitted --&gt;
And anyway you NEED to define which shaders are used together since the dawn of time.&lt;/p&gt;
&lt;p&gt;So put them into the same file!&lt;/p&gt;
&lt;h2 id=&#34;describe-a-priori-all-the-static-parts-of-rendering&#34;&gt;Describe a priori all the STATIC parts of rendering.&lt;/h2&gt;
&lt;p&gt;Knowing all the static parts of rendering can lead to offline analysis and build, statistics, and all kind of things you can think of.&lt;!-- raw HTML omitted --&gt;
It also serves to really have knowledge of the combinational explosion of rendering &lt;strong&gt;before&lt;/strong&gt; it arrives in your beloved renderer!&lt;!-- raw HTML omitted --&gt;
Sometimes you can group shaders together and improve speed and usability by just analysing how &lt;strong&gt;similar&lt;/strong&gt; some shaders are.&lt;/p&gt;
&lt;h2 id=&#34;being-more-data-driven-improve-iteration-time&#34;&gt;Being more data driven, improve iteration time.&lt;/h2&gt;
&lt;p&gt;If you think of reloading assets, then a shader reload will also load all the render stage associated.&lt;!-- raw HTML omitted --&gt;
If you want to bring it a step further, adding/removing passes, changing were in the &lt;em&gt;render graph&lt;/em&gt; the shaders are used can be an incredible tool to quickly prototype, optimize, develop ideas.&lt;/p&gt;
&lt;h2 id=&#34;being-more-data-driven-encourage-rendering-experimentation&#34;&gt;Being more data driven, encourage rendering experimentation.&lt;/h2&gt;
&lt;p&gt;You can also add some non-coding tools to augment a shader with all those data.&lt;!-- raw HTML omitted --&gt;
And again, defining this in data let&amp;rsquo;s you check relationship with the rest of the renderer more easily.&lt;/p&gt;
&lt;h2 id=&#34;easiness-of-debugging&#34;&gt;Easiness of debugging.&lt;/h2&gt;
&lt;p&gt;Data-drivenness means that data is always available.&lt;!-- raw HTML omitted --&gt;
In the example I am adding here, you can see how useful can be to even have a simple ImGui debug of a HFX file.&lt;!-- raw HTML omitted --&gt;
Bring that to a realtime renderer, and you can quickly debug rendering problems without having to use external tools like Pix, RenderDoc and such. These are wonderful tools, but I always love to have a defense before arriving there.&lt;/p&gt;
&lt;p&gt;An example is to debug on someone&amp;rsquo;s machine that does not have installed those tools.&lt;/p&gt;
&lt;p&gt;Same can be applied to performances, to quickly check performances in realtime.&lt;/p&gt;
&lt;p&gt;Tooling is essential to any developer, and should be developed with the technology itself.&lt;/p&gt;
&lt;h2 id=&#34;encourages-less-hardcoded-data&#34;&gt;Encourages less hardcoded data.&lt;/h2&gt;
&lt;p&gt;Nothing wrong to hardcoding data, and many times is necessary and useful.&lt;!-- raw HTML omitted --&gt;
But the question is: &lt;strong&gt;when&lt;/strong&gt; is necessary ?&lt;/p&gt;
&lt;p&gt;Having a common data format gives you the tools (see previous point) to analyze, compared to hardcoded.&lt;/p&gt;
&lt;h1 id=&#34;shader-augmentations&#34;&gt;Shader Augmentations&lt;/h1&gt;
&lt;p&gt;We will take a HFX shader and will see all the augmentations.&lt;!-- raw HTML omitted --&gt;
This is used in the &lt;a href=&#34;https://jorenjoestar.github.io/post/data_driven_rendering_pipeline/&#34;&gt;Render Pipeline Article&lt;/a&gt; and renders the GLTF assets:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;shader PBR {

    properties {
        albedo_texture(&amp;quot;Albedo&amp;quot;, 2D) = &amp;quot;&amp;quot;
        normals_texture(&amp;quot;Normals&amp;quot;, 2D) = &amp;quot;&amp;quot;
        metal_roughness_texture(&amp;quot;MetalRoughness&amp;quot;, 2D) = &amp;quot;&amp;quot;
        emissive_texture(&amp;quot;Emissive&amp;quot;, 2D) = &amp;quot;&amp;quot;
        occlusion_texture(&amp;quot;Occlusion&amp;quot;, 2D) = &amp;quot;&amp;quot;
        scale(&amp;quot;Scale&amp;quot;, Float) = 16.0
    }

    layout {
        vertex main3D {
            binding 0 16 vertex
            attribute float3 Position 0 0 0
            attribute ubyte4n Color 0 1 12
        }

        vertex main3DPosition {
            binding 0 12 vertex
            attribute float3 Position 0 0 0
        }

        vertex main3DPositionNormal {
            binding 0 12 vertex
            binding 1 12 vertex
            binding 3 64 instance
            attribute float3 Position 0 0 0
            attribute float3 Normal 1 1 0
            attribute float4 InstanceTransform 3 3 0
            attribute float4 InstanceTransform 3 4 16
            attribute float4 InstanceTransform 3 5 32
            attribute float4 InstanceTransform 3 6 48
        }

        vertex gbuffer {
            binding 0 12 vertex
            binding 1 12 vertex
            binding 2 8 vertex
            binding 3 64 instance
            attribute float3 Position 0 0 0
            attribute float3 Normal 1 1 0
            attribute float2 UV 2 2 0
            attribute float4 InstanceTransform 3 3 0
            attribute float4 InstanceTransform 3 4 16
            attribute float4 InstanceTransform 3 5 32
            attribute float4 InstanceTransform 3 6 48
        }

        list gbuffer {
            cbuffer ViewConstants ViewConstants;

            texture2D albedo;
            texture2D normals;
            texture2D metalRoughness;
            texture2D emissive;
            texture2D occlusion;

            sampler2D linear_sampler
        }
    }

    sampler_states {
        state linear_sampler {
            Filter MinMagMipLinear
            AddressU Clamp
            AddressV Clamp
        }
    }

    render_states {
        state main {
            Cull Back
            ZTest LEqual
            ZWrite On
        }

        state linesZTest {
            Cull None
            ZTest LEqual
            ZWrite Off
            BlendMode Alpha
        }
    }

    glsl GBuffer_V {

        #pragma include &amp;quot;Platform.h&amp;quot;

        layout (location = 0) in vec3 Position;
        layout (location = 1) in vec3 Normal;
        layout (location = 2) in vec2 UV;
        layout (location = 3) in mat4 instanceTransform;

        layout (std140, binding=0) uniform ViewConstants {
            mat4                    view_projection_matrix;
            mat4                    projection_matrix;
            vec4                    resolution;
        };

        out vec3 vertexNormal;
        out vec2 uv;
        out vec3 worldPosition;

        void main()
        {
            vertexNormal = (inverse(transpose((instanceTransform))) * vec4(Normal,0)).rgb;
            uv = UV;

            vec4 world_pos = instanceTransform * vec4(Position.xyz, 1.0f);
            worldPosition = world_pos.xyz;
            gl_Position = view_projection_matrix * world_pos;
        }
    }

    glsl GBuffer_F {

        #pragma include &amp;quot;Platform.h&amp;quot;
    
        layout (location = 0) out vec4 Out_Color;
        layout (location = 1) out vec4 Out_Normals;
        layout (location = 2) out vec4 Out_Properties0;
        //layout (location = 3) out vec4 Out_WorldPosition;

        layout(binding=0) uniform sampler2D albedo;
        layout(binding=1) uniform sampler2D normals;
        layout(binding=2) uniform sampler2D metalRoughness;
        layout(binding=3) uniform sampler2D emissive;
        layout(binding=4) uniform sampler2D occlusion;

        in vec3 vertexNormal;
        in vec2 uv;
        in vec3 worldPosition;

        void generate_TB_basis( out vec3 vT, out vec3 vB, vec2 texST, vec3 base_normal, vec3 sigma_x, vec3 sigma_y, float flip_sign )
        {
            vec2 dSTdx = dFdxFine ( texST ) , dSTdy = dFdyFine ( texST ) ;
            float det = dot ( dSTdx , vec2 ( dSTdy .y ,- dSTdy .x ));
            float sign_det = det &amp;lt;0 ? -1 : 1;

            // invC0 represents ( dXds , dYds ) ; but we don ’t divide by
            // determinant ( scale by sign instead )
            vec2 invC0 = sign_det * vec2 ( dSTdy .y , - dSTdx .y );

            vT = sigma_x * invC0 .x + sigma_y * invC0 .y;
            if( abs ( det ) &amp;gt; 0.0)
                vT = normalize ( vT );

            vB = ( sign_det * flip_sign ) * cross ( base_normal , vT );
        }

        void main()
        {
            // Calculate gradient base:
            vec3 base_normal = normalize(vertexNormal);

            vec3 position_derivate_x = dFdxFine( worldPosition );
            vec3 position_derivate_y = dFdyFine( worldPosition );

            vec3 sigma_x = position_derivate_x - dot( position_derivate_x, base_normal ) * base_normal;
            vec3 sigma_y = position_derivate_y - dot( position_derivate_y, base_normal ) * base_normal;
            float flip_sign = dot ( position_derivate_y, cross ( base_normal, position_derivate_x )) &amp;lt; 0 ? -1 : 1;

            vec3 tangent, bitangent;
            generate_TB_basis( tangent, bitangent, uv.xy, base_normal, sigma_x, sigma_y, flip_sign );

            vec3 tangent_normal = texture(normals, uv.xy).xyz * 2 - 1;

            vec3 normal = tangent * tangent_normal.x + bitangent * tangent_normal.y + base_normal * tangent_normal.z;
            normal = normalize(normal);

            vec3 emissive_color = texture(emissive, uv.xy).rgb;

            //Out_Normals = vec4(vertexNormal, 1);
            //Out_Normals = vec4(tangent_normal * 0.5 + 0.5, 1);
            Out_Normals = vec4(normal, emissive_color.r);

            vec3 color = texture(albedo, uv.xy).xyz;
            float occlusion = texture(occlusion, uv.xy).r;
            Out_Color = vec4(color, occlusion);

            // G = Rougthness, B = Metalness
            vec2 roughness_metal = texture(metalRoughness, uv.xy).yz;
            Out_Properties0 = vec4(roughness_metal.xy, emissive_color.gb);

            // TODO: remove! This is to test world space reconstruction!
            //Out_WorldPosition = vec4(worldPosition, 1);
        }
    }

    glsl PositionOnly {

        #pragma include &amp;quot;Platform.h&amp;quot;

        #if defined VERTEX

        layout (location = 0) in vec3 Position;

        uniform ViewConstants { 
            mat4                    view_projection_matrix;
            mat4                    projection_matrix;
            vec4                    resolution;
        };

        void main()
        {
            gl_Position = view_projection_matrix * vec4(Position.xyz, 1.0f);
        }
        out vec4 vTexCoord;

        #endif // VERTEX

        #if defined FRAGMENT

        layout (location = 0) out vec4 Out_Color;
        
        void main()
        {
            Out_Color = vec4(1,1,1,1);
        }
        #endif // FRAGMENT
    }

    glsl PositionNormals {

        #pragma include &amp;quot;Platform.h&amp;quot;

        #if defined VERTEX

        layout (location = 0) in vec3 Position;
        layout (location = 1) in vec3 Normal;
        layout (location = 3) in mat4 instanceTransform;

        layout (std140, binding=0) uniform ViewConstants { 
            mat4                    view_projection_matrix;
            mat4                    projection_matrix;
            vec4                    resolution;
        };

        out vec3 vertexNormal;

        void main()
        {
            vertexNormal = Normal;
            gl_Position = view_projection_matrix * instanceTransform * vec4(Position.xyz, 1.0f);
        }
        

        #endif // VERTEX

        #if defined FRAGMENT

        layout (location = 0) out vec4 Out_Color;
        layout (location = 1) out vec4 Out_Normals;
        in vec3 vertexNormal;
        
        void main()
        {
            Out_Normals = vec4(vertexNormal * 0.5 + 0.5, 1);

            vec3 L = vec3(-0.7, 0.7, 0 );
            float lambert_diffuse = max(0, dot(vertexNormal, L));
            Out_Color = vec4(lambert_diffuse.xxx, 1);
        }
        #endif // FRAGMENT
    }

    pass GBuffer {
        resources = gbuffer
        render_states = main
        vertex_layout = gbuffer
        vertex = GBuffer_V
        fragment = GBuffer_F
    }

    pass PositionN {
        render_states = main
        vertex_layout = main3DPositionNormal
        vertex = PositionNormals
        fragment = PositionNormals
    }

    pass PositionOnly {
        render_states = main
        vertex_layout = main3DPosition
        vertex = PositionOnly
        fragment = PositionOnly
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;1-linking-multiple-programs&#34;&gt;1: Linking Multiple Programs&lt;/h2&gt;
&lt;p&gt;This is a pretty simple task, and the first one to be tackled.&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;p&gt;In Vulkan all the Pipelines need all the shader used at creation, using an array of &lt;a href=&#34;https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPipelineShaderStageCreateInfo.html&#34;&gt;VkPipelineStageCreationInfo&lt;/a&gt; for graphics, compute and ray-tracing.&lt;/p&gt;
&lt;p&gt;In D3D12, you have the &lt;a href=&#34;https://docs.microsoft.com/en-us/windows/win32/api/d3d12/ns-d3d12-d3d12_shader_bytecode&#34;&gt;ShaderBytecode&lt;/a&gt; used in the pipelines, but not as arrays (just member of the various creation structs).&lt;/p&gt;
&lt;p&gt;From a functionality perspective, they are EQUAL. It makes sense - a &lt;strong&gt;Pipeline&lt;/strong&gt; is the description of all the static part of a GPU pipeline, and shaders are amongst the most important part of it.&lt;/p&gt;
&lt;p&gt;You can see it in the &amp;lsquo;pass&amp;rsquo; section of the HFX file:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;pass PositionOnly {
    vertex = PositionOnly
    fragment = PositionOnly
    ...
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;For a compute pipeline is even simpler, and dispatch size can be added as well:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;pass DeferredCompute {
    compute = DeferredCompute
    dispatch = 32, 32, 1
    ...
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Even just with something like this it is easy to organize different shaders.&lt;/p&gt;
&lt;h2 id=&#34;2-define-render-states&#34;&gt;2: Define Render States&lt;/h2&gt;
&lt;p&gt;Following the previous point, Pipelines need also (almost) all the render states (depth/stencil, alpha, raster, &amp;hellip;) to be defined.&lt;!-- raw HTML omitted --&gt;
This was one of the main features of CGFX and Microsoft&amp;rsquo;s FX - and still now is incredibly useful.&lt;!-- raw HTML omitted --&gt;
Unity&amp;rsquo;s ShaderLab also incorporates render states.&lt;/p&gt;
&lt;p&gt;I decided to separate render states on their own group:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;render_states {
    state main {
        Cull Back
        ZTest LEqual
        ZWrite On
    }

    state linesZTest {
        Cull None
        ZTest LEqual
        ZWrite Off
        BlendMode Alpha
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Here two different render states are defined.&lt;!-- raw HTML omitted --&gt;
In this case a render states defines depth/stencil, blend and rasterization.&lt;/p&gt;
&lt;p&gt;A great addition to that is to add the possibility of inherit/override render states.&lt;!-- raw HTML omitted --&gt;
For example in a Transparent pass, the blend state could be defined in the Render Pass data, and be inherited explicitly here.&lt;/p&gt;
&lt;p&gt;Also very important is the definition of &lt;strong&gt;input assembly&lt;/strong&gt; - how the vertices are fed into the &lt;em&gt;vertex program&lt;/em&gt;:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;layout {
    vertex main3D {
        binding 0 16 vertex
        attribute float3 Position 0 0 0
        attribute ubyte4n Color 0 1 12
    }

    vertex main3DPosition {
        binding 0 12 vertex
        attribute float3 Position 0 0 0
    }

    vertex main3DPositionNormal {
        binding 0 12 vertex
        binding 1 12 vertex
        binding 3 64 instance
        attribute float3 Position 0 0 0
        attribute float3 Normal 1 1 0
        attribute float4 InstanceTransform 3 3 0
        attribute float4 InstanceTransform 3 4 16
        attribute float4 InstanceTransform 3 5 32
        attribute float4 InstanceTransform 3 6 48
    }

    vertex gbuffer {
        binding 0 12 vertex
        binding 1 12 vertex
        binding 2 8 vertex
        binding 3 64 instance
        attribute float3 Position 0 0 0
        attribute float3 Normal 1 1 0
        attribute float2 UV 2 2 0
        attribute float4 InstanceTransform 3 3 0
        attribute float4 InstanceTransform 3 4 16
        attribute float4 InstanceTransform 3 5 32
        attribute float4 InstanceTransform 3 6 48
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Here we can see some instancing use case, just to show the flexibility of writing this code.&lt;!-- raw HTML omitted --&gt;
The bytes offset could be removed as well.&lt;/p&gt;
&lt;h2 id=&#34;3-use-any-shader-language&#34;&gt;3: Use ANY Shader Language&lt;/h2&gt;
&lt;p&gt;The best way to diffuse these augmentation is to change the less possible the shader languate itself.&lt;!-- raw HTML omitted --&gt;
This is because you want to be portable, and when having different platform it can be paramount even to define shaders with different languages into the same file, and switch based on platforms.&lt;!-- raw HTML omitted --&gt;
This is becoming less and less of a need (see HLSL working on Vulkan) but there could be some special cases.&lt;!-- raw HTML omitted --&gt;
Would it be great to fix those special cases by writing platform specific shader fragments without any of your internal rendering code changing ?&lt;/p&gt;
&lt;p&gt;The choise here is to use a keyword to identify the type of language and then simply write the code in that language.&lt;!-- raw HTML omitted --&gt;
This is &lt;em&gt;ideal&lt;/em&gt; to also incorporate code from previous codebases with a small amount of work.&lt;/p&gt;
&lt;p&gt;Let&amp;rsquo;s look at the GBuffer Vertex GLSL code:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;glsl GBuffer_V {

    #pragma include &amp;quot;Platform.h&amp;quot;

    layout (location = 0) in vec3 Position;
    layout (location = 1) in vec3 Normal;
    layout (location = 2) in vec2 UV;
    layout (location = 3) in mat4 instanceTransform;

    layout (std140, binding=0) uniform ViewConstants {
        mat4                    view_projection_matrix;
        mat4                    projection_matrix;
        vec4                    resolution;
    };

    out vec3 vertexNormal;
    out vec2 uv;
    out vec3 worldPosition;

    void main()
    {
        vertexNormal = (inverse(transpose((instanceTransform))) * vec4(Normal,0)).rgb;
        uv = UV;

        vec4 world_pos = instanceTransform * vec4(Position.xyz, 1.0f);
        worldPosition = world_pos.xyz;
        gl_Position = view_projection_matrix * world_pos;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The only modification I did, and it is sadly necessary in GLSL, is to add the &amp;lsquo;#pragma include&amp;rsquo; custom parsing to add the include in the HFX compiler.&lt;/p&gt;
&lt;h2 id=&#34;4-resource-layouts-as-first-citizens&#34;&gt;4: Resource Layouts as First Citizens&lt;/h2&gt;
&lt;p&gt;A new addition of the new APIs, resource layouts are another great factor to take care of.&lt;!-- raw HTML omitted --&gt;
Architecturally they can be implemented in different ways, but I like the idea of having them &amp;lsquo;in your face&amp;rsquo; since the beginning!&lt;/p&gt;
&lt;p&gt;In the &lt;em&gt;layout&lt;/em&gt; section, you can define resources like this:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;list gbuffer {
    cbuffer ViewConstants ViewConstants;

    texture2D albedo;
    texture2D normals;
    texture2D metalRoughness;
    texture2D emissive;
    texture2D occlusion;

    sampler2D linear_sampler
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The name will be used in the pass section to define which resource list is used.&lt;!-- raw HTML omitted --&gt;
There can be multiple resource lists, normally they should be grouped per frequency (most frequent changes to least frequent ones) and can be separated by a comma for example.&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;p&gt;A small addition is to use externally specified resource list and code, like for &lt;strong&gt;starnest.hfx&lt;/strong&gt;:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;pass main {
	...
	resources = &amp;quot;ShaderToy.Main&amp;quot;	
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This means that the pass named &amp;lsquo;main&amp;rsquo; will simply use the resources defined in &amp;lsquo;shadertoy.hfx&amp;rsquo; - resource list called main.&lt;/p&gt;
&lt;h2 id=&#34;5-permutations&#34;&gt;5: Permutations&lt;/h2&gt;
&lt;p&gt;This is the most tedious of the tasks, and also one of the most dangerous.&lt;!-- raw HTML omitted --&gt;
Permutations explosion is a well known problem, and there are different ways of tackling this. If you don&amp;rsquo;t have a shader augmentation a good option is to write some scripts to help with generating the code.&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;p&gt;Otherwise if you have a shader augmentation and you define a &amp;lsquo;shader state&amp;rsquo;, you can define some &amp;lsquo;permutation flags&amp;rsquo;, and just add the defines when you compile shaders. Even in GLSL, you can do some easy string concatenation to add those defines, or use tools like GLSLang + SpirV to help.&lt;/p&gt;
&lt;p&gt;This becomes a cartesian product of all the &lt;em&gt;permutations/options groups&lt;/em&gt; and again can lead to a lot of created shader.&lt;!-- raw HTML omitted --&gt;
I am still investigating the best approach and I will update this article with the results, because I want to include them into HFX but avoid that to become a huge file - and worst to include unused permutations.&lt;/p&gt;
&lt;p&gt;So stay tuned as I will update this article with the solution I find!&lt;/p&gt;
&lt;h2 id=&#34;6-c-generated-helpers&#34;&gt;6: C++ Generated Helpers&lt;/h2&gt;
&lt;p&gt;As finishing touch, there are some informations that can be exposed in a c++ file.
&amp;hellip;&lt;/p&gt;
&lt;h1 id=&#34;included-code-shader-augmentation&#34;&gt;Included code: &amp;lsquo;Shader Augmentation&amp;rsquo;&lt;/h1&gt;
&lt;p&gt;The included code has a small application to compile and inspect HFX files.
&amp;hellip;&lt;/p&gt;
&lt;h1 id=&#34;conclusions&#34;&gt;Conclusions&lt;/h1&gt;
&lt;p&gt;I tried to explain the reasons of the different &lt;strong&gt;shader augmentations&lt;/strong&gt; and trying to focus more on the importance of not trying to create a new shading language, but instead empowering it with new informations.&lt;/p&gt;
&lt;p&gt;I can&amp;rsquo;t stress enough how important is to me to have an abstraction that is slightly on top of current shaders API - and create other systems to hide the complexities if needed.&lt;/p&gt;
&lt;p&gt;With HFX, I would like to &lt;em&gt;expand&lt;/em&gt; any language by adding all those features.&lt;!-- raw HTML omitted --&gt;
I wish this could become a used tool by many in their project, and really wish it will be the initial spark.&lt;/p&gt;
&lt;p&gt;Next in line is a revisiting of higher level of rendering, to arrive to explore different rendering techniques with the easiness that the data-driven approach should give.&lt;/p&gt;
&lt;p&gt;As always please comment, give me feedback, share and enjoy!&lt;/p&gt;
&lt;p&gt;Thanks for reading!
Gabriel&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Writing a Shader Effect Language Part 3: Materials</title>
      <link>https://jorenjoestar.github.io/post/writing_shader_effect_language_3/</link>
      <pubDate>Mon, 14 Oct 2019 10:43:49 -0400</pubDate>
      
      <guid>https://jorenjoestar.github.io/post/writing_shader_effect_language_3/</guid>
      <description>&lt;h1 id=&#34;overview&#34;&gt;Overview&lt;/h1&gt;
&lt;p&gt;Data Driven Rendering Series:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;https://jorenjoestar.github.io/post/writing_shader_effect_language_1/&#34;&gt;https://jorenjoestar.github.io/post/writing_shader_effect_language_1/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://jorenjoestar.github.io/post/writing_shader_effect_language_2/&#34;&gt;https://jorenjoestar.github.io/post/writing_shader_effect_language_2/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://jorenjoestar.github.io/post/writing_shader_effect_language_3/&#34;&gt;https://jorenjoestar.github.io/post/writing_shader_effect_language_3/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://jorenjoestar.github.io/post/data_driven_rendering_pipeline/&#34;&gt;https://jorenjoestar.github.io/post/data_driven_rendering_pipeline/&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;In &lt;a href=&#34;https://jorenjoestar.github.io/post/writing_shader_effect_language_2/&#34;&gt;Part 2 of this series&lt;/a&gt; we added Resource Layouts and Properties to the &lt;strong&gt;HFX&lt;/strong&gt; language, trying to arrive at a point in which we can describe the rendering of a Shader Effect almost entirely.&lt;!-- raw HTML omitted --&gt;
In this article I would like to explore further adds to HFX, especially a proper &lt;strong&gt;Material System&lt;/strong&gt; to be used in conjunction with the HFX language.&lt;!-- raw HTML omitted --&gt;
I also separated the code a little bit for clarity and added the usage of STB array and hash maps.&lt;!-- raw HTML omitted --&gt;
With that I would like to develop a Material System that is robust and easy to use, even though I am (DISCLAIMER!) far from it!&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;p&gt;I will first talk about the theory and thoughts behind those changes, and then go through the code changes and addition.&lt;/p&gt;
&lt;h1 id=&#34;material-system-thoughts&#34;&gt;Material System thoughts&lt;/h1&gt;
&lt;p&gt;Following a nomenclature from the amazing guys at &lt;a href=&#34;https://ourmachinery.com/post/&#34;&gt;our_machinery&lt;/a&gt;, we are adding a &lt;em&gt;Tier 1 Shader System&lt;/em&gt; - something that builds on top of the graphics API created in the previous article.&lt;/p&gt;
&lt;p&gt;First of all, a great series of article is again on their website:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://ourmachinery.com/post/the-machinery-shader-system-part-1/&#34;&gt;https://ourmachinery.com/post/the-machinery-shader-system-part-1/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://ourmachinery.com/post/the-machinery-shader-system-part-2/&#34;&gt;https://ourmachinery.com/post/the-machinery-shader-system-part-2/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://ourmachinery.com/post/the-machinery-shader-system-part-3/&#34;&gt;https://ourmachinery.com/post/the-machinery-shader-system-part-3/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;We are building a Material System based on a graphics-API that exposes the following concepts:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Buffer&lt;/li&gt;
&lt;li&gt;Texture&lt;/li&gt;
&lt;li&gt;Pipeline (that includes shaders)&lt;/li&gt;
&lt;li&gt;Render Pass&lt;/li&gt;
&lt;li&gt;Resource List Layout&lt;/li&gt;
&lt;li&gt;Resource List&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;We are using a Vulkan/D3D12 interface here, and these concepts map 1 to 1 with that.&lt;!-- raw HTML omitted --&gt;
One of the big changes from a typical low-level graphics API is both the &amp;lsquo;missing&amp;rsquo; concept of Shader as a resource, and the addition of Render Pass as resource.&lt;!-- raw HTML omitted --&gt;
A new concept is the one of &lt;strong&gt;Resource List Layout&lt;/strong&gt; and &lt;strong&gt;Resource List&lt;/strong&gt;.&lt;!-- raw HTML omitted --&gt;
The Vulkan names are &lt;strong&gt;Descriptor Set Layout&lt;/strong&gt; and &lt;strong&gt;Descriptor Set&lt;/strong&gt;, but even though they reflect more the underlying driver nature of the term, I changed to &lt;strong&gt;Resource List&lt;/strong&gt; just to have it clearer as a concept.&lt;/p&gt;
&lt;p&gt;The &lt;strong&gt;King&lt;/strong&gt; here is the Pipeline: it is a structure that contains &lt;strong&gt;all the immutable data of a pipeline&lt;/strong&gt;. That includes our missing &lt;strong&gt;shaders&lt;/strong&gt;, all the &lt;strong&gt;render states&lt;/strong&gt; (DepthStencil, AlphaBlend, &amp;hellip;) and a &lt;strong&gt;Layout of the resources to be used by the shader&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;Part of the &lt;strong&gt;dynamic&lt;/strong&gt; pipeline states are normally the &lt;strong&gt;geometry&lt;/strong&gt; and the &lt;strong&gt;resource lists&lt;/strong&gt;.&lt;!-- raw HTML omitted --&gt;
Note that I am using the plural here: each &lt;strong&gt;pipeline&lt;/strong&gt; can have 1 or more &lt;strong&gt;resource lists!!&lt;/strong&gt;.&lt;!-- raw HTML omitted --&gt;
This is a good to organize your resources based on update frequencies, something coming from the numerous talks about Approaching Zero Driver Overhead.&lt;/p&gt;
&lt;p&gt;Remembering the simple interface of our API, now we have the following:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;struct Device {

	...

    BufferHandle                    create_buffer( const BufferCreation&amp;amp; creation );
    TextureHandle                   create_texture( const TextureCreation&amp;amp; creation );
    PipelineHandle                  create_pipeline( const PipelineCreation&amp;amp; creation );
    SamplerHandle                   create_sampler( const SamplerCreation&amp;amp; creation );
    ResourceListLayoutHandle        create_resource_list_layout( const ResourceListLayoutCreation&amp;amp; creation );
    ResourceListHandle              create_resource_list( const ResourceListCreation&amp;amp; creation );
    RenderPassHandle                create_render_pass( const RenderPassCreation&amp;amp; creation );

    ...
};
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;If you look at the OpenGL implementation (the only I wrote for now :( ) you will find that Shaders are considered resources, but it is more for convenience of the attach/linking OpenGL need than anything else.&lt;/p&gt;
&lt;p&gt;Let&amp;rsquo;s finally introduce the new concept for this article!&lt;/p&gt;
&lt;h2 id=&#34;shader-effect&#34;&gt;Shader Effect&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;A &lt;strong&gt;Shader Effect&lt;/strong&gt; is the blueprint of &lt;em&gt;static&lt;/em&gt; data needed to draw something on the screen.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;It needs to include &lt;strong&gt;shaders&lt;/strong&gt; (included in a &lt;strong&gt;Pipeline Description&lt;/strong&gt;), &lt;strong&gt;properties&lt;/strong&gt; (coming from the HFX file) and find its location into a &lt;strong&gt;render graph&lt;/strong&gt;.&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;A &lt;strong&gt;Shader Effect&lt;/strong&gt; is 1 to 1 with a &lt;strong&gt;Binary HFX file&lt;/strong&gt;.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;As a convenience we will add also informations about the &lt;strong&gt;local constants&lt;/strong&gt;.&lt;!-- raw HTML omitted --&gt;
When creating a Shader Effect, we can define properties, and we put all the numerical properties into one buffer.&lt;/p&gt;
&lt;p&gt;This is the current code:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;
struct ShaderEffect {

    //
    //
    struct PropertiesMap {

        char*                       key;
        hfx::ShaderEffectFile::MaterialProperty* value;

    }; // struct PropertiesMap

    struct Pass {
        PipelineCreation            pipeline_creation;
        char                        name[32];
        PipelineHandle              pipeline_handle;
        uint32_t                    pool_id;
    }; // struct Pass

    Pass*                           passes;

    uint16_t                        num_passes              = 0;
    uint16_t                        num_properties          = 0;
    uint32_t                        local_constants_size    = 0;

    char*                           local_constants_default_data = nullptr;
    char*                           properties_data         = nullptr;

    PropertiesMap*                  name_to_property        = nullptr;

    char                            name[32];
    char                            pipeline_name[32];
    uint32_t                        pool_id;

}; // struct ShaderEffect

&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;You see both a &lt;strong&gt;pipeline name&lt;/strong&gt; and an array of &lt;strong&gt;passes&lt;/strong&gt; with a name. These are to insert the pass into a very &lt;strong&gt;primordial&lt;/strong&gt; render graph, that I wrote just because I didn&amp;rsquo;t want to hardcode the frame structure, especially because next article will be EXACTLY on this topic!&lt;/p&gt;
&lt;p&gt;Having defined the Shader Effect, we can now move into the next big actor.&lt;/p&gt;
&lt;h2 id=&#34;material&#34;&gt;Material&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;A &lt;strong&gt;Material&lt;/strong&gt; is an instance of a &lt;strong&gt;Shader Effect&lt;/strong&gt;.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Given a HFX file, we generate a new file (HMT, Hydra Material) that will contain all the informations.&lt;!-- raw HTML omitted --&gt;
The concept of Material is really &lt;strong&gt;unique values for the properties of a Shader Effect&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;That is basically it.&lt;/p&gt;
&lt;p&gt;For example, if a shader contains a property like an &lt;em&gt;albedo texture&lt;/em&gt;, the material answer the question &amp;ldquo;which albedo texture?&amp;rdquo;.&lt;!-- raw HTML omitted --&gt;
This is done for every property.&lt;/p&gt;
&lt;p&gt;Let&amp;rsquo;s have a look at our new material:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;{
    &amp;quot;name&amp;quot;: &amp;quot;SimpleFullscreen&amp;quot;,
    &amp;quot;effect_path&amp;quot;: &amp;quot;SimpleFullscreen.hfx&amp;quot;,
    &amp;quot;properties&amp;quot;: [
        {
            &amp;quot;scale&amp;quot;: 16.0,
            &amp;quot;albedo&amp;quot;: &amp;quot;AngeloCensorship.png&amp;quot;,
            &amp;quot;modulo&amp;quot;: 2.0
        }
    ],
    &amp;quot;bindings&amp;quot;: [
        {
            &amp;quot;LocalConstants&amp;quot;: &amp;quot;LocalConstants&amp;quot;,
            &amp;quot;destination_texture&amp;quot;: &amp;quot;compute_output_texture&amp;quot;,
            &amp;quot;input_texture&amp;quot;: &amp;quot;compute_output_texture&amp;quot;,
            &amp;quot;albedo_texture&amp;quot;: &amp;quot;albedo&amp;quot;
        }
    ]
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;As you can see there is a name, the effect path, the properties and the bindings. These will be explained in the next section.&lt;!-- raw HTML omitted --&gt;
Properties are just a name-value list, coming from the Shader Effect itself (the .bhfx file).&lt;/p&gt;
&lt;p&gt;The texture is my horrible drawing after reading the fantastic &lt;a href=&#34;http://c0de517e.blogspot.com/2019/08/engineering-career-guide-leaked.html&#34;&gt;rendering guide by Angelo Pesce&lt;/a&gt; and how he censored the parts that were internal to Roblox!&lt;/p&gt;
&lt;h2 id=&#34;shader-resource-database-and-lookup&#34;&gt;Shader Resource Database and Lookup&lt;/h2&gt;
&lt;p&gt;A concept that I saw only in the &lt;strong&gt;our_machinery&lt;/strong&gt; posts, but I personally adopted since a couple of years, is a way of automating a daunting task: &lt;em&gt;setting shader resources&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;I still need to finish the correct implementation of those, but the concepts are simple.&lt;!-- raw HTML omitted --&gt;
A &lt;strong&gt;Shader Resource Database&lt;/strong&gt; is a database of resources that can be searched using a &lt;strong&gt;Shader Resources Lookup&lt;/strong&gt;.&lt;!-- raw HTML omitted --&gt;
The name of the binding is the shader related name, while the value is the name into the database.&lt;!-- raw HTML omitted --&gt;
Of course you can use hashes instead of names, and compile them into a binary version of this, but this is not important now.&lt;/p&gt;
&lt;p&gt;One interesting bit (sadly not implemented here, sorry!) is the binding specialization. &lt;!-- raw HTML omitted --&gt;
This is done so that resources can be specialized in the database.&lt;!-- raw HTML omitted --&gt;
This is done per pass and it let you write only one binding list for all the Material, and then gather the proper resource based on the specialization.&lt;!-- raw HTML omitted --&gt;
For example if there is a binding for a pass-dependent resource, writing a generic version can specialize the shader pass correctly. Or using special keywords in the bindings, you can retrieve input/output textures from the render pass in which the shader is rendered!&lt;/p&gt;
&lt;p&gt;For now though it is more a manual written list, but it will be developed further.&lt;/p&gt;
&lt;h1 id=&#34;where-is-my-code-&#34;&gt;Where is my code ?&lt;/h1&gt;
&lt;p&gt;Having introduced the new concept, let&amp;rsquo;s look at the changes that happened in the last weeks of night coding.&lt;!-- raw HTML omitted --&gt;
As said before, in general I separated the code in header/cpp for clarity and building performances (after a good talk on Twitter, &lt;a href=&#34;https://twitter.com/GabrielSassone/status/1179810419617275905?s=20)&#34;&gt;https://twitter.com/GabrielSassone/status/1179810419617275905?s=20)&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&#34;applications&#34;&gt;Applications&lt;/h2&gt;
&lt;p&gt;First big changes was separating the code from the previous articles in an &lt;em&gt;application&lt;/em&gt;: namely &lt;strong&gt;CustomShaderLanguageApplication&lt;/strong&gt; in &lt;strong&gt;CustomShaderLanguage.h/cpp&lt;/strong&gt; and &lt;strong&gt;MaterialSystemApplication&lt;/strong&gt; in &lt;strong&gt;MaterialSystem.h/cpp&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;The first contains all the application code that uses HDF and HFX, with code generation and HFX compilation.&lt;!-- raw HTML omitted --&gt;
The second contains both the new &lt;strong&gt;Material System&lt;/strong&gt; and the application that uses it.&lt;!-- raw HTML omitted --&gt;
I would love to say that is an usable app, but I really touched my limits in non designing clearly when night coding.&lt;!-- raw HTML omitted --&gt;
&lt;strong&gt;Personal note: I hope this could be the spark to create a FX Composer successor, open source and free for all!&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;stb&#34;&gt;STB&lt;/h2&gt;
&lt;p&gt;As part of this experiment I wanted to try something different.&lt;!-- raw HTML omitted --&gt;
Instead of re-writing array and hash maps with templates, I wanted to give a try to the &lt;a href=&#34;https://github.com/nothings/stb&#34;&gt;STB libraries&lt;/a&gt;: namely &lt;strong&gt;stb_ds.h&lt;/strong&gt; and &lt;strong&gt;stb_image.h&lt;/strong&gt;.&lt;!-- raw HTML omitted --&gt;
Arrays and Hash Maps are now included in hydra_lib.h to be used across the code.&lt;/p&gt;
&lt;h2 id=&#34;hydra-graphics&#34;&gt;Hydra Graphics&lt;/h2&gt;
&lt;p&gt;The device added render passes and the support for multiple resources layout.&lt;!-- raw HTML omitted --&gt;
It also creates FBOs for color passes and supports resize, especially thanks to the Render Pipeline.&lt;/p&gt;
&lt;h2 id=&#34;primitive-render-graph-called-render-pipeline&#34;&gt;Primitive Render Graph (called Render Pipeline)&lt;/h2&gt;
&lt;p&gt;I use the term I used since the inception in 2010, and honestly it is more true to what it does.&lt;!-- raw HTML omitted --&gt;
It is not a graph but more a list of &lt;strong&gt;Render Stages&lt;/strong&gt; with input/outputs defined clearly.&lt;!-- raw HTML omitted --&gt;
In the next article I will develop more on this, but for now I needed some structure like this to be explicit.&lt;/p&gt;
&lt;p&gt;In the application there are 3 pipelines, one for a single pass ShaderToy shader, one for a silly compute to framebuffer shader(that for now loads a texture and outputs it to the framebuffer), and one for just a render to window.&lt;/p&gt;
&lt;p&gt;I use this in my indie project, with a fully custom and data driven (written in json) pipeline that includes compute deferred lighting and shadows, shadow passes, various post-process passes and such, everything very easy to debug and very easy to modify/add/delete.&lt;!-- raw HTML omitted --&gt;
There is a mechanism to send the correct draw calls to the correct pass through the usage of render systems, but again this will be a topic for the next article!&lt;/p&gt;
&lt;p&gt;In the included code, there is also a small but powerful tool: a pipeline explorer.&lt;!-- raw HTML omitted --&gt;
For now it will just show the render targets for each stage, and in these simple examples does not matter much.&lt;!-- raw HTML omitted --&gt;
In the next article we will dive deep into the &lt;strong&gt;Render Pipeline/Graph&lt;/strong&gt; subject and then all of this will make sense!&lt;/p&gt;
&lt;h1 id=&#34;break-a-simple-resource-manager&#34;&gt;Break: a simple Resource Manager&lt;/h1&gt;
&lt;p&gt;While being a very important topic, this is not the focus of this article.&lt;!-- raw HTML omitted --&gt;
Anyway I wanted a Resource Manager that would be helpful to handle resource creation and loading.&lt;!-- raw HTML omitted --&gt;
This includes also &lt;em&gt;resource compilation&lt;/em&gt;, something that normally happens at &lt;em&gt;build time&lt;/em&gt;, but in our exercise can be triggered at run-time.&lt;/p&gt;
&lt;p&gt;The &lt;strong&gt;resource manager&lt;/strong&gt; is a class that simply manages resources using &lt;strong&gt;factories&lt;/strong&gt; and manages dependencies between resources.&lt;!-- raw HTML omitted --&gt;
We have only 3 resources for now:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Textures&lt;/li&gt;
&lt;li&gt;Shader Effects&lt;/li&gt;
&lt;li&gt;Materials&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;resources&#34;&gt;Resources&lt;/h2&gt;
&lt;p&gt;A resource is a class that both has data and let the dependency with other data be clear.&lt;!-- raw HTML omitted --&gt;
The &lt;strong&gt;resource&amp;rsquo;s data&lt;/strong&gt; is actually a pointer to actual raw data used by other systems, in this case rendering.&lt;!-- raw HTML omitted --&gt;
Let&amp;rsquo;s see its definition:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;struct Resource {

    struct ResourceReference {
        uint8_t                     type;
        char                        path[255];
    }; // struct ResourceReference

    struct Header {

        char                        header[7];
        uint8_t                     type;   // ResourceType::enum

        size_t                      data_size;
        uint16_t                    num_external_references;
        uint16_t                    num_internal_references;
        
    }; // struct Header

    struct ResourceMap {
        char*                       key;
        Resource*                   value;
    };

    Header*                         header;
    char*                           data;
    void*                           asset;

    Resource::ResourceReference*    external_references;
    // External
    ResourceMap*                    name_to_external_resources;
    // Interal

}; // struct Resource
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;A resource is loaded from a binary file and contains a header and some data coming from the file, and an asset containing a system specific pointer.&lt;/p&gt;
&lt;p&gt;We added 3 system specific resources (Texture, Shader Effect and Material) but the class handled is always resource.&lt;!-- raw HTML omitted --&gt;
To access the system specific data, asset member is used.&lt;/p&gt;
&lt;p&gt;A resource contains also a map to the external resources loaded within it - to handle external references.&lt;/p&gt;
&lt;h2 id=&#34;compilation&#34;&gt;Compilation&lt;/h2&gt;
&lt;p&gt;Starting from a &lt;em&gt;source file&lt;/em&gt; (.hfx, .png, .hmt) using the specific factory, the resource manager compiles the code to a binary resource.&lt;!-- raw HTML omitted --&gt;
This means both converting the source format to a binary representation but also adding &lt;strong&gt;external dependencies&lt;/strong&gt; to the file.&lt;!-- raw HTML omitted --&gt;
These dependencies will be loaded when loading the resource, and before it.&lt;/p&gt;
&lt;h2 id=&#34;loading&#34;&gt;Loading&lt;/h2&gt;
&lt;p&gt;Loading happens by first loading all the dependent resources and then using the specific factory to load the &lt;em&gt;system specific&lt;/em&gt; asset.&lt;!-- raw HTML omitted --&gt;
This is a very semplicistic resource management - synchronous only, single threaded, not optimized - so really was an exercise in having something running for both compiling a resource and managing dependencies.&lt;!-- raw HTML omitted --&gt;
The whole point is the separation between a source and human-readable format to a binary one and encapsulate this.&lt;/p&gt;
&lt;p&gt;After this (very!) small break on resource management, let&amp;rsquo;s continue to the actual code for the materials!&lt;/p&gt;
&lt;h1 id=&#34;material-system-implementation&#34;&gt;Material System implementation&lt;/h1&gt;
&lt;p&gt;After all this thory let&amp;rsquo;s look at the code!&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;h2 id=&#34;shader-effect-1&#34;&gt;Shader Effect&lt;/h2&gt;
&lt;p&gt;The main parts of a &lt;strong&gt;Shader Effect&lt;/strong&gt; are &lt;strong&gt;Passes&lt;/strong&gt; and &lt;strong&gt;Properties&lt;/strong&gt;.&lt;!-- raw HTML omitted --&gt;
&lt;strong&gt;Passes&lt;/strong&gt; are the most important one, as they contain all the informations to create an actual &lt;strong&gt;Pipeline&lt;/strong&gt;, called &lt;strong&gt;Pipeline Creation&lt;/strong&gt;.&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;p&gt;Remembering the Vulkan/DX12 interface, we cannot create singularly a shader, but we need all the pipeline data (depth stencil, alpha blend, &amp;hellip;) to actually create the shaders too.&lt;/p&gt;
&lt;p&gt;The gist here is to access all those informations in a hiearchical way, basically reading them from the RenderPipeline and then overwriting with what is defined in the HFX file.&lt;/p&gt;
&lt;p&gt;Right now there is almost nothing if not the shaders, so the creation is quite simple:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;for ( uint16_t p = 0; p &amp;lt; shader_effect_file.header-&amp;gt;num_passes; p++ ) {
    hfx::ShaderEffectFile::PassHeader* pass_header = hfx::get_pass( shader_effect_file, p );

    uint32_t shader_count = pass_header-&amp;gt;num_shader_chunks;

    memcpy( effect-&amp;gt;passes[p].name, pass_header-&amp;gt;stage_name, 32 );

    PipelineCreation&amp;amp; pipeline_creation = effect-&amp;gt;passes[p].pipeline_creation;
    ShaderCreation&amp;amp; creation = pipeline_creation.shaders;
    bool compute = false;

    // Create Shaders
    for ( uint16_t i = 0; i &amp;lt; shader_count; i++ ) {
        hfx::get_shader_creation( pass_header, i, &amp;amp;creation.stages[i] );

        if ( creation.stages[i].type == ShaderStage::Compute )
            compute = true;
    }

    creation.name = pass_header-&amp;gt;name;
    creation.stages_count = shader_count;

    effect-&amp;gt;passes[p].pipeline_creation.compute = compute;

    // Create Resource Set Layouts
    for ( uint16_t l = 0; l &amp;lt; pass_header-&amp;gt;num_resource_layouts; l++ ) {

        uint8_t num_bindings = 0;
        const ResourceListLayoutCreation::Binding* bindings = get_pass_layout_bindings( pass_header, l, num_bindings );
        ResourceListLayoutCreation resource_layout_creation = { bindings, num_bindings };

        pipeline_creation.resource_list_layout[l] = context.device.create_resource_list_layout( resource_layout_creation );

    }

    pipeline_creation.num_active_layouts = pass_header-&amp;gt;num_resource_layouts;

    // Create Pipeline
    effect-&amp;gt;passes[p].pipeline_handle = context.device.create_pipeline( pipeline_creation );
    if ( effect-&amp;gt;passes[p].pipeline_handle.handle == k_invalid_handle ) {
        invalid_effect = true;
        break;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;When we will have a proper RenderPipeline, we will get the basic pipeline creation from there, and overwrite the shaders and states that will be defined in the HFX.&lt;/p&gt;
&lt;p&gt;There are 3 main steps here:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Create Shaders&lt;/li&gt;
&lt;li&gt;Create Resource Set Layouts&lt;/li&gt;
&lt;li&gt;Create Pipelines&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;These are simple operations that rely heavily on the device.&lt;!-- raw HTML omitted --&gt;
The objective of the HFX is to embed most information possible to create a complete pipeline.&lt;/p&gt;
&lt;p&gt;Another important step is to populate the properties map:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;string_hash_init_arena( effect-&amp;gt;name_to_property );

for ( uint32_t p = 0; p &amp;lt; effect-&amp;gt;num_properties; ++p ) {
    hfx::ShaderEffectFile::MaterialProperty* property = hfx::get_property( effect-&amp;gt;properties_data, p );

    string_hash_put( effect-&amp;gt;name_to_property, property-&amp;gt;name, property );
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;We are using the STB String Hashmap here with the property that are inside the shader effect file. Those will contain the type, name for UI and the pointer to a default value. &lt;!-- raw HTML omitted --&gt;
The default value will be used based on the type of course.&lt;/p&gt;
&lt;p&gt;We are also saving the local constant buffer size, so that we can allocate some memory in the Material and alter its property using the UI.&lt;/p&gt;
&lt;p&gt;We will see the importance of this next.&lt;/p&gt;
&lt;h2 id=&#34;material-1&#34;&gt;Material&lt;/h2&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;struct ShaderInstance {

    PipelineHandle                  pipeline;
    ResourceListHandle              resource_lists[hydra::graphics::k_max_resource_layouts];

    uint32_t                        num_resource_lists;
}; // struct ShaderInstance

struct Material {

    ShaderInstance*                 shader_instances        = nullptr;
    uint32_t                        num_instances           = 0;

    ShaderResourcesLookup           lookups; // Per-pass resource lookup. Same count as shader instances.
    ShaderEffect*                   effect                  = nullptr;

    BufferHandle                    local_constants_buffer;
    char*                           local_constants_data    = nullptr;

    const char*                     name                    = nullptr;
    StringBuffer                    loaded_string_buffer;
    
    uint32_t                        num_textures            = 0;
    uint32_t                        pool_id                 = 0;

    Texture**                       textures                = nullptr;

}; // struct Material
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This is the glue to actually render something on the screen.&lt;!-- raw HTML omitted --&gt;
As a recap, we need 3 informations to render something:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Pipeline (shaders + render states)&lt;/li&gt;
&lt;li&gt;Resources (handles to buffers and textures)&lt;/li&gt;
&lt;li&gt;Geometry (in this case a fullscreen quad)&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Material gives all those informations.&lt;/p&gt;
&lt;p&gt;A &lt;strong&gt;Shader Instance&lt;/strong&gt; is defined for each &lt;strong&gt;pass&lt;/strong&gt;, and actually contains the Pipeline Handle and the &lt;strong&gt;List of Resource Lists&lt;/strong&gt; to be used.&lt;!-- raw HTML omitted --&gt;
This is one of the new concepts for Vulkan/DX12: you can use one of more lists of resources to render, and normally it is better to group them by frequency.&lt;/p&gt;
&lt;p&gt;Finally, a list of &lt;strong&gt;textures&lt;/strong&gt; is saved to be modified by the editor.&lt;/p&gt;
&lt;p&gt;To understand more the process, let&amp;rsquo;s look at the loading code of a Material.&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;void* MaterialFactory::load( LoadContext&amp;amp; context ) {
    
    using namespace hydra::graphics;

    // 1. Read header from file
    MaterialFile material_file;
    material_file.header = (MaterialFile::Header*)context.data;
    material_file.property_array = (MaterialFile::Property*)(context.data + sizeof( MaterialFile::Header ));
    material_file.binding_array = (MaterialFile::Binding*)(context.data + sizeof( MaterialFile::Header ) + sizeof( MaterialFile::Property ) * material_file.header-&amp;gt;num_properties);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;We are using the data from the material file to access properties and bindings.&lt;!-- raw HTML omitted --&gt;
Properties are both numerical and path to textures, bindings are name to retrieve resources from the database. We will look into that later.&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;    // 2. Read shader effect
    Resource* shader_effect_resource = string_hash_get( context.resource-&amp;gt;name_to_external_resources, material_file.header-&amp;gt;hfx_filename );
    ShaderEffect* shader_effect = shader_effect_resource ? (ShaderEffect*)shader_effect_resource-&amp;gt;asset : nullptr;
    if ( !shader_effect ) {
        return nullptr;
    }

    // 3. Search pipeline
    RenderPipeline* render_pipeline = string_hash_get( context.name_to_render_pipeline, shader_effect-&amp;gt;pipeline_name );
    if ( !render_pipeline ) {
        return nullptr;
    }

&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Access the Shader Effect through the resource dependencies, and the Render Pipeline from the map.&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;    // 4. Load material
    char* material_name = material_file.header-&amp;gt;name;
    uint32_t pool_id = materials_pool.obtain_resource();
    Material* material = new (materials_pool.access_resource(pool_id))Material();
    material-&amp;gt;loaded_string_buffer.init( 1024 );
    material-&amp;gt;pool_id = pool_id;

    // TODO: for now just have one lookup shared.
    material-&amp;gt;lookups.init();
    // TODO: properly specialize.
    // For each pass
    //for ( uint32_t i = 0; i &amp;lt; effect-&amp;gt;num_pipelines; i++ ) {
    //    PipelineCreation&amp;amp; pipeline = effect-&amp;gt;pipelines[i];
    //    //final ShaderBindings specializedBindings = bindings.specialize( shaderTechnique.passName, shaderTechnique.viewName );
    //    //shaderBindings.add( specializedBindings );
    //}

    material-&amp;gt;effect = shader_effect;
    material-&amp;gt;num_instances = shader_effect-&amp;gt;num_passes;
    material-&amp;gt;shader_instances = new ShaderInstance[shader_effect-&amp;gt;num_passes];
    material-&amp;gt;name = material-&amp;gt;loaded_string_buffer.append_use( material_name );
    material-&amp;gt;num_textures = material_file.header-&amp;gt;num_textures;
    material-&amp;gt;textures = (Texture**)hydra::hy_malloc( sizeof( Texture* ) * material-&amp;gt;num_textures );
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Here is the meaty part.&lt;!-- raw HTML omitted --&gt;
We create the Material, initialize a StringBuffer used to store all the names found in the file, init the db-&amp;gt;resource lookup and create the ShaderInstance array.&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;    // Init memory for local constants
    material-&amp;gt;local_constants_data = (char*)hydra::hy_malloc( shader_effect-&amp;gt;local_constants_size );
    // Copy default values to init to sane valuess
    memcpy( material-&amp;gt;local_constants_data, material-&amp;gt;effect-&amp;gt;local_constants_default_data, material-&amp;gt;effect-&amp;gt;local_constants_size );
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;We cached the constant data size to allocate its memory, and we copy the default values in it.
This memory will be overwritten by the other numerical properties and used to initialize the local constant buffer.&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;    // Add properties
    uint32_t current_texture = 0;
    for ( size_t p = 0; p &amp;lt; material_file.header-&amp;gt;num_properties; ++p ) {
        MaterialFile::Property&amp;amp; property = material_file.property_array[p];

        hfx::ShaderEffectFile::MaterialProperty* material_property = string_hash_get( material-&amp;gt;effect-&amp;gt;name_to_property, property.name );

        switch ( material_property-&amp;gt;type ) {
            case hfx::Property::Texture2D:
            {
                const char* texture_path = material-&amp;gt;loaded_string_buffer.append_use( property.data );
                Resource* texture_resource = string_hash_get( context.resource-&amp;gt;name_to_external_resources, texture_path );
                Texture* texture = (Texture*)texture_resource-&amp;gt;asset;
                texture-&amp;gt;filename = texture_path;

                render_pipeline-&amp;gt;resource_database.register_texture( property.name, texture-&amp;gt;handle );

                material-&amp;gt;textures[current_texture] = texture;

                ++current_texture;

                break;
            }

            case hfx::Property::Float:
            {
                memcpy( material-&amp;gt;local_constants_data + material_property-&amp;gt;offset, property.data, sizeof( float ) );
                break;
            }
        }
    }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;When cycling through the properties, we are copying the numerical properties into the newly allocated memory (local_constant_data) and we load the textures from the dependencies.&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;     // Add bindings
    for ( size_t b = 0; b &amp;lt; material_file.header-&amp;gt;num_bindings; ++b ) {
        MaterialFile::Binding&amp;amp; binding = material_file.binding_array[b];

        char* name = material-&amp;gt;loaded_string_buffer.append_use( binding.name );
        char* value = material-&amp;gt;loaded_string_buffer.append_use( binding.value );
        material-&amp;gt;lookups.add_binding_to_resource( name, value );
    }

&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;We populate the resource lookups.&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;    BufferCreation checker_constants_creation = {};
    checker_constants_creation.type = BufferType::Constant;
    checker_constants_creation.name = s_local_constants_name;
    checker_constants_creation.usage = ResourceUsageType::Dynamic;
    checker_constants_creation.size = shader_effect-&amp;gt;local_constants_size;
    checker_constants_creation.initial_data = material-&amp;gt;local_constants_data;

    material-&amp;gt;local_constants_buffer = context.device.create_buffer( checker_constants_creation );
    render_pipeline-&amp;gt;resource_database.register_buffer( (char*)s_local_constants_name, material-&amp;gt;local_constants_buffer );
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Generate the actual constant buffer.&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;    // Bind material resources
    update_material_resources( material, render_pipeline-&amp;gt;resource_database, context.device );
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;And finally search the bindings for the resources.&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;static void update_material_resources( hydra::graphics::Material* material, hydra::graphics::ShaderResourcesDatabase&amp;amp; database, hydra::graphics::Device&amp;amp; device ) {

    using namespace hydra::graphics;

    // Create resource list
    // Get all resource handles from the database.
    ResourceListCreation::Resource resources_handles[k_max_resources_per_list];

    // For each pass
    for ( uint32_t i = 0; i &amp;lt; material-&amp;gt;effect-&amp;gt;num_passes; i++ ) {
        PipelineCreation&amp;amp; pipeline = material-&amp;gt;effect-&amp;gt;passes[i].pipeline_creation;

        for ( uint32_t l = 0; l &amp;lt; pipeline.num_active_layouts; ++l ) {
            // Get resource layout description
            ResourceListLayoutDescription layout;
            device.query_resource_list_layout( pipeline.resource_list_layout[l], layout );

            // For each resource
            for ( uint32_t r = 0; r &amp;lt; layout.num_active_bindings; r++ ) {
                const ResourceBinding&amp;amp; binding = layout.bindings[r];

                // Find resource name
                // Copy string_buffer 
                char* resource_name = material-&amp;gt;lookups.find_resource( (char*)binding.name );

                switch ( binding.type ) {
                    case hydra::graphics::ResourceType::Constants:
                    case hydra::graphics::ResourceType::Buffer:
                    {
                        BufferHandle handle = resource_name ? database.find_buffer( resource_name ) : device.get_dummy_constant_buffer();
                        resources_handles[r].handle = handle.handle;

                        break;
                    }

                    case hydra::graphics::ResourceType::Texture:
                    case hydra::graphics::ResourceType::TextureRW:
                    {
                        TextureHandle handle = resource_name ? database.find_texture( resource_name ) : device.get_dummy_texture();
                        resources_handles[r].handle = handle.handle;

                        break;
                    }

                    default:
                    {
                        break;
                    }
                }
            }

            ResourceListCreation creation = { pipeline.resource_list_layout[l], resources_handles, layout.num_active_bindings };
            material-&amp;gt;shader_instances[i].resource_lists[l] = device.create_resource_list( creation );
        }
        material-&amp;gt;shader_instances[i].num_resource_lists = pipeline.num_active_layouts;
        material-&amp;gt;shader_instances[i].pipeline = material-&amp;gt;effect-&amp;gt;passes[i].pipeline_handle;
    }
}

&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;For each Pass, Resource Layout and Binding, we search the Database to retrieve the actual resource and create the Resource List.&lt;/p&gt;
&lt;p&gt;This can be improved - having a global database of resources and a &amp;lsquo;local&amp;rsquo; one based on material resources.&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;    // 5. Bind material to pipeline
    for ( uint8_t p = 0; p &amp;lt; shader_effect-&amp;gt;num_passes; ++p ) {
        char* stage_name = shader_effect-&amp;gt;passes[p].name;
        hydra::graphics::RenderStage* stage = string_hash_get( render_pipeline-&amp;gt;name_to_stage, stage_name );

        if ( stage ) {
            stage-&amp;gt;material = material;
            stage-&amp;gt;pass_index = (uint8_t)p;
        }
    }

    return material;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Finally, and this is hacky, we assing the current material and pass index to the found stage.&lt;!-- raw HTML omitted --&gt;
Once we have the real Render Pipeline/Graph working, we will use another dispatching mechanism.&lt;/p&gt;
&lt;h1 id=&#34;rendering-of-a-material&#34;&gt;Rendering of a Material&lt;/h1&gt;
&lt;p&gt;After all of this we finally have created a Material.&lt;!-- raw HTML omitted --&gt;
But how can we render it ?&lt;!-- raw HTML omitted --&gt;
The magic here happens in a &lt;strong&gt;Render Pipeline&lt;/strong&gt;!&lt;!-- raw HTML omitted --&gt;
A Render Pipeline is a list of Render Stages and some resources with it. In this case resources are the &lt;strong&gt;render targets&lt;/strong&gt; and the &lt;strong&gt;buffers&lt;/strong&gt; that are shared amongst &lt;strong&gt;Stages&lt;/strong&gt; (and Render Systems in the future).&lt;!-- raw HTML omitted --&gt;
Resources are inside a &lt;strong&gt;Shader Resources Database&lt;/strong&gt; and they can be retrieved using a &lt;strong&gt;Shader Resource Lookup&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;Each &lt;strong&gt;Render Stage&lt;/strong&gt; has defined a list of input and output textures plus some resize data. This data is needed to recreate textures when a resize event arrives if needed, or change size if an option is changed (like a Shadow Map resolution option).&lt;!-- raw HTML omitted --&gt;
As everthing in this articles, this is primordial and simple, but I think is a very good start, especially from a mindset perspective.&lt;/p&gt;
&lt;p&gt;In this simple scenario we render 1 material only, and normally it simply 1 &lt;em&gt;Material Pass&lt;/em&gt; for each &lt;em&gt;Render Stage Pass&lt;/em&gt;, rendering either using a fullscreen quad or through compute.&lt;/p&gt;
&lt;p&gt;There are 2 pipelines, both simple and used as a test, one is for a &lt;em&gt;ShaderToy&lt;/em&gt; shader that I use as test, the other as a compute only pipeline. They are both hardcoded and created at the beginning of the &lt;em&gt;Material Application&lt;/em&gt;, but as said before, it should be data-driven and reloadable to have great rendering power.&lt;/p&gt;
&lt;h2 id=&#34;rendering-of-a-pipeline&#34;&gt;Rendering of a Pipeline&lt;/h2&gt;
&lt;p&gt;The code is simple:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;void RenderPipeline::render( CommandBuffer* commands ) {

    for ( size_t i = 0; i &amp;lt; string_hash_length( name_to_stage ); i++ ) {

        RenderStage* stage = name_to_stage[i].value;
        stage-&amp;gt;begin( commands );
        stage-&amp;gt;render( commands );
        stage-&amp;gt;end( commands );
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;We cycle through each stage and render.&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;void RenderStage::begin( CommandBuffer* commands ) {
    commands-&amp;gt;begin_submit( 0 );
    commands-&amp;gt;begin_pass( render_pass );
    commands-&amp;gt;set_viewport( { 0, 0, (float)current_width, (float)current_height, 0.0f, 1.0f } );
    if ( clear_rt ) {
        commands-&amp;gt;clear( clear_color[0], clear_color[1], clear_color[2], clear_color[3] );
    }
    commands-&amp;gt;end_submit();
    // Set render stage states (depth, alpha, ...)
}

&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Before rendering anything this code will bind the correct FBO/Render Targets, clear and set viewport and set render states.&lt;!-- raw HTML omitted --&gt;
After this we are ready to render the actual stage. In this simple implementation we have only 3 type of stages: Compute, Post and Swapchain.&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;p&gt;They are very simple and similar, like this:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;commands-&amp;gt;begin_submit( pass_index );
commands-&amp;gt;bind_pipeline( shader_instance.pipeline );
commands-&amp;gt;bind_resource_list( &amp;amp;shader_instance.resource_lists[0], shader_instance.num_resource_lists );
commands-&amp;gt;draw( graphics::TopologyType::Triangle, 0, 3 );
commands-&amp;gt;end_submit();
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Set the pipeline, bind all the different resource lists and issue the draw (in this case a full screen triangle).&lt;/p&gt;
&lt;h1 id=&#34;included-in-the-code&#34;&gt;Included in the code&lt;/h1&gt;
&lt;h2 id=&#34;material-application&#34;&gt;Material application&lt;/h2&gt;
&lt;p&gt;I just added a simple Material Application to render the content of one of those simple shaders.&lt;/p&gt;
&lt;p&gt;Honestly not very happy about the code quality - and you can see why trying to add big features like memory management or multi-threading is a no-go.&lt;/p&gt;
&lt;p&gt;The application let you switch between &lt;strong&gt;materials&lt;/strong&gt; by right clicking on the &lt;strong&gt;.hmt&lt;/strong&gt; file.&lt;!-- raw HTML omitted --&gt;
The whole purpose is to explore with the given code a couple of materials and their dependencies.&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.shadertoy.com/view/XlfGRj&#34;&gt;Starnest&lt;/a&gt; is a shader by the amazing &lt;a href=&#34;https://www.deviantart.com/fractkali&#34;&gt;&lt;strong&gt;Pablo Roman Andrioli&lt;/strong&gt;&lt;/a&gt;, so all credits are to him! I wanted something beautiful to show in this simple example from ShaderToy.&lt;/p&gt;
&lt;h1 id=&#34;conclusions-and-some-thoughts&#34;&gt;Conclusions and some thoughts&lt;/h1&gt;
&lt;p&gt;We added a simple material system based on our HFX language.&lt;!-- raw HTML omitted --&gt;
Interestingly enough code generation is used much less - if almost nothing - instead of serializing data into files and using them.&lt;!-- raw HTML omitted --&gt;
As stated in the other articles, the goal is to have a parsing and code generation knowledge under your belt, and understand when it is time to use it!&lt;!-- raw HTML omitted --&gt;
We also introduced a lot of connections to other topics that are lengthy enough - like resource management - that need more time and dedication to properly be explored.&lt;!-- raw HTML omitted --&gt;
I am continuing working on this until it will become my &lt;em&gt;rendering explorer&lt;/em&gt; - a tool I can use to easily explore ideas, much like &lt;strong&gt;ShaderToy&lt;/strong&gt; but in an even more powerful way.&lt;!-- raw HTML omitted --&gt;
How ?&lt;!-- raw HTML omitted --&gt;
In the next article we will explore the final piece of the puzzle, and then we will probably start iterating and improving on what we have!&lt;!-- raw HTML omitted --&gt;
We will see how we can describe a frame and the rendering dependencies in an easy way, especially if done since the beginning, and how much having that knowledge upfront is GREAT to work on rendering.&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;p&gt;I am honestly not happy about the overall architecture though - here you have an example of &lt;em&gt;exploring code&lt;/em&gt; - code written to explore a specific subject, and after venturing more into it you want to rewrite it.&lt;!-- raw HTML omitted --&gt;
To properly rewrite it you need to create solid foundations - namely &lt;strong&gt;Memory Management, Multi-Threading, Basic Data Structures, &amp;hellip;&lt;/strong&gt; and choose to pick your battles!&lt;/p&gt;
&lt;p&gt;This is a huge lesson: pick your battles, choose what to concentrate on.&lt;!-- raw HTML omitted --&gt;
These articles are more towards code generation and rendering, but defining the constraints of the articles helps in narrowing down what to do.&lt;!-- raw HTML omitted --&gt;
If, as I would like, you want to use this code to evolve into something like a &amp;lsquo;desktop&amp;rsquo; Shadertoy, then you can&amp;rsquo;t ignore all the foundational topics.&lt;!-- raw HTML omitted --&gt;
On the other end if you just quickly want to experiment with those topics, this should suffice.&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;p&gt;I have two paths here: rewriting most of this code with a solid foundations, and delaying a RenderPipeline/Graph article, or finishing with this architecture and then re-write everything with the &amp;lsquo;desktop Shadertoy&amp;rsquo;.&lt;!-- raw HTML omitted --&gt;
Again, pick your battles :)&lt;/p&gt;
&lt;p&gt;As always, please comment, feedback, share!&lt;!-- raw HTML omitted --&gt;
I really hope soon there will be some &lt;em&gt;rendering joy&lt;/em&gt;!&lt;/p&gt;
&lt;p&gt;Gabriel&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Writing a Shader Effect Language Part 2</title>
      <link>https://jorenjoestar.github.io/post/writing_shader_effect_language_2/</link>
      <pubDate>Wed, 11 Sep 2019 00:42:13 -0400</pubDate>
      
      <guid>https://jorenjoestar.github.io/post/writing_shader_effect_language_2/</guid>
      <description>&lt;h1 id=&#34;overview&#34;&gt;Overview&lt;/h1&gt;
&lt;p&gt;Data Driven Rendering Series:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;https://jorenjoestar.github.io/post/writing_shader_effect_language_1/&#34;&gt;https://jorenjoestar.github.io/post/writing_shader_effect_language_1/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://jorenjoestar.github.io/post/writing_shader_effect_language_2/&#34;&gt;https://jorenjoestar.github.io/post/writing_shader_effect_language_2/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://jorenjoestar.github.io/post/writing_shader_effect_language_3/&#34;&gt;https://jorenjoestar.github.io/post/writing_shader_effect_language_3/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://jorenjoestar.github.io/post/data_driven_rendering_pipeline/&#34;&gt;https://jorenjoestar.github.io/post/data_driven_rendering_pipeline/&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;In &lt;a href=&#34;https://jorenjoestar.github.io/post/writing_shader_effect_language_1/&#34;&gt;Part 1 of this series&lt;/a&gt; we created a simple &lt;em&gt;language&lt;/em&gt; to work as &amp;lsquo;shader effect&amp;rsquo; - a shader language superset to make our life easier, by adding missing features.&lt;!-- raw HTML omitted --&gt;
The fact that there is not an industry standard for a shader effect language leads to either hand-crafted (and secret) languages, or to hardcoded permutations, or to other gray-area solutions.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;(Personal though: part of me would like to help in contributing to the creation of a standard through these articles and code.)&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;What is the &lt;strong&gt;goal&lt;/strong&gt; of this article ?&lt;/p&gt;
&lt;p&gt;The &lt;strong&gt;goal&lt;/strong&gt; is to enrich the &lt;strong&gt;HFX language&lt;/strong&gt; to generate more code possible and/or bake data for us, namely:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Shader constants generation&lt;/li&gt;
&lt;li&gt;Shader resource bindings&lt;/li&gt;
&lt;li&gt;Render states (depth stencil, blend, rasterization)&lt;/li&gt;
&lt;li&gt;Render pass hints for a future framegraph&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;We will see Render States and Render Pass hints in a following article, because this is an already lengthy article!&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;I hope that by now the way of adding an identifier, parsing it and generating code is clearer.&lt;!-- raw HTML omitted --&gt;
In this article we will focus more on the features than anything else, even though I will put a lot of code still.&lt;!-- raw HTML omitted --&gt;
But before that, we need to have a big addition to our example: a rendering API!&lt;!-- raw HTML omitted --&gt;
We will use this as target of our code generation, and it will be an amazing example to see something working.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Maybe this will spark a new FX Composer ?&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;This article will be divided in 2 parts.&lt;!-- raw HTML omitted --&gt;
Part 1 of this article will talk about the rendering API.&lt;!-- raw HTML omitted --&gt;
Part 2 will be about the extended HFX language.&lt;!-- raw HTML omitted --&gt;
If you are not interested in that, jump to part 2 of this article.&lt;/p&gt;
&lt;h1 id=&#34;part-1-adding-a-low-level-rendering-api&#34;&gt;Part 1: adding a low-level rendering API&lt;/h1&gt;
&lt;p&gt;Writing articles on rendering without some sort of API to use is tricky.&lt;!-- raw HTML omitted --&gt;
Creating a language to speed up data driven rendering, either for generating code and/or for baking data &lt;em&gt;needs&lt;/em&gt; a target API.&lt;!-- raw HTML omitted --&gt;
The main idea is to have an abstract API to map more easily rendering concepts instead of losing ourselves in specific API needs.&lt;/p&gt;
&lt;h2 id=&#34;the-search-for-an-abstract-api&#34;&gt;The search for an abstract API&lt;/h2&gt;
&lt;p&gt;The first thing to do is to search for an existing abstract API.&lt;!-- raw HTML omitted --&gt;
I have few criteria in mind:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Simple and clear interface&lt;/li&gt;
&lt;li&gt;Compact and clear code&lt;/li&gt;
&lt;li&gt;Vulkan and D3D12 interface&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;With those in mind, I found 2 alternatives: &lt;a href=&#34;https://github.com/bkaradzic/bgfx&#34;&gt;BGFX&lt;/a&gt; and &lt;a href=&#34;https://github.com/floooh/sokol&#34;&gt;Sokol&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;I am an honest fan of both, they are brilliant, robust and well written.&lt;!-- raw HTML omitted --&gt;
But for the purpose of these articles, sadly they miss my search criteria.&lt;!-- raw HTML omitted --&gt;
There is also a &lt;strong&gt;huge disclaimer&lt;/strong&gt; here: I used them too little, so it is possible I overlooked the usage of them.&lt;!-- raw HTML omitted --&gt;
I will be more than glad to use either instead of my toy API!&lt;!-- raw HTML omitted --&gt;
I respect the developers and the library a lot, they are doing an amazing job!&lt;!-- raw HTML omitted --&gt;
But we are handcrafting something, and to properly do that I personally need to know deeply the code. And I am not.&lt;/p&gt;
&lt;p&gt;BGFX is very complete, but the interface is a little confusing for me, possibly because I never used it but just read the code few times.&lt;!-- raw HTML omitted --&gt;
The main reason I chose not to use it is because the interface is missing the resource interface like Vulkan and D3D12 (DescriptorSets, &amp;hellip;), otherwise it would have been an amazing choice.&lt;/p&gt;
&lt;p&gt;Sokol is also very good, I love the code and the simple interface.&lt;!-- raw HTML omitted --&gt;
Two main problems here: again no Vulkan/D3D12 resource interface, and in this case a different target: it does not support compute shaders.&lt;/p&gt;
&lt;p&gt;Again, I want to make it clear: I am not saying these are not good libraries. They are amazing. They just don&amp;rsquo;t fit my search criteria, plus I LOVE to work on rendering architecture. Well actually, it is my favourite job!&lt;/p&gt;
&lt;p&gt;So kudos to them (I also wrote to Andre Weissflog to ask for compute shader support, but it is not in his plans for now) but we are making a different choice.&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;p&gt;If you ever find anything that I write useful guys, please let me know!&lt;/p&gt;
&lt;h2 id=&#34;hydra-graphics-design-principles&#34;&gt;Hydra Graphics: design principles&lt;/h2&gt;
&lt;p&gt;Small trivia: the name comes from my first ever graphics engine written in 2006 (I think), after devouring 3D Game Engine Design by Dave Eberly. I already knew I would write many engines and I would learn and grow stronger from every of them, so I chose the name Hydra from the Greek mythology monster.&lt;!-- raw HTML omitted --&gt;
The other name would have been Phoenx engine, but I remember finding already some tech with that name.&lt;/p&gt;
&lt;p&gt;Anyway, design principles!&lt;!-- raw HTML omitted --&gt;
I really loved the interface of Sokol, and often I used something similar by myself.&lt;!-- raw HTML omitted --&gt;
I opted for a pair of header/implementation files as the only needed files.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;The backend is OpenGL for now, just because I have a working implementation in my indie project that works with pretty complex rendering, and I can use that as reference.&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;interface&#34;&gt;Interface&lt;/h3&gt;
&lt;p&gt;Rendering in general is a matter of creating, modifying and combining &lt;em&gt;resources&lt;/em&gt;.&lt;!-- raw HTML omitted --&gt;
There are mainly 2 classes that do all the rendering work:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Device&lt;/li&gt;
&lt;li&gt;Command Buffer&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;em&gt;The Device is responsible for creation, destruction, modification and query of the resources.&lt;!-- raw HTML omitted --&gt;
The Command Buffer is responsible for the usage of resources for rendering.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;The obvious fundamental concept is &lt;strong&gt;resource&lt;/strong&gt;.&lt;!-- raw HTML omitted --&gt;
A &lt;strong&gt;resource&lt;/strong&gt; is handled externally through handles, can be created using &lt;strong&gt;creation&lt;/strong&gt; structs and has both a common and an API-specific representation.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Buffers&lt;/strong&gt; are specialized in vertex/index/constant/&amp;hellip; depending on their creation parameters.&lt;/p&gt;
&lt;p&gt;This is a small example on creation/usage/destruction of a resource.&lt;!-- raw HTML omitted --&gt;
First, we can create a texture:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;graphics::TextureCreation first_rt = {};
first_rt.width = 512;
first_rt.height = 512;
first_rt.render_target = 1;
first_rt.format = graphics::TextureFormat::R8G8B8A8_UNORM;

TextureHandle render_target = gfx_device.create_texture( first_rt );
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Next we can create a command buffer:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;CommandBuffer* commands = gfx_device.get_command_buffer( graphics::QueueType::Graphics, 1024 );
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Skipping other creations, we bind resources and add the commands:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;commands-&amp;gt;bind_pipeline( first_graphics_pipeline );
commands-&amp;gt;bind_resource_set( gfx_resources );
commands-&amp;gt;bind_vertex_buffer( gfx_device.get_fullscreen_vertex_buffer() );
commands-&amp;gt;draw( graphics::TopologyType::Triangle, 0, 3 );
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;At this point we can execute the command buffer to draw.&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;gfx_device.execute_command_buffer( commands );
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Updating a resource can be done like that:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;hydra::graphics::MapBufferParameters map_parameters = { buffer.handle, 0, 0 };
LocalConstants* buffer_data = (LocalConstants*)device.map_buffer( map_parameters );
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Everything uses structs to perform creation/updates.&lt;!-- raw HTML omitted --&gt;
Nothing new, but I always loved this design.&lt;/p&gt;
&lt;h3 id=&#34;resource-layout-and-resource-lists&#34;&gt;Resource layout and resource lists&lt;/h3&gt;
&lt;p&gt;I wanted to bring the Vulkan/D3D12 resource interface as first class citizens, and remove completely old concepts (like single constants, render states as single objects, single bind of a resource) and add new ones: resource layout, resource lists and command buffers. Well command buffers are not new, but &lt;em&gt;finally&lt;/em&gt; you can draw only with those!&lt;/p&gt;
&lt;p&gt;In Vulkan/D3D12 you can bind resources through the usage of &lt;em&gt;sets&lt;/em&gt;: basically tables that contains the resources used.&lt;!-- raw HTML omitted --&gt;
This is a welcomed difference from previous APIs, and I think it is a concept not too hard to grasp but very useful to have it explicit.&lt;/p&gt;
&lt;p&gt;The first thing to define is the &lt;strong&gt;resource layout&lt;/strong&gt; describes the layout of a set of resources.&lt;!-- raw HTML omitted --&gt;
For example, if we have a material that uses Albedo and Normals textures and a constant buffer, the layout will contain all the informations about that (like the type, the GPU registers and so on).&lt;!-- raw HTML omitted --&gt;
This though still does not contain the resources themselves!&lt;!-- raw HTML omitted --&gt;
Enter &lt;strong&gt;resource list&lt;/strong&gt;.&lt;!-- raw HTML omitted --&gt;
A &lt;strong&gt;resource list&lt;/strong&gt; is a list of actual resources &lt;em&gt;relative to a layout&lt;/em&gt;.&lt;!-- raw HTML omitted --&gt;
It sets resources using a layout.&lt;/p&gt;
&lt;p&gt;From now on, when we draw we can bind &lt;em&gt;one or more resource lists&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;In Vulkan lingo, the &lt;strong&gt;resource layout&lt;/strong&gt; is called &lt;strong&gt;descriptor set layout&lt;/strong&gt;, and a &lt;strong&gt;resource list&lt;/strong&gt; is a &lt;strong&gt;descriptor set&lt;/strong&gt;.&lt;!-- raw HTML omitted --&gt;
Here are a couple of articles for the Vulkan side:&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://vulkan.lunarg.com/doc/view/1.0.33.0/linux/vkspec.chunked/ch13s02.html&#34;&gt;Official Vulkan Documentation on Descriptor Layouts and Sets&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://software.intel.com/en-us/articles/api-without-secrets-introduction-to-vulkan-part-6&#34;&gt;Intel API Without Secrets Part 6&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Similarly in D3D12 there are Root Tables and Descriptor Tables. The concepts do no map 1 to 1 but they are pretty similar:&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://docs.microsoft.com/en-us/windows/win32/direct3d12/using-descriptor-tables&#34;&gt;D3D12 Descriptor Tables&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;I tried to map these concepts using different words that would make more sense to me, so from &lt;em&gt;Descriptor Set&lt;/em&gt; or &lt;em&gt;Root Table&lt;/em&gt; it became &lt;em&gt;Resource List&lt;/em&gt; and &lt;em&gt;Resource Layout&lt;/em&gt;.&lt;/p&gt;
&lt;h3 id=&#34;pipelines&#34;&gt;Pipelines&lt;/h3&gt;
&lt;p&gt;Finally a pipeline is the complete description of what is needed by the GPU to draw something on the screen (or to use a Compute Shader for any other purpose).&lt;!-- raw HTML omitted --&gt;
Basically a pipeline must fill all the informations for all the GPU stages like this (thanks to &lt;a href=&#34;https://renderdoc.org&#34;&gt;RenderDoc&lt;/a&gt;):&lt;/p&gt;






&lt;figure&gt;

  &lt;a data-fancybox=&#34;&#34; href=&#34;RenderDoc_Pipeline.png&#34; &gt;

&lt;img src=&#34;RenderDoc_Pipeline.png&#34; &gt;
&lt;/a&gt;


&lt;figcaption data-pre=&#34;Figure &#34; data-post=&#34;:&#34; &gt;
  &lt;h4&gt;RenderDoc Pipeline&lt;/h4&gt;
  
&lt;/figcaption&gt;

&lt;/figure&gt;

&lt;p&gt;What once was setup individually now is all in one place (reflecting what happened behind the scene, into the driver).&lt;!-- raw HTML omitted --&gt;
DepthStencil, AlphaBlend, Rasterization, Shaders, all must be defined here.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;In the currrent implementation of the graphics-API a lot of states are still missing!&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;Now that we say the basic principles of the target rendering API, we can finally concentrate on the new freatures of HFX.&lt;/p&gt;
&lt;h1 id=&#34;part-2-forging-the-hfx-language-features&#34;&gt;Part 2: forging the HFX language features&lt;/h1&gt;
&lt;p&gt;Our HFX language needs some properties to be added but first there is a change: HFX will generate a binary version to embed all the informations needed to create a shader.&lt;/p&gt;
&lt;h2 id=&#34;hfx-evolution-what-files-are-generated-&#34;&gt;HFX evolution: what files are generated ?&lt;/h2&gt;
&lt;p&gt;In the previous article, we used a single HFX file to generate multiple glsl files, ready to be used by any OpenGL renderer:&lt;/p&gt;






&lt;figure&gt;

  &lt;a data-fancybox=&#34;&#34; href=&#34;HFX_Shader_Gen.png&#34; &gt;

&lt;img src=&#34;HFX_Shader_Gen.png&#34; &gt;
&lt;/a&gt;


&lt;figcaption data-pre=&#34;Figure &#34; data-post=&#34;:&#34; &gt;
  &lt;h4&gt;Shader Generation&lt;/h4&gt;
  
&lt;/figcaption&gt;

&lt;/figure&gt;

&lt;p&gt;Remembering the article on &lt;a href=&#34;https://jorenjoestar.github.io/post/writing_a_simple_code_generator/&#34;&gt;Hydra Data Format&lt;/a&gt;, we instead were generating an header file.&lt;!-- raw HTML omitted --&gt;
For our needs, we will generate an embedded HFX (binary HFX) AND a C++ header:&lt;/p&gt;






&lt;figure&gt;

  &lt;a data-fancybox=&#34;&#34; href=&#34;HFX_Gen.png&#34; &gt;

&lt;img src=&#34;HFX_Gen.png&#34; &gt;
&lt;/a&gt;


&lt;figcaption data-pre=&#34;Figure &#34; data-post=&#34;:&#34; &gt;
  &lt;h4&gt;Binary and Header Generation&lt;/h4&gt;
  
&lt;/figcaption&gt;

&lt;/figure&gt;

&lt;p&gt;What is the next step for HFX ?&lt;!-- raw HTML omitted --&gt;
For shader generation, we want ideally to load a HFX file without having to manually stick together the single shader files, and that is why the first step is to create &lt;strong&gt;embedded HFX files&lt;/strong&gt;.&lt;!-- raw HTML omitted --&gt;
This will contain all the information to create a shader, and this includes also the resource layouts.&lt;/p&gt;
&lt;p&gt;For constant handling, we want to have UI generated and easy update on the gpu. We want to automate these things.&lt;!-- raw HTML omitted --&gt;
This can be done in a more code-generated way or by generating data.&lt;/p&gt;
&lt;p&gt;If we abstract the problem, all these articles are about understanding how you want to generate code or data to maximise iteration time, performances and control.&lt;!-- raw HTML omitted --&gt;
By moving the HFX to being binary, we are effectively generating &lt;em&gt;data&lt;/em&gt; used by the renderer.&lt;!-- raw HTML omitted --&gt;
For the shader UI, we can do both: generate code or create data. We will see the generated code part here.&lt;/p&gt;
&lt;p&gt;Let&amp;rsquo;s see briefly the internals of the &lt;strong&gt;Embedded HFX&lt;/strong&gt; file format:&lt;/p&gt;
&lt;h3 id=&#34;embedded-hfx&#34;&gt;Embedded HFX&lt;/h3&gt;
&lt;p&gt;As a Recap, when &lt;em&gt;parsing&lt;/em&gt; HFX we store some informations.&lt;/p&gt;
&lt;p&gt;First is the CodeFragment, including also (spoiler!) the addition of resources for the sake of this article:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;// C++
//
struct CodeFragment {

    struct Resource {
        
        hydra::graphics::ResourceType::Enum type;
        StringRef               name;

    }; // struct Resource

    std::vector&amp;lt;StringRef&amp;gt;      includes;
    std::vector&amp;lt;Stage&amp;gt;          includes_stage;     // Used to separate which include is in which shader stage.
    std::vector&amp;lt;Resource&amp;gt;       resources;          // Used to generate the layout table.

    StringRef                   name;
    StringRef                   code;
    Stage                       current_stage       = Stage::Count;
    uint32_t                    ifdef_depth         = 0;
    uint32_t                    stage_ifdef_depth[Stage::Count];

}; // struct CodeFragment
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The rest is unchanged from the previous article.&lt;!-- raw HTML omitted --&gt;
We have basically code and includes to bake the final shader.&lt;!-- raw HTML omitted --&gt;
Remember, we are handling GLSL in these examples!&lt;/p&gt;
&lt;p&gt;Next is the Pass:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;// C++
//
struct Pass {

    StringRef                   name;
    struct ShaderStage {

        const CodeFragment*     code                = nullptr;
        Stage                   stage               = Stage::Count;

    }; // struct ShaderStage

    StringRef                   name;
    std::vector&amp;lt;ShaderStage&amp;gt;    shader_stages;

}; // struct Pass
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Nothing changed here.&lt;!-- raw HTML omitted --&gt;
A pass is a container of one of more shaders.&lt;!-- raw HTML omitted --&gt;
In general we will use the term &lt;em&gt;shader state&lt;/em&gt; to describe the shaders that needs to be bound to the pipeline.&lt;!-- raw HTML omitted --&gt;
Most common are the couple Vertex and Fragment shaders, or the Compute by itself.&lt;/p&gt;
&lt;p&gt;Last is the Shader itself:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;// C++
//
struct Shader {

    StringRef                   name;

    std::vector&amp;lt;Pass*&amp;gt;          passes;
    std::vector&amp;lt;Property*&amp;gt;      properties;

}; // struct Shader
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Being just a collection of passes.&lt;!-- raw HTML omitted --&gt;
Again we are seeing the properties here, that I will talk later on in the article.&lt;/p&gt;
&lt;p&gt;These will be used to &amp;lsquo;bake&amp;rsquo; data into a &amp;lsquo;bhfx&amp;rsquo; (binary HFX) file.&lt;/p&gt;
&lt;h3 id=&#34;bhfx-layout&#34;&gt;BHFX layout&lt;/h3&gt;
&lt;p&gt;In order to maximise efficiency, we are packing the data in the way we will use it.&lt;!-- raw HTML omitted --&gt;
The file is divided in two main sections: common and passes.&lt;!-- raw HTML omitted --&gt;
The overall layout is as follows:&lt;/p&gt;






&lt;figure&gt;

  &lt;a data-fancybox=&#34;&#34; href=&#34;BHFX_Format.png&#34; &gt;

&lt;img src=&#34;BHFX_Format.png&#34; &gt;
&lt;/a&gt;

&lt;/figure&gt;

&lt;p&gt;The trick is to have the offset for each section easy to access.&lt;/p&gt;
&lt;p&gt;The &lt;em&gt;pass section&lt;/em&gt; contains several informations as following:&lt;/p&gt;






&lt;figure&gt;

  &lt;a data-fancybox=&#34;&#34; href=&#34;BHFX_Pass.png&#34; &gt;

&lt;img src=&#34;BHFX_Pass.png&#34; &gt;
&lt;/a&gt;

&lt;/figure&gt;

&lt;p&gt;As we will see later we include shaders, resources layout and other data based on our target API (Hydra Graphics).&lt;/p&gt;
&lt;h3 id=&#34;writing-the-bhfx-file&#34;&gt;Writing the BHFX file&lt;/h3&gt;
&lt;p&gt;To write our file, we need to parse the HFX file.&lt;!-- raw HTML omitted --&gt;
A quick code could be something like this:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;// C++
//

...

char* text = ReadEntireFileIntoMemory( &amp;quot;..\\data\\SimpleFullscreen.hfx&amp;quot;, nullptr );
initLexer( &amp;amp;lexer, (char*)text, data_buffer );

hfx::initParser( &amp;amp;effect_parser, &amp;amp;lexer );
hfx::generateAST( &amp;amp;effect_parser );

    
hfx::initCodeGenerator( &amp;amp;hfx_code_generator, &amp;amp;effect_parser, 4096, 5 );

hfx::compileShaderEffectFile( &amp;amp;hfx_code_generator, &amp;quot;..\\data\\&amp;quot;, &amp;quot;SimpleFullscreen.bhfx&amp;quot; );
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Here we are parsing the file (generateAST) and then using that to &lt;em&gt;compile&lt;/em&gt; our shader effect file. This is where the magic happens.&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;// C++
//
void compileShaderEffectFile( CodeGenerator* code_generator, const char* path, const char* filename ) {
    // Create the output file
    FILE* output_file;

    // Alias the StringBuffer for better readability.
    StringBuffer&amp;amp; filename_buffer = code_generator-&amp;gt;string_buffers[0];

    // Concatenate name
    filename_buffer.clear();
    filename_buffer.append( path );
    filename_buffer.append( filename );
    fopen_s( &amp;amp;output_file, filename_buffer.data, &amp;quot;wb&amp;quot; );

    if ( !output_file ) {
        printf( &amp;quot;Error opening file. Aborting. \n&amp;quot; );
        return;
    }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Typical file creation preamble.&lt;!-- raw HTML omitted --&gt;
Concatenate the file using the StringBuffer, and try to create it.&lt;/p&gt;
&lt;p&gt;Remember that overall the file structure is:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;File header&lt;/li&gt;
&lt;li&gt;Pass offset list&lt;/li&gt;
&lt;li&gt;Pass sections&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Let&amp;rsquo;s start with the file header:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;    const uint32_t pass_count = (uint32_t)code_generator-&amp;gt;parser-&amp;gt;passes.size();
    
    ShaderEffectFile shader_effect_file;
    shader_effect_file.num_passes = pass_count;    

    fwrite( &amp;amp;shader_effect_file, sizeof(ShaderEffectFile), 1, output_file );
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;In this case we are writing straight to the file, because it is an in-order operation with the file layout.&lt;!-- raw HTML omitted --&gt;
For the rest of the file writing we will need to use String Buffers to accumulate data out-of-order and then write the file in the correct order.&lt;!-- raw HTML omitted --&gt;
Think of the &lt;em&gt;Pass Offset List&lt;/em&gt;: to calculate the offsets we need to know the size of the passes. To know the size we need to finalize the pass data. To finalize the pass data we need to finalize shaders, and that means adding the includes.&lt;/p&gt;
&lt;p&gt;Again for code clarity I use aliases like this:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;    StringBuffer&amp;amp; code_buffer = code_generator-&amp;gt;string_buffers[1];
    StringBuffer&amp;amp; pass_offset_buffer = code_generator-&amp;gt;string_buffers[2];
    StringBuffer&amp;amp; shader_offset_buffer = code_generator-&amp;gt;string_buffers[3];
    StringBuffer&amp;amp; pass_buffer = code_generator-&amp;gt;string_buffers[4];
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Let&amp;rsquo;s continue.&lt;!-- raw HTML omitted --&gt;
We start tracking the pass section memory offset knowing that it will be after the &lt;em&gt;header&lt;/em&gt; and the pass offset list:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;    pass_offset_buffer.clear();
    pass_buffer.clear();

    // Pass memory offset starts after header and list of passes offsets.
    uint32_t pass_offset = sizeof( ShaderEffectFile ) + sizeof(uint32_t) * pass_count;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Now into the most interesting part. We will avoid talking about the resource layout part, that will be added later.&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;    // Pass Section:
    // ----------------------------------------------------------------------------------------
    // Shaders count | Name | Shader Offset+Count List | Shader Code 0, Shader Code 1
    // ----------------------------------------------------------------------------------------

    ShaderEffectFile::PassHeader pass_header;

    for ( uint32_t i = 0; i &amp;lt; pass_count; i++ ) {

        pass_offset_buffer.append( &amp;amp;pass_offset, sizeof( uint32_t ) );

        const Pass&amp;amp; pass = code_generator-&amp;gt;parser-&amp;gt;passes[i];

        const uint32_t pass_shader_stages = (uint32_t)pass.shader_stages.size();
        const uint32_t pass_header_size = pass_shader_stages * sizeof( ShaderEffectFile::Chunk ) + sizeof( ShaderEffectFile::PassHeader );
        uint32_t current_shader_offset = pass_header_size;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;We start iterating the passes and calculate the shader offset.&lt;!-- raw HTML omitted --&gt;
Shader Chunks (the actual shader code) are written after the Pass Header and the dynamic list of shader chunk offset and size.&lt;!-- raw HTML omitted --&gt;
Next we will calculate the offsets of the single shaders AFTER we finalize the code - that means after the includes are added!&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;        shader_offset_buffer.clear();
        code_buffer.clear();

        for ( size_t s = 0; s &amp;lt; pass.shader_stages.size(); ++s ) {
            const Pass::ShaderStage shader_stage = pass.shader_stages[s];

            appendFinalizedCode( path, shader_stage.stage, shader_stage.code, filename_buffer, code_buffer, true, constants_buffer );
            updateOffsetTable( &amp;amp;current_shader_offset, pass_header_size, shader_offset_buffer, code_buffer );
        }

        // Update pass offset
        pass_offset += code_buffer.current_size + shader_offset;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;At this point we have code_buffer containing all the shaders of the pass one after another (null terminated) and we can update the pass offset for the next pass.&lt;!-- raw HTML omitted --&gt;
We also calculated the single shader offsets with the &lt;em&gt;updateOffsetTable&lt;/em&gt; method in shader_offset_buffer.&lt;!-- raw HTML omitted --&gt;
We need to finalize the Pass Header and then we can merge the pass memory in one block and proceed to the next pass:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;        // Fill Pass Header
        copy( pass.name, pass_header.name, 32 );
        pass_header.num_shader_chunks = pass.num_shaders;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This is a very IMPORTANT part.&lt;!-- raw HTML omitted --&gt;
Merge in the pass_buffer all the pass section currently calculated: pass header, the single shader code offsets and the shader code itself.&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;        pass_buffer.append( (void*)&amp;amp;pass_header, sizeof( ShaderEffectFile::PassHeader ) );
        pass_buffer.append( shader_offset_buffer );
        pass_buffer.append( code_buffer );
    }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;After we finished with all the passes, we have 2 buffers: one containing the pass offset list, the other the pass sections.&lt;!-- raw HTML omitted --&gt;
We can write them off in the correct order finally and close the file:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;    fwrite( pass_offset_buffer.data, pass_offset_buffer.current_size, 1, output_file );
    fwrite( pass_buffer.data, pass_buffer.current_size, 1, output_file );
    
    fclose( output_file );
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;We can see &lt;em&gt;why&lt;/em&gt; we chose this format when looking at the code to actually create a &lt;em&gt;shader state&lt;/em&gt;.&lt;!-- raw HTML omitted --&gt;
First of all this is the struct to create a shader state:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;// hydra_graphics.h
//
struct ShaderCreation {

    struct Stage {

        ShaderStage::Enum           type                = ShaderStage::Compute;
        const char*                 code                = nullptr;

    }; // struct Stage

    const Stage*                    stages              = nullptr;
    const char*                     name                = nullptr;

    uint32_t                        stages_count        = 0;

}; // struct ShaderCreation
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;It is very simple, each stage has a code and type.&lt;!-- raw HTML omitted --&gt;
A shader state can have one or more stages.&lt;!-- raw HTML omitted --&gt;
This was already the case in OpenGL - compiling shaders and linking them - so the interface is similar - but it maps well to Vulkan/D3D12 as well, in which the &lt;em&gt;Pipeline State&lt;/em&gt;, that describe almost everything the GPU needs to draw, needs an unique set of vertex/fragment/compute shaders.&lt;!-- raw HTML omitted --&gt;
Anyway, we embed this data already in the &lt;em&gt;binary HFX file&lt;/em&gt;, and thus we can easily create a shader state like this:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;static void compile_shader_effect_pass( hydra::graphics::Device&amp;amp; device, char* hfx_memory, 
                                        uint16_t pass_index, hydra::graphics::ShaderHandle&amp;amp; out_shader ) {
    using namespace hydra;

    // Get pass section memory
    char* pass = hfx::getPassMemory( hfx_memory, pass_index );
    hfx::ShaderEffectFile::PassHeader* pass_header = (hfx::ShaderEffectFile::PassHeader*)pass;

    const uint32_t shader_count = pass_header-&amp;gt;num_shader_chunks;    
    graphics::ShaderCreation::Stage* stages = new graphics::ShaderCreation::Stage[shader_count];

    // Get individual shader code and type
    for ( uint16_t i = 0; i &amp;lt; shader_count; i++ ) {
        hfx::getShaderCreation( shader_count, pass, i, &amp;amp;stages[i] );
    }

    graphics::ShaderCreation first_shader = {};
    first_shader.stages = stages;
    first_shader.stages_count = shader_count;
    first_shader.name = pass_header-&amp;gt;name;

    out_shader = device.create_shader( first_shader );

    delete stages;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Nothing really interesting here, but we read the file in memory and use the offsets we store to access the different sections of the file.&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;p&gt;To access the &lt;em&gt;Pass Section&lt;/em&gt; we first need to read its memory offset and then read from there.&lt;!-- raw HTML omitted --&gt;
Remember from before that the offset is in the list AFTER the ShaderEffectFile header, and it is a single uint32:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;char* getPassMemory( char* hfx_memory, uint32_t index ) {
    
    // Read offset form list after the ShaderEffectFile header.
    const uint32_t pass_offset = *(uint32_t*)(hfx_memory + sizeof( ShaderEffectFile ) + (index * sizeof( uint32_t )));

    return hfx_memory + pass_offset;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;From the &lt;em&gt;pass offset&lt;/em&gt;, the list of shader chunks (that are defined as code offset and size) is right after the &lt;em&gt;pass header&lt;/em&gt;&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;void getShaderCreation( uint32_t shader_count, char* pass_memory, uint32_t index,
                        hydra::graphics::ShaderCreation::Stage* shader_creation ) {

    char* shader_offset_list_start = pass_memory + sizeof( ShaderEffectFile::PassHeader );
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Read the single shader offset and access the memory there:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;    const uint32_t shader_offset = *(uint32_t*)(shader_offset_list_start + (index * sizeof( ShaderEffectFile::Chunk )));
    char* shader_chunk_start = pass_memory + shader_offset;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The baked informations are first the type (as a single char, but called hfx::ShaderEffectFile::ChunkHeader in case we change it) and the actual shader code is right after!&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;    shader_creation-&amp;gt;type = (hydra::graphics::ShaderStage::Enum)(*shader_chunk_start);
    shader_creation-&amp;gt;code = (const char*)(shader_chunk_start + sizeof( hfx::ShaderEffectFile::ChunkHeader ));
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;In this case I chose to bake the file instead of generating a header file - just cause I can reuse this code for every shader effect. I could have generated an header instead of the binary BHFX file, but then including it would mean that you need to recompile at every change.&lt;!-- raw HTML omitted --&gt;
We will see some areas in which we can have both approaches!&lt;/p&gt;
&lt;p&gt;Finally done with the new embedded format, let&amp;rsquo;s see the new features!&lt;/p&gt;
&lt;h2 id=&#34;brainstorming-what-features-are-needed-&#34;&gt;Brainstorming: what features are needed ?&lt;/h2&gt;
&lt;p&gt;We already talked about the features at the beginning of the articles, but let&amp;rsquo;s write them again to refresh our memory:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Shader constants generation&lt;/li&gt;
&lt;li&gt;Shader resource bindings&lt;/li&gt;
&lt;li&gt;Render states (depth stencil, blend, rasterization) &lt;strong&gt;(in the next article)&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;Render pass hints for a future framegraph &lt;strong&gt;(in the next article)&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;There are few articles around this subject, but the most complete is from the amazing guys at &lt;a href=&#34;https://ourmachinery.com/&#34;&gt;OurMachinery&lt;/a&gt;, and in particular &lt;a href=&#34;https://ourmachinery.com/post/the-machinery-shader-system-part-2/&#34;&gt;this article&lt;/a&gt;.&lt;!-- raw HTML omitted --&gt;
These guys does (as always honestly) an amazing job in describing the problem we are facing and the solutions, and how enriching a shader language can make a huge difference in making better rendering (faster iteration time, less error prone, more artist friendly..) so I would suggest to read those articles (and in general any article/presentation/blog post they write!).&lt;/p&gt;
&lt;p&gt;We will go through each feature in depth so get ready!&lt;/p&gt;
&lt;h2 id=&#34;constants-artists-programmers-both-&#34;&gt;Constants: artists, programmers, both ?&lt;/h2&gt;
&lt;p&gt;Constants&amp;hellip;uniforms&amp;hellip;whatever name you choose, they represent the same concept: &lt;em&gt;numerical properties&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;Even if they are a simple concept, still it is hard to make both rendering citizens happy: artists and programmers!&lt;/p&gt;
&lt;p&gt;Artists want tweakable UI, simple variables and fast iteration.&lt;!-- raw HTML omitted --&gt;
Programmers want optimal layout, more CPU calculated variables possible, and ultimate control.&lt;!-- raw HTML omitted --&gt;
How to make them both happy ?&lt;/p&gt;
&lt;p&gt;I brainstormed and designed for few days (well evenings) to solve this problem.&lt;!-- raw HTML omitted --&gt;
One thought that came to me is that artists want to create a &lt;em&gt;material interface&lt;/em&gt;, something they can tweak and change easily, and when you want to quickly prototype something, create and such, you don&amp;rsquo;t want to deal with low-level resource management and such.&lt;!-- raw HTML omitted --&gt;
Let&amp;rsquo;s solve this first: &lt;strong&gt;give artists a simple way of creating a material interface&lt;/strong&gt;!&lt;/p&gt;
&lt;p&gt;After searching for a bit, I chose to use a syntax very similar to Unity ShaderLab. Let&amp;rsquo;s see the HFX (finally!):&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;// .HFX
//
// For the artist: create a material interface.
properties {

    // Using Unity ShaderLab syntax:
    // AORemapMin0(&amp;quot;AORemapMin0&amp;quot;, Range(0.0, 1.0)) = 0.0
    scale(&amp;quot;Scale&amp;quot;, Float) = 32.00
    modulo(&amp;quot;Modulo&amp;quot;, Float) = 2.0
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;We added a new section in the language, named &amp;ldquo;&lt;em&gt;properties&lt;/em&gt;&amp;rdquo;.&lt;!-- raw HTML omitted --&gt;
Why this name ?&lt;!-- raw HTML omitted --&gt;
Because properties contains both &lt;em&gt;numerical properties and textures&lt;/em&gt;!&lt;!-- raw HTML omitted --&gt;
The name makes sense in this way. Naming &amp;lsquo;constants&amp;rsquo; and having also textures, not.&lt;/p&gt;
&lt;p&gt;There are 2 possible &lt;em&gt;outputs&lt;/em&gt; from this, one that is pure code-generation and the other that is more data-driven.
I will dwelve into the code-generation one and talk about the data-driven one in another post.&lt;/p&gt;
&lt;p&gt;There are 3 parts for the generated code of the properties:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Properties UI&lt;/li&gt;
&lt;li&gt;GPU-ready constant buffer&lt;/li&gt;
&lt;li&gt;API-dependant buffer&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;For the Properties UI, we want to generate something like this:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;// C++
struct LocalConstantsUI {

    float                    scale                = 32.000000f;
    float                    modulo                = 2.000000f;

    void reflectMembers() {
        ImGui::InputScalar( &amp;quot;Scale&amp;quot;, ImGuiDataType_Float, &amp;amp;scale);
        ImGui::InputScalar( &amp;quot;Modulo&amp;quot;, ImGuiDataType_Float, &amp;amp;modulo);
    }

    void reflectUI() {
        ImGui::Begin( &amp;quot;LocalConstants&amp;quot; );
        reflectMembers();
        ImGui::End();
    }

}; // struct LocalConstantsUI
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;For the GPU-ready constants, we want to have a both a GPU and a CPU representation like this:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;// C++
//
struct LocalConstants {

    float                    scale                = 32.000000f;
    float                    modulo                = 2.000000f;
    float                    pad_tail[2];

}; // struct LocalConstants

// GLSL
//
layout (std140, binding=7) uniform LocalConstants {

    float                    scale;
    float                    modulo;

    float                    pad[2];

} local_constants;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;And for the API-dependant buffer, we want to create code that takes care of everything for us. This is the real deal here - and something we will revisit in next articles to show some advanced features.&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;void create( hydra::graphics::Device&amp;amp; device ) {

    using namespace hydra;

    graphics::BufferCreation constants_creation = {};
    constants_creation.type = graphics::BufferType::Constant;
    constants_creation.name = &amp;quot;LocalConstants&amp;quot;;
    constants_creation.usage = graphics::ResourceUsageType::Dynamic;

    // NOTE: using LocalConstants struct - is the GPU ready one with padding and such!
    constants_creation.size = sizeof( LocalConstants );
    // Struct is initialized with default values already, so it is safe to copy it to the GPU.
    constants_creation.initial_data = &amp;amp;constants;

    buffer = device.create_buffer( constants_creation );
}

void destroy( hydra::graphics::Device&amp;amp; device ) {

    device.destroy_buffer( buffer );
}

void updateUI( hydra::graphics::Device&amp;amp; device ) {
    // Draw UI
    constantsUI.reflectUI();

    // TODO:
    // Ideally there should be a way to tell if a variable has changed and update only in that case.
    
    // Map buffer to GPU and upload parameters from the UI
    hydra::graphics::MapBufferParameters map_parameters = { buffer.handle, 0, 0 };

    LocalConstants* buffer_data = (LocalConstants*)device.map_buffer( map_parameters );

    if ( buffer_data ) {
        buffer_data-&amp;gt;scale = constantsUI.scale;
        buffer_data-&amp;gt;modulo = constantsUI.modulo;
        device.unmap_buffer( map_parameters );
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;For the sake of the example this could be a possible implementation - but really depends on the rendering API.
Let&amp;rsquo;s quickly check parsing and code-generation.&lt;/p&gt;
&lt;h3 id=&#34;constants-parsing&#34;&gt;Constants Parsing&lt;/h3&gt;
&lt;p&gt;To parse the new &lt;strong&gt;property&lt;/strong&gt; section, there is the new method &lt;code&gt;void declarationProperties( Parser* parser )&lt;/code&gt; that iterates through all properties, and inside that the &lt;code&gt;void declarationProperty( Parser* parser, const StringRef&amp;amp; name )&lt;/code&gt; one.&lt;/p&gt;
&lt;p&gt;We are parsing the following HFX syntax:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;// Syntax
//
identifier(string, identifier[(arguments)]) [= default_value]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;With this is an example:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;// HFX
//
properties {
    scale(&amp;quot;Scale&amp;quot;, Float) = 32.0
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;We will add a simple backtracking to the parsing because of the optional parameters.&lt;!-- raw HTML omitted --&gt;
Let&amp;rsquo;s check the code!&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;inline void declarationProperty( Parser* parser, const StringRef&amp;amp; name ) {
    Property* property = new Property();

    // Cache name
    property-&amp;gt;name = name;

    Token token;

    if ( !expectToken( parser-&amp;gt;lexer, token, Token::Token_OpenParen ) ) {
        return;
    }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;We just parsed the property name and the &amp;lsquo;(&amp;rsquo;. Next is the string containing the UI name:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;    // Advance to the string representing the ui_name
    if ( !expectToken( parser-&amp;gt;lexer, token, Token::Token_String ) ) {
        return;
    }

    property-&amp;gt;ui_name = token.text;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Saved the ui name and then we have the type.&lt;!-- raw HTML omitted --&gt;
Types can be &lt;em&gt;Float, Int, Range, Texture, Vector, Color&lt;/em&gt; and we will simply parse their text and convert it to an enum that we will use in the code generation phase.&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;    if ( !expectToken( parser-&amp;gt;lexer, token, Token::Token_Comma ) ) {
        return;
    }

    // Next is the identifier representing the type name
    if ( !expectToken( parser-&amp;gt;lexer, token, Token::Token_Identifier ) ) {
        return;
    }

    // Parse property type and convert it to an enum
    property-&amp;gt;type = propertyTypeIdentifier( token );
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Now will come the most complicated part.&lt;!-- raw HTML omitted --&gt;
We have optional &amp;lsquo;(&amp;rsquo; open parenthesis for the parameters if the type needs it.&lt;!-- raw HTML omitted --&gt;
For the length of code and article, I skip this part and will add it in next article!&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;    // If an open parenthesis is present, then parse the ui arguments.
    nextToken( parser-&amp;gt;lexer, token );
    if ( token.type == Token::Token_OpenParen ) {
        property-&amp;gt;ui_arguments = token.text;

        while ( !equalToken( parser-&amp;gt;lexer, token, Token::Token_CloseParen ) ) {
            // TODO:
            // Parse parameters!
        }

        // Advance to the last close parenthesis
        nextToken( parser-&amp;gt;lexer, token );

        property-&amp;gt;ui_arguments.length = token.text.text - property-&amp;gt;ui_arguments.text;
    }

    if ( !checkToken( parser-&amp;gt;lexer, token, Token::Token_CloseParen ) ) {
        return;
    }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;At this point we can either be at the end of the property or we could have a &amp;lsquo;=&amp;rsquo; token to add a default value.
Being that the Lexer class is small, we can backtrack by saving the current Lexer status:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;    // Cache lexer status and advance to next token.
    // If the token is &#39;=&#39; then we parse the default value.
    // Otherwise backtrack by one token.
    Lexer cached_lexer = *parser-&amp;gt;lexer;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Now we can advance to the next token and:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;If the token is &amp;lsquo;=&amp;rsquo;, parse the default value.&lt;/li&gt;
&lt;li&gt;If not, backtrack the position of the Lexer and finish the parsing.&lt;/li&gt;
&lt;/ol&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;    nextToken( parser-&amp;gt;lexer, token );

    // At this point only the optional default value is missing, otherwise the parsing is over.
    if ( token.type == Token::Token_Equals ) {
        nextToken( parser-&amp;gt;lexer, token );
        
        if ( token.type = Token::Token_Number ) {
            // Cache the data buffer entry index into the property for later retrieval.
            property-&amp;gt;data_index = parser-&amp;gt;lexer-&amp;gt;data_buffer-&amp;gt;current_entries - 1;
        }
        else {
            // TODO:
            // Handle vectors, colors and non single number default values
        }
    }
    else {
        *parser-&amp;gt;lexer = cached_lexer;
    }

    parser-&amp;gt;shader.properties.push_back( property );
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;An interesting point is that the &lt;em&gt;numbers&lt;/em&gt; are parsed in a &lt;strong&gt;DataBuffer&lt;/strong&gt;, and during the parsing of the token we will add the number to it.&lt;!-- raw HTML omitted --&gt;
To retrieve it, we have the &lt;code&gt;data_index&lt;/code&gt; field of the &lt;code&gt;Property&lt;/code&gt; struct.&lt;!-- raw HTML omitted --&gt;
Also here, for the sake of &amp;lsquo;brevity&amp;rsquo;, I am handling only floats and ints. Vectors, colors and texture property should be easy to add.&lt;/p&gt;
&lt;p&gt;For vectors and colors we should parse a list of them and save them into the data buffer.&lt;/p&gt;
&lt;p&gt;For textures we should just save the default value as text and use it in the code-generation part.&lt;/p&gt;
&lt;h3 id=&#34;code-generation&#34;&gt;Code Generation&lt;/h3&gt;
&lt;p&gt;This should be pretty straight forward.&lt;!-- raw HTML omitted --&gt;
We can iterate the properties and generate both a C++ struct and a HLSL/GLSL buffer.&lt;!-- raw HTML omitted --&gt;
The only thing to be concerned is the padding: on the GPU normally the alignment is 16 bytes, so we can track that and insert padding when generating the code.&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;p&gt;In the method &lt;code&gt;void generateShaderResourceHeader( CodeGenerator* code_generator, const char* path )&lt;/code&gt; we can see how we generate the different code for C++:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;// C++
//
// Beginning

fprintf( output_file, &amp;quot;\n#pragma once\n#include &amp;lt;stdint.h&amp;gt;\n#include \&amp;quot;hydra_graphics.h\&amp;quot;\n\n// This file is autogenerated!\nnamespace &amp;quot; );

fwrite( shader.name.text, shader.name.length, 1, output_file );
fprintf( output_file, &amp;quot; {\n\n&amp;quot; );

// Preliminary sections
constants_ui.append( &amp;quot;struct LocalConstantsUI {\n\n&amp;quot; );

cpu_constants.append( &amp;quot;struct LocalConstants {\n\n&amp;quot; );

constants_ui_method.append(&amp;quot;\tvoid reflectMembers() {\n&amp;quot;);

buffer_class.append( &amp;quot;struct LocalConstantsBuffer {\n\n\thydra::graphics::BufferHandle\tbuffer;\n&amp;quot; );
buffer_class.append( &amp;quot;\tLocalConstants\t\t\t\t\tconstants;\n\tLocalConstantsUI\t\t\t\tconstantsUI;\n\n&amp;quot; );
buffer_class.append( &amp;quot;\tvoid create( hydra::graphics::Device&amp;amp; device ) {\n\t\tusing namespace hydra;\n\n&amp;quot; );
buffer_class.append( &amp;quot;\t\tgraphics::BufferCreation constants_creation = { graphics::BufferType::Constant, graphics::ResourceUsageType::Dynamic, sizeof( LocalConstants ), &amp;amp;constants, \&amp;quot;LocalConstants\&amp;quot; };\n&amp;quot; );
buffer_class.append( &amp;quot;\t\tbuffer = device.create_buffer( constants_creation );\n\t}\n\n&amp;quot; );
buffer_class.append( &amp;quot;\tvoid destroy( hydra::graphics::Device&amp;amp; device ) {\n\t\tdevice.destroy_buffer( buffer );\n\t}\n\n&amp;quot; );
buffer_class.append( &amp;quot;\tvoid updateUI( hydra::graphics::Device&amp;amp; device ) {\n\t\t// Draw UI\n\t\tconstantsUI.reflectUI();\n\t\t// Update constants from UI\n&amp;quot; );
buffer_class.append( &amp;quot;\t\thydra::graphics::MapBufferParameters map_parameters = { buffer.handle, 0, 0 };\n&amp;quot; );
buffer_class.append( &amp;quot;\t\tLocalConstants* buffer_data = (LocalConstants*)device.map_buffer( map_parameters );\n\t\tif (buffer_data) {\n&amp;quot; );

// For GPU the struct must be 16 bytes aligned. Track alignment
uint32_t gpu_struct_alignment = 0;

DataBuffer* data_buffer = code_generator-&amp;gt;parser-&amp;gt;lexer-&amp;gt;data_buffer;
// For each property write code
for ( size_t i = 0; i &amp;lt; shader.properties.size(); i++ ) {
    hfx::Property* property = shader.properties[i];

    switch ( property-&amp;gt;type ) {
        case Property::Float:
        {
            constants_ui.append(&amp;quot;\tfloat\t\t\t\t\t&amp;quot;);
            constants_ui.append( property-&amp;gt;name );

            cpu_constants.append( &amp;quot;\tfloat\t\t\t\t\t&amp;quot; );
            cpu_constants.append( property-&amp;gt;name );
            
            if ( property-&amp;gt;data_index != 0xffffffff ) {
                float value = 0.0f;
                getData( data_buffer, property-&amp;gt;data_index, value );
                constants_ui.append( &amp;quot;\t\t\t\t= %ff&amp;quot;, value );
                cpu_constants.append( &amp;quot;\t\t\t\t= %ff&amp;quot;, value );
            }

            constants_ui.append( &amp;quot;;\n&amp;quot; );

            cpu_constants.append( &amp;quot;;\n&amp;quot; );

            constants_ui_method.append(&amp;quot;\t\tImGui::InputScalar( \&amp;quot;&amp;quot;);
            constants_ui_method.append( property-&amp;gt;ui_name );
            constants_ui_method.append( &amp;quot;\&amp;quot;, ImGuiDataType_Float, &amp;amp;&amp;quot; );
            constants_ui_method.append( property-&amp;gt;name );
            constants_ui_method.append( &amp;quot;);\n&amp;quot; );

            // buffer_data-&amp;gt;scale = constantsUI.scale;
            buffer_class.append(&amp;quot;\t\t\tbuffer_data-&amp;gt;&amp;quot;);
            buffer_class.append( property-&amp;gt;name );
            buffer_class.append( &amp;quot; = constantsUI.&amp;quot; );
            buffer_class.append( property-&amp;gt;name );
            buffer_class.append( &amp;quot;;\n&amp;quot; );

            ++gpu_struct_alignment;

            break;
        }
    }
}

// Post-property sections
constants_ui.append( &amp;quot;\n&amp;quot; );

constants_ui_method.append( &amp;quot;\t}\n\n&amp;quot; );
constants_ui_method.append( &amp;quot;\tvoid reflectUI() {\n\t\tImGui::Begin( \&amp;quot;LocalConstants\&amp;quot; );\n&amp;quot; );
constants_ui_method.append( &amp;quot;\t\treflectMembers();\n\t\tImGui::End();\n\t}\n\n&amp;quot; );
constants_ui_method.append( &amp;quot;}; // struct LocalConstantsUI\n\n&amp;quot; );

// Add tail padding data
uint32_t tail_padding_size = 4 - (gpu_struct_alignment % 4);
cpu_constants.append( &amp;quot;\tfloat\t\t\t\t\tpad_tail[%u];\n\n&amp;quot;, tail_padding_size );

cpu_constants.append( &amp;quot;}; // struct LocalConstants\n\n&amp;quot; );

buffer_class.append( &amp;quot;\t\t\tdevice.unmap_buffer( map_parameters );\n\t\t}\n\t}\n}; // struct LocalConstantBuffer\n\n&amp;quot; );

fwrite( constants_ui.data, constants_ui.current_size, 1, output_file );
fwrite( constants_ui_method.data, constants_ui_method.current_size, 1, output_file );
fwrite( cpu_constants.data, cpu_constants.current_size, 1, output_file );
fwrite( buffer_class.data, buffer_class.current_size, 1, output_file );


// End
fprintf( output_file, &amp;quot;} // namespace &amp;quot; );
fwrite( shader.name.text, shader.name.length, 1, output_file );
fprintf( output_file, &amp;quot;\n\n&amp;quot; );

fclose( output_file );
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This piece of code will generate a constant buffer from the properties:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;// GLSL
//
static void generateConstantsCode( const Shader&amp;amp; shader, StringBuffer&amp;amp; out_buffer ) {
    if ( !shader.properties.size() ) {
        return;
    }

    // Add the local constants into the code.
    out_buffer.append( &amp;quot;\n\t\tlayout (std140, binding=7) uniform LocalConstants {\n\n&amp;quot; );

    // For GPU the struct must be 16 bytes aligned. Track alignment
    uint32_t gpu_struct_alignment = 0;

    const std::vector&amp;lt;Property*&amp;gt;&amp;amp; properties = shader.properties;
    for ( size_t i = 0; i &amp;lt; shader.properties.size(); i++ ) {
        hfx::Property* property = shader.properties[i];

        switch ( property-&amp;gt;type ) {
            case Property::Float:
            {
                out_buffer.append( &amp;quot;\t\t\tfloat\t\t\t\t\t&amp;quot; );
                out_buffer.append( property-&amp;gt;name );
                out_buffer.append( &amp;quot;;\n&amp;quot; );

                ++gpu_struct_alignment;
                break;
            }
        }
    }

    uint32_t tail_padding_size = 4 - (gpu_struct_alignment % 4);
    out_buffer.append( &amp;quot;\t\t\tfloat\t\t\t\t\tpad_tail[%u];\n\n&amp;quot;, tail_padding_size );
    out_buffer.append( &amp;quot;\t\t} local_constants;\n\n&amp;quot; );
}
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;expert-constants-an-interesting-problem&#34;&gt;Expert constants: an interesting problem&lt;/h3&gt;
&lt;p&gt;A problem many times surfaces is that the material interface does not correspond to the buffer sent to the GPU, because the programmers will do the following:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Add &lt;em&gt;system&lt;/em&gt; constants, that don&amp;rsquo;t need a UI&lt;/li&gt;
&lt;li&gt;Change order of the constants&lt;/li&gt;
&lt;li&gt;Change constants to more GPU friendly values, calculating some stuff on the CPU&lt;/li&gt;
&lt;li&gt;Pack constants into smaller ones&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;This is an interesting topic and I&amp;rsquo;ll cover it in another article, but a simple solution would be to add a mapping between the GPU constants and the UI, so that we can separate the UI constants from the GPU ones.&lt;/p&gt;
&lt;p&gt;I&amp;rsquo;ll give a brief example but it would be too much for this article and will not be included in the source code.&lt;/p&gt;
&lt;p&gt;Basically we are trying to create a mapping between the material interface:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;// C++
struct LocalConstantsUI {

    float                    scale                = 32.000000f;
    float                    modulo                = 2.000000f;

    void reflectMembers() {
        ImGui::InputScalar( &amp;quot;Scale&amp;quot;, ImGuiDataType_Float, &amp;amp;scale);
        ImGui::InputScalar( &amp;quot;Modulo&amp;quot;, ImGuiDataType_Float, &amp;amp;modulo);
    }

    void reflectUI() {
        ImGui::Begin( &amp;quot;LocalConstants&amp;quot; );
        reflectMembers();
        ImGui::End();
    }

}; // struct LocalConstantsUI
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;And the GPU constants:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;// C++
struct LocalConstants {

    float                    scale                = 32.000000f;
    float                    modulo                = 2.000000f;
    float                    pad_tail[2];

}; // struct LocalConstants
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;We could enhance HFX with some syntax to mark the &lt;em&gt;derivate&lt;/em&gt; properties and just add the &lt;em&gt;system&lt;/em&gt; ones in an explicit buffer layout, and add a &lt;em&gt;layout&lt;/em&gt; section in the HFX:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;// HFX

properties {

    // Using Unity ShaderLab syntax:
    scale(&amp;quot;Scale&amp;quot;, Range(0.0, 100.0)) = 100.0
    modulo(&amp;quot;Modulo&amp;quot;, Float) = 2.0
}

layout {
    CBuffer LocalConstants {
        float4x4            world_view_projection;    // &#39;System&#39; variable

        float               scale01 = (scale);       // Silly normalized version of scale interface property
        float               modulo;
        float               pad[2];
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;we could completely override the automatic constant buffer generation from the properties.&lt;!-- raw HTML omitted --&gt;
With this we can:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Add a system variable like &lt;em&gt;world_view_projection&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;Flag the property &lt;strong&gt;scale&lt;/strong&gt; as UI only, by saying that property &lt;strong&gt;scale01&lt;/strong&gt; uses it.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;I think that with this syntax both artists and programmers can be happy together!&lt;!-- raw HTML omitted --&gt;
I will try to work on this on a later article.&lt;/p&gt;
&lt;h2 id=&#34;resource-bindings-vulkan-and-d3d12-mentality&#34;&gt;Resource bindings: Vulkan and D3D12 mentality&lt;/h2&gt;
&lt;p&gt;As stated multiple times, the shift in mentality is towards the new APIs, and that includes the concept of &lt;strong&gt;resource lists&lt;/strong&gt;.&lt;!-- raw HTML omitted --&gt;
The problem is that we don&amp;rsquo;t want artists to have to handle this kind of things - especially if you want to quickly prototype things!&lt;!-- raw HTML omitted --&gt;
But at the same time, we want programmers to have the possibility to optimize the shaders the artists gave them.&lt;!-- raw HTML omitted --&gt;
What is the solution?&lt;!-- raw HTML omitted --&gt;
Simple: creating an optional &lt;em&gt;resource layout&lt;/em&gt; section and &lt;strong&gt;automatically&lt;/strong&gt; generate it if not present, so that artists (and not only) can happily create amazing tech and THEN worry about these details!&lt;/p&gt;
&lt;h3 id=&#34;automatic-resource-layout&#34;&gt;Automatic Resource Layout&lt;/h3&gt;
&lt;p&gt;The easiest way to handle resource layout is to make them &lt;strong&gt;SIMPLE&lt;/strong&gt;. Remember the &lt;strong&gt;K.I.S.S. principle&lt;/strong&gt;.&lt;!-- raw HTML omitted --&gt;
In this case it means that we can create a Resource List for each pass, that will contain:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;One constant/uniform buffer containing all the properties&lt;/li&gt;
&lt;li&gt;All the textures used by the shader&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;How can we achieve that ?&lt;/p&gt;
&lt;p&gt;We already saw how we can generate the constant buffer from the properties in the previous section.
For textures we have a couple of options.&lt;/p&gt;
&lt;h4 id=&#34;list-of-textures&#34;&gt;List of Textures&lt;/h4&gt;
&lt;p&gt;Being in automation land, there are 2 ways to add texture dependencies:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Use reflection mechanism from the target shader language&lt;/li&gt;
&lt;li&gt;Parse identifiers in the current finalized shader&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;For the sake of fun we will look into the second of course!&lt;!-- raw HTML omitted --&gt;
If we go back to &lt;code&gt;void declarationGlsl( Parser* parser )&lt;/code&gt;, we can add a new method to parse the keyword:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;// Parse hash for includes and defines
if ( token.type == Token::Token_Hash ) {
    // Get next token and check which directive is
    nextToken( parser-&amp;gt;lexer, token );

    directiveIdentifier( parser, token, code_fragment );
}
else if ( token.type == Token::Token_Identifier ) {        &amp;lt;------------  New Code!

    // Parse uniforms to add resource dependencies if not explicit in the HFX file.
    if ( expectKeyword( token.text, 7, &amp;quot;uniform&amp;quot; ) ) {
        nextToken( parser-&amp;gt;lexer, token );

        uniformIdentifier( parser, token, code_fragment );
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;In this way it will search for the identifier &lt;em&gt;uniform&lt;/em&gt; and search for the other identifiers. This is GLSL centric of course.&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;inline void uniformIdentifier( Parser* parser, const Token&amp;amp; token, CodeFragment&amp;amp; code_fragment ) {
    for ( uint32_t i = 0; i &amp;lt; token.text.length; ++i ) {
        char c = *(token.text.text + i);

        switch ( c ) {
            case &#39;i&#39;:
            {
                if ( expectKeyword( token.text, 7, &amp;quot;image2D&amp;quot; ) ) {
                    // Advance to next token to get the name
                    Token name_token;
                    nextToken( parser-&amp;gt;lexer, name_token );

                    CodeFragment::Resource resource = { hydra::graphics::ResourceType::TextureRW, name_token.text };
                    code_fragment.resources.emplace_back( resource );
                }
                break;
            }

            case &#39;s&#39;:
            {
                if ( expectKeyword( token.text, 9, &amp;quot;sampler2D&amp;quot; ) ) {
                    // Advance to next token to get the name
                    Token name_token;
                    nextToken( parser-&amp;gt;lexer, name_token );

                    CodeFragment::Resource resource = { hydra::graphics::ResourceType::Texture, name_token.text };
                    code_fragment.resources.emplace_back( resource );
                }
                break;
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Should be pretty straight-forward: if you find the identifier for texture, add a resource dependency with type and name to the current code fragment!&lt;!-- raw HTML omitted --&gt;
Is this the ideal solution ?&lt;!-- raw HTML omitted --&gt;
Probably not.&lt;!-- raw HTML omitted --&gt;
But I wanted to show what we can achieve once we have fun with parsing, including the understanding on when to say &lt;strong&gt;NO&lt;/strong&gt; to it!&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;h3 id=&#34;manual-resource-layout&#34;&gt;Manual Resource Layout&lt;/h3&gt;
&lt;p&gt;Now that the effect can work without too much programmer time, it is time to give back to programmers the control they want.&lt;!-- raw HTML omitted --&gt;
In the previous paragraph about &lt;em&gt;Expert Constants&lt;/em&gt; we talked about adding a new section, called &lt;strong&gt;layout&lt;/strong&gt;.&lt;!-- raw HTML omitted --&gt;
In this section we can specify the resource list for each &lt;em&gt;pass&lt;/em&gt; manually, and later on in the pass we can reference this lists as used by the pass.&lt;/p&gt;
&lt;p&gt;Going on a more complete solution, layouts &lt;strong&gt;should be included and merged when including other HFX files&lt;/strong&gt;.&lt;!-- raw HTML omitted --&gt;
This is something we want and we&amp;rsquo;ll look in another post, we can start simple by defining something local:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;// HFX
//
// For the developer
layout {
    list LocalCompute {
        cbuffer LocalConstants;

        texture2Drw(rgba8) destination_texture;
    }

    list Local {
        texture2D input_texture;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This is a rather simple layout, but let&amp;rsquo;s see it.&lt;!-- raw HTML omitted --&gt;
First of all, for each &amp;lsquo;list&amp;rsquo; keyword we define a single list with a unique name.&lt;!-- raw HTML omitted --&gt;
With that, we can reference in the pass which list to use.&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;p&gt;The code that does the parsing is (at this point) pretty straight-forward, both in &lt;code&gt;void declarationResourceList( Parser* parser, ResourceList&amp;amp; resource_list )&lt;/code&gt; and  &lt;code&gt;void resourceBindingIdentifier( Parser* parser, const Token&amp;amp; token, ResourceBinding&amp;amp; binding )&lt;/code&gt;.&lt;!-- raw HTML omitted --&gt;
I will not go over it, but basically it will parse the resource lists and add them to the shader.&lt;!-- raw HTML omitted --&gt;
The parsing itself will read the text and create the &lt;code&gt;ResourceSetLayoutCreation::Binding&lt;/code&gt; and add it to the list of the resources.&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;p&gt;We then add a new identifier in the pass to choose which resource list to be used:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;// HFX
//
pass FillTexture {

    resources = LocalCompute, ...

    dispatch = 32, 32, 1
    render_pass = compute
    compute = ComputeTest
}

pass ToScreen {

    resources = Local

    render_pass = fullscreen
    vertex = ToScreen
    fragment = ToScreen
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The parsing will happen in &lt;code&gt;void declarationPassResources( Parser* parser, Pass&amp;amp; pass )&lt;/code&gt;.&lt;/p&gt;
&lt;h3 id=&#34;adding-resource-layout-data-to-binary-hfx&#34;&gt;Adding Resource Layout data to binary HFX&lt;/h3&gt;
&lt;p&gt;So after this amazing journey we are ready to embed those informations into the BHFX and use it right away into the rendering API.&lt;/p&gt;
&lt;p&gt;The big difference is &lt;strong&gt;if the hfx file contains a layout section&lt;/strong&gt;.&lt;!-- raw HTML omitted --&gt;
If it is not present, then all the informations will be gathered automatically and will be added with the &lt;code&gt;writeAutomaticResourcesLayout&lt;/code&gt; method.&lt;/p&gt;
&lt;p&gt;First we will add the LocalConstant buffer created from the properties:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;static void writeAutomaticResourcesLayout( const hfx::Pass&amp;amp; pass, StringBuffer&amp;amp; pass_buffer, uint32_t&amp;amp; pass_offset ) {

    using namespace hydra::graphics;

    // Add the local constant buffer obtained from all the properties in the layout.
    hydra::graphics::ResourceSetLayoutCreation::Binding binding = { hydra::graphics::ResourceType::Constants, 0, 1, &amp;quot;LocalConstants&amp;quot; };

    pass_buffer.append( (void*)&amp;amp;binding, sizeof( hydra::graphics::ResourceSetLayoutCreation::Binding) );
    pass_offset += sizeof( hydra::graphics::ResourceSetLayoutCreation::Binding );
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Then we will cycle through all the shader stages and write the resources into the memory:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;    for ( size_t s = 0; s &amp;lt; pass.shader_stages.size(); ++s ) {
        const Pass::ShaderStage shader_stage = pass.shader_stages[s];

        for ( size_t p = 0; p &amp;lt; shader_stage.code-&amp;gt;resources.size(); p++ ) {
            const hfx::CodeFragment::Resource&amp;amp; resource = shader_stage.code-&amp;gt;resources[p];

            switch ( resource.type ) {
                case ResourceType::Texture:
                {
                    copy( resource.name, binding.name, 32 );
                    binding.type = hydra::graphics::ResourceType::Texture;

                    pass_buffer.append( (void*)&amp;amp;binding, sizeof( hydra::graphics::ResourceSetLayoutCreation::Binding ) );
                    pass_offset += sizeof( hydra::graphics::ResourceSetLayoutCreation::Binding );
                    break;
                }

                case ResourceType::TextureRW:
                {
                    copy( resource.name, binding.name, 32 );
                    binding.type = hydra::graphics::ResourceType::TextureRW;

                    pass_buffer.append( (void*)&amp;amp;binding, sizeof( hydra::graphics::ResourceSetLayoutCreation::Binding ) );
                    pass_offset += sizeof( hydra::graphics::ResourceSetLayoutCreation::Binding );
                    break;
                }
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;If instead there is a layout section, the method &lt;code&gt;writeResourcesLayout&lt;/code&gt; is called and will be pretty straight-forward:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;static void writeResourcesLayout( const hfx::Pass&amp;amp; pass, StringBuffer&amp;amp; pass_buffer, uint32_t&amp;amp; pass_offset ) {

    using namespace hydra::graphics;

    for ( size_t r = 0; r &amp;lt; pass.resource_lists.size(); ++r ) {
        const ResourceList* resource_list = pass.resource_lists[r];

        const uint32_t resources_count = (uint32_t)resource_list-&amp;gt;resources.size();
        pass_buffer.append( (void*)resource_list-&amp;gt;resources.data(), sizeof(ResourceBinding) * resources_count );
        pass_offset += sizeof( ResourceBinding ) * resources_count;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;And this will be put at the end of the current pass section:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;pass_buffer.append( (void*)&amp;amp;pass_header, sizeof( ShaderEffectFile::PassHeader ) );
pass_buffer.append( shader_offset_buffer );
pass_buffer.append( code_buffer );

if ( automatic_layout ) {
    writeAutomaticResourcesLayout( pass, pass_buffer, pass_offset );
}
else {
    writeResourcesLayout( pass, pass_buffer, pass_offset );
}
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;conclusions-and-whats-next&#34;&gt;Conclusions and what&amp;rsquo;s next&lt;/h1&gt;
&lt;p&gt;We arrived at the end of this article, and we started seeing how we can use HFX as a more complete language to embed different rendering features.&lt;!-- raw HTML omitted --&gt;
We saw how to embed shader code and resource lists so that the rendering API can create everything without hard-coded generation of resources. This also showed when it was useful to create data instead of code.&lt;!-- raw HTML omitted --&gt;
On the contrary, the UI and the Constants are generated in a new header file - thus code generation.&lt;!-- raw HTML omitted --&gt;
There are pros and cons to both approaches, but I hope that knowing how to generate code and create a custom language will let you play with the concepts and explore your own needs.&lt;/p&gt;
&lt;p&gt;As next steps, there are some questions opened: how to reload shaders ? Can I add new material properties without recompiling code ?&lt;/p&gt;
&lt;p&gt;We will also see a simple implementation of a frame-graph, that I use since my years in Codemasters and in my indie project. This will be much more data-driven than code-generated, but again, the purpose of these articles is to explore the concepts and understanding when to use what.&lt;/p&gt;
&lt;p&gt;As always please comment, feedback, share!&lt;/p&gt;
&lt;p&gt;Thanks for reading!
Gabriel&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Writing a Shader Effect Language Part 1</title>
      <link>https://jorenjoestar.github.io/post/writing_shader_effect_language_1/</link>
      <pubDate>Tue, 06 Aug 2019 13:04:15 -0400</pubDate>
      
      <guid>https://jorenjoestar.github.io/post/writing_shader_effect_language_1/</guid>
      <description>&lt;h1 id=&#34;overview&#34;&gt;Overview&lt;/h1&gt;
&lt;p&gt;Data Driven Rendering Series:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;https://jorenjoestar.github.io/post/writing_shader_effect_language_1/&#34;&gt;https://jorenjoestar.github.io/post/writing_shader_effect_language_1/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://jorenjoestar.github.io/post/writing_shader_effect_language_2/&#34;&gt;https://jorenjoestar.github.io/post/writing_shader_effect_language_2/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://jorenjoestar.github.io/post/writing_shader_effect_language_3/&#34;&gt;https://jorenjoestar.github.io/post/writing_shader_effect_language_3/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://jorenjoestar.github.io/post/data_driven_rendering_pipeline/&#34;&gt;https://jorenjoestar.github.io/post/data_driven_rendering_pipeline/&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;In this article we will create a simple language that can encapsulate shader code (called &lt;strong&gt;code fragments&lt;/strong&gt;) and output different files for each fragment.&lt;!-- raw HTML omitted --&gt;
This is the initial step to switch from an engine that loads single files for each &lt;strong&gt;shader stage&lt;/strong&gt; (vertex, fragment, compute, &amp;hellip;) to one that uses an effect file that contains more than one shader.&lt;/p&gt;
&lt;p&gt;We will start by motivation, then will define the language itself (very simple), then we will look at the Parser and last the Code Generator.&lt;/p&gt;
&lt;p&gt;Have a good read!&lt;/p&gt;
&lt;h1 id=&#34;motivation&#34;&gt;Motivation&lt;/h1&gt;
&lt;p&gt;In the incredible quest of &lt;em&gt;data-driven rendering&lt;/em&gt;, after we defeated the dragon of &lt;a href=&#34;https://jorenjoestar.github.io/post/writing_a_simple_code_generator/&#34;&gt;code generation&lt;/a&gt; another multiple headed dragon arises: an hydra!
We have different options here: be the brave warrior in shiny armor that tries to cut all the heads of the hydra, built some machines that can fight for us and send them, or both built the machines AND fight.&lt;/p&gt;
&lt;p&gt;Our code is invaluable, like our energies fighting the hydra.
We need to carefully balance them and see how can we use for the BEST.&lt;/p&gt;
&lt;p&gt;Writing manual code is good, it is generally what is done, but it is slow and error prone.
Going data-driven can be fast, but can give you a sense of losing control (not personally, but I heard few people saying that).
Only generating code can quickly become a recipe for disaster: so many particular use cases need attention, that the code could be come a different kind of mess.&lt;/p&gt;
&lt;p&gt;We will try to go down the route of code generation mixed with data-driven.
As I wrote in my previous articles, it is a fine line and can be good to know when to go in which direction!&lt;/p&gt;
&lt;p&gt;I will divide the article in 2 parts.
The first part (this one) will contain the new Shader Code Generator to generate shader permutations and add include support to GLSL.
The second will require a low-level rendering library and will show Code Generation of more CPU areas of Rendering, the real goal of all these articles!&lt;/p&gt;
&lt;p&gt;The code is available here:&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/JorenJoestar/DataDrivenRendering&#34;&gt;https://github.com/JorenJoestar/DataDrivenRendering&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&#34;effect-file-structure&#34;&gt;Effect file structure&lt;/h1&gt;
&lt;p&gt;Looking at effects, the first thing to do is to define a file that will represent our shaders. My choice is to create a simple language to embed shaders code and generate the CPU code necessary to render it.&lt;/p&gt;
&lt;h2 id=&#34;why-not-using-json-&#34;&gt;Why not using Json ?&lt;/h2&gt;
&lt;p&gt;While it is an amazing data-format, I still want a bigger degree of control of what to parse and what to generate.
The decision is based on the fact that by writing a parser for the language, I can automate some code-generation that would be more intricate with Json.
Also, this series itself is a personal exploration on the topic, so using Json was not an option for this level of complexity.&lt;/p&gt;
&lt;h2 id=&#34;the-hfx-format&#34;&gt;The HFX Format&lt;/h2&gt;
&lt;p&gt;HFX (Hydra Effects) is a new language we will define to write out shaders.
The first iteration will be barebone - it will simply be a shader permutation generator - but it will be the foundation to extensions that will allow us to write CPU rendering code that we want to automate.&lt;/p&gt;
&lt;p&gt;In defining the format, there will be few keywords that will be defined, but the general architecture will make straightforward to copy-paste shader code fragments from any language into the HFX language.
We will use the following keywords (and concepts).&lt;/p&gt;
&lt;h3 id=&#34;shader&#34;&gt;Shader&lt;/h3&gt;
&lt;p&gt;The root of a shader effect. It will contain everything we are writing.&lt;/p&gt;
&lt;h3 id=&#34;glslhlsl&#34;&gt;Glsl/Hlsl&lt;/h3&gt;
&lt;p&gt;These will define the actual shader code, enclosed fragments. Fragments can be composed and reused.
For Glsl in particular, code fragments needs to be embedded in defines for each stage. More on that later.&lt;/p&gt;
&lt;h3 id=&#34;pass-technique-variant&#34;&gt;Pass, Technique, Variant&lt;/h3&gt;
&lt;p&gt;This is the central part for the effects to work. I&amp;rsquo;ve researched a bit, between &lt;a href=&#34;https://docs.microsoft.com/en-us/windows/win32/direct3d9/using-an-effect&#34;&gt;Microsoft effects&lt;/a&gt;, &lt;a href=&#34;https://docs.unity3d.com/Manual/SL-Shader.html&#34;&gt;Unity effects&lt;/a&gt;, &lt;a href=&#34;https://github.com/BastiaanOlij/shader_tutorial/blob/master/shaders/water_3d/depth_buffer/depth_buffer_textured.shader&#34;&gt;Godot&lt;/a&gt; and &lt;a href=&#34;http://advances.realtimerendering.com/destiny/gdc_2017/&#34;&gt;Bungie&lt;/a&gt; and the concepts are very similar, but they seem to differ a little and also each implementation becomes very engine-specific of course.&lt;!-- raw HTML omitted --&gt;
The presentation by Bungie is amazing and their system is by far the more extensive and complex, we will work on a much simpler shader effect system.&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;p&gt;Let&amp;rsquo;s define a pass as a combination of shader code for at least one stage of the shader pipeline. For example a single compute shader or a couple vertex-fragment shader.&lt;/p&gt;
&lt;p&gt;Variants and techniques are loose concept to help separating shader paths.
For example a &lt;em&gt;variant&lt;/em&gt; could be a different post-process shader, like different implementations of SSAO.&lt;/p&gt;
&lt;p&gt;A technique could be a whole set of passes that target a specific platform.&lt;/p&gt;
&lt;p&gt;Not having my mind set on those still, I will omit them for now, as they are concepts that are less central than the code generation, and can be very subjective opinion-wise.
Possibly I&amp;rsquo;ll get them in part 2.&lt;/p&gt;
&lt;h3 id=&#34;properties&#34;&gt;Properties&lt;/h3&gt;
&lt;p&gt;Final piece of the puzzle. This will define the resources used by the shader effect on a per-effect level.
Keeping an eye on the newer rendering APIs (DX12 and Vulkan) this defines also the layout of the resources and how they are used.
Possibly the most intense part from an automation possibility (and thus code-generation).
We will define this in part 2 of this article.&lt;/p&gt;
&lt;h1 id=&#34;high-level-workflow&#34;&gt;High level workflow&lt;/h1&gt;
&lt;p&gt;From a high level perspective what will happen in all this code is enclosed in this code:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;text = ReadEntireFileIntoMemory( &amp;quot;..\\data\\SimpleFullscreen.hfx&amp;quot;, nullptr );
initLexer( &amp;amp;lexer, (char*)text );

hfx::Parser effect_parser;
hfx::initParser( &amp;amp;effect_parser, &amp;amp;lexer );
hfx::generateAST( &amp;amp;effect_parser );

hfx::CodeGenerator hfx_code_generator;
hfx::initCodeGenerator( &amp;amp;hfx_code_generator, &amp;amp;effect_parser, 4096 );
hfx::generateShaderPermutations( &amp;amp;hfx_code_generator, &amp;quot;..\\data\\&amp;quot; );
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;We separated the &lt;em&gt;Lexer&lt;/em&gt; from the &lt;em&gt;Parser&lt;/em&gt; so we can reuse the lexer functionalities, thus we can reuse it from the previous example (parsing the HydraDataFormat files).&lt;!-- raw HTML omitted --&gt;
Then we initialize the &lt;em&gt;Parser&lt;/em&gt; and &lt;em&gt;generate the AST&lt;/em&gt;. This will save all the passes and code fragments we defined in the HFX file.&lt;!-- raw HTML omitted --&gt;
Finally we will get the parsing informations and give them to the &lt;em&gt;code generator&lt;/em&gt;, that will write out the files for each pass and stage.&lt;/p&gt;
&lt;p&gt;Let&amp;rsquo;s dig into the example!&lt;/p&gt;
&lt;h1 id=&#34;parser-welcome-hfx&#34;&gt;Parser: welcome HFX!&lt;/h1&gt;
&lt;p&gt;In most rendering-API (OpenGL, Vulkan, Direct3D12, &amp;hellip;) shaders are compiled by compiling the individual stages (vertex, fragment, compute, geometry, &amp;hellip;) and in some APIs (especially the newer ones) are compiled into a &lt;strong&gt;Shader State&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;As first step of this shader language, single shader files will be created by the &lt;em&gt;shader generation&lt;/em&gt; method in our code.&lt;/p&gt;
&lt;p&gt;We will define a simple fullscreen HFX with &lt;em&gt;code fragments&lt;/em&gt; and &lt;em&gt;passes&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;First, we define the root shader (SimpleFullscreen.hfx, under folder &amp;lsquo;data&amp;rsquo;):&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;shader SimpleFullscreen {
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This is simply the container for all the code and passes that will define the shader effect.&lt;/p&gt;
&lt;p&gt;Now we need some actual code, so we can define a shader fragment.&lt;!-- raw HTML omitted --&gt;
The keyword used in our language is &lt;strong&gt;glsl&lt;/strong&gt; followed by a name and an open brace:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;glsl ToScreen {
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This will define a &lt;strong&gt;code fragment&lt;/strong&gt; named &lt;em&gt;ToScreen&lt;/em&gt;, that can be referenced from the passes.&lt;!-- raw HTML omitted --&gt;
Next we use a glsl trick to &lt;em&gt;signal our parser to use includes&lt;/em&gt;:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;#pragma include &amp;quot;Platform.h&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This #pragma is actually ignored by the compiler, but will be used by the parser to actually add the include!&lt;!-- raw HTML omitted --&gt;
BEWARE: this code will be included in BOTH &lt;em&gt;vertex&lt;/em&gt; and &lt;em&gt;fragment&lt;/em&gt; program!&lt;!-- raw HTML omitted --&gt;
Anything outside of the VERTEX/FRAGMENT/COMPUTE macros will be, and this is done on purpose, like defining an interpolator struct only once or for common includes.&lt;/p&gt;
&lt;p&gt;Next we define the vertex program.&lt;!-- raw HTML omitted --&gt;
BEWARE: vertex only code must be enclosed in &lt;strong&gt;VERTEX&lt;/strong&gt; define!&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;#if defined VERTEX

out vec4 vTexCoord;

void main() {

   vTexCoord.xy = vec2((gl_VertexID &amp;lt;&amp;lt; 1) &amp;amp; 2, gl_VertexID &amp;amp; 2);
   vTexCoord.zw = vTexCoord.xy;
   gl_Position = vec4(vTexCoord.xy * 2.0f + -1.0f, 0.0f, 1.0f);
}

#endif // VERTEX
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This code is a simple fullscreen triangle that does not require any vertex buffer, but uses the vertex id to draw. Nothing fancy.&lt;/p&gt;
&lt;p&gt;Next is the fragment program, and again enclosed in &lt;strong&gt;FRAGMENT&lt;/strong&gt; define:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;#if defined FRAGMENT

in vec4 vTexCoord;

out vec4 outColor;

layout(binding=0) uniform sampler2D input_texture;

void main() {

    vec3 color = texture2D(input_texture, vTexCoord.xy).xyz;
    outColor = vec4(color, 1);
}

#endif // FRAGMENT

} // glsl ToScreen

&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This code simply reads a texture and outputs it to the screen.&lt;/p&gt;
&lt;p&gt;We defined the code fragment ToScreen, containing both a vertex and a fragment program, and now we can actually generate the permutation that we need.&lt;!-- raw HTML omitted --&gt;
The code for this in our effect file is:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;pass ToScreen {
   vertex = ToScreen
   fragment = ToScreen
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;We are simply defining a pass with the vertex and fragment program defined in the ToScreen code fragment (yes I don&amp;rsquo;t like this term too).&lt;/p&gt;
&lt;p&gt;Running the &lt;strong&gt;code generator&lt;/strong&gt; on this simple effect file will generate the two files ToScreen.vert and ToScreen.frag.&lt;/p&gt;
&lt;p&gt;These can be read directly into your favourite OpenGL renderer and used as is!&lt;/p&gt;
&lt;h2 id=&#34;the-parser&#34;&gt;The Parser&lt;/h2&gt;
&lt;p&gt;Now that we have defined the effect and we know what is the outcome of generating code from the effect file, let&amp;rsquo;s look into the different component of the parser and code generator needed.&lt;/p&gt;
&lt;p&gt;By design, we chose the Lexer to know nothing about the language, so that we can use it between different languages.
The entry point to parse the effect is the method generateAST:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;void generateAST( Parser* parser ) {

    // Read source text until the end.
    // The main body can be a list of declarations.
    bool parsing = true;

    while ( parsing ) {

        Token token;
        nextToken( parser-&amp;gt;lexer, token );

        switch ( token.type ) {

            case Token::Token_Identifier:
            {
                identifier( parser, token );
                break;
            }

            case Token::Type::Token_EndOfStream:
            {
                parsing = false;
                break;
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This code simply process the file -  using the lexer -  until the end of it, and reads only identifiers.&lt;!-- raw HTML omitted --&gt;
It is the same as the previous article and the previous parser. What changes drastically is the &lt;strong&gt;identifier&lt;/strong&gt; method!&lt;!-- raw HTML omitted --&gt;
We will have 3 different set of identifiers, usable in different parts of the HFX file:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Main identifiers, &amp;lsquo;shader&amp;rsquo;, &amp;lsquo;glsl&amp;rsquo;, &amp;lsquo;pass&amp;rsquo;&lt;/li&gt;
&lt;li&gt;Pass identifiers, &amp;lsquo;compute&amp;rsquo;, &amp;lsquo;vertex&amp;rsquo;, &amp;lsquo;fragment&amp;rsquo;&lt;/li&gt;
&lt;li&gt;Directive identifiers, &amp;lsquo;if defined&amp;rsquo;, &amp;lsquo;pragma include&amp;rsquo;, &amp;lsquo;endif&amp;rsquo;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Let&amp;rsquo;s have a look at the code for parsing the main identifiers:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;inline void identifier( Parser* parser, const Token&amp;amp; token ) {

    // Scan the name to know which 
    for ( uint32_t i = 0; i &amp;lt; token.text.length; ++i ) {
        char c = *(token.text.text + i);

        switch ( c ) {
            case &#39;s&#39;:
            {
                if ( expectKeyword( token.text, 6, &amp;quot;shader&amp;quot; ) ) {
                    declarationShader( parser );
                    return;
                }

                break;
            }

            case &#39;g&#39;:
            {
                if ( expectKeyword( token.text, 4, &amp;quot;glsl&amp;quot; ) ) {
                    declarationGlsl( parser );
                    return;
                }
                break;
            }

            case &#39;p&#39;:
            {
                if ( expectKeyword( token.text, 4, &amp;quot;pass&amp;quot; ) ) {
                    declarationPass( parser );
                    return;
                }
                break;
            }

        }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This code simply defers the parsing of a particular identifier using the &lt;strong&gt;declaration&lt;/strong&gt; method corresponding to the identifier.
We will look into detail on each method.&lt;/p&gt;
&lt;h3 id=&#34;parsing-shader&#34;&gt;Parsing &amp;lsquo;shader&amp;rsquo;&lt;/h3&gt;
&lt;p&gt;We are parsing now the following part from the HFX file:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;// HFX

shader SimpleFullscreen {
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This is the entry point of the effect itself.&lt;!-- raw HTML omitted --&gt;
What should the parser do here ?&lt;!-- raw HTML omitted --&gt;
Simply iterate through the main identifiers, &amp;lsquo;glsl&amp;rsquo; and &amp;lsquo;pass&amp;rsquo;.&lt;!-- raw HTML omitted --&gt;
Technically I could have separated the methods to have one with parsing shader only and the others parsing &amp;lsquo;glsl&amp;rsquo; and &amp;lsquo;pass&amp;rsquo;, but did not want to complicate the code further.&lt;/p&gt;
&lt;p&gt;Let&amp;rsquo;s look at how we parse the identifier &amp;lsquo;shader&amp;rsquo;:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;// C++

inline void declarationShader( Parser* parser ) {
    // Parse name
    Token token;
    if ( !expectToken( parser-&amp;gt;lexer, token, Token::Token_Identifier ) ) {
        return;
    }

    // Cache name string
    StringRef name = token.text;

    if ( !expectToken( parser-&amp;gt;lexer, token, Token::Token_OpenBrace ) ) {
        return;
    }

    while ( !equalToken( parser-&amp;gt;lexer, token, Token::Token_CloseBrace ) ) {

        identifier( parser, token );
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;As the previous article&amp;rsquo;s code, this will get the tokens from the lexer and generate data if the syntax is correct.&lt;!-- raw HTML omitted --&gt;
When we enter the method the Lexer will be just at the beginning of the name (SimpleFullscreen), so the code will parse the name, the open brace, and parse everything else until it encounter the close brace.&lt;/p&gt;
&lt;p&gt;The method identifier will parse also identifiers &amp;lsquo;glsl&amp;rsquo; and &amp;lsquo;pass&amp;rsquo;.&lt;/p&gt;
&lt;h3 id=&#34;parsing-glsl&#34;&gt;Parsing &amp;lsquo;glsl&amp;rsquo;&lt;/h3&gt;
&lt;p&gt;This is the most complex parsing in the code.&lt;!-- raw HTML omitted --&gt;
I will put both the HFX part and C++ code so hopefully it will be clearer what the parser is doing and why.&lt;/p&gt;
&lt;p&gt;As a refresh and reference, this is the &lt;strong&gt;code fragment&lt;/strong&gt; ToScreen defined in SimpleFullscreen.hfx:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;// HFX

glsl ToScreen {

    #pragma include &amp;quot;Platform.h&amp;quot;

    #if defined VERTEX
    out vec4 vTexCoord;

    void main() {

        vTexCoord.xy = vec2((gl_VertexID &amp;lt;&amp;lt; 1) &amp;amp; 2, gl_VertexID &amp;amp; 2);
        vTexCoord.zw = vTexCoord.xy;

        gl_Position = vec4(vTexCoord.xy * 2.0f + -1.0f, 0.0f, 1.0f);
    }
    #endif // VERTEX

    #if defined FRAGMENT

    in vec4 vTexCoord;

    out vec4 outColor;

    layout(binding=0) uniform sampler2D input_texture;

    void main() {
        vec3 color = texture2D(input_texture, vTexCoord.xy).xyz;
        outColor = vec4(1, 1, 0, 1);
        outColor = vec4(color, 1);
    }
    #endif // FRAGMENT
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Let&amp;rsquo;s start from the beginning.&lt;!-- raw HTML omitted --&gt;
When the parser finds the &amp;lsquo;glsl&amp;rsquo; keyword in the identifier method:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;// C++

case &#39;g&#39;:
{
    if ( expectKeyword( token.text, 4, &amp;quot;glsl&amp;quot; ) ) {
        declarationGlsl( parser );
        return;
    }
    break;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;It calls the method &lt;em&gt;&lt;em&gt;void declarationGlsl( Parser&lt;/em&gt; parser )&lt;/em&gt;*.&lt;/p&gt;
&lt;p&gt;The lexer reading the HFX is after the glsl keyword when entering the method, just before the ToScreen identifier:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;// HFX

glsl (Here!)ToScreen {
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Let&amp;rsquo;s see the C++ code step by step.&lt;!-- raw HTML omitted --&gt;
First parsing the name &amp;lsquo;ToScreen&amp;rsquo;:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;// C++

inline void declarationGlsl( Parser* parser ) {

    // Parse name
    Token token;
    if ( !expectToken( parser-&amp;gt;lexer, token, Token::Token_Identifier ) ) {
        return;
    }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;as seen in other methods as well.&lt;!-- raw HTML omitted --&gt;
We are defining a new &lt;strong&gt;code fragment&lt;/strong&gt;, thus we need to initialize it. There is tracking of the #ifdef depths to manage when some code must be included in a code fragment and when not:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;    CodeFragment code_fragment = {};
    // Cache name string
    code_fragment.name = token.text;

    for ( size_t i = 0; i &amp;lt; CodeFragment::Count; i++ ) {
        code_fragment.stage_ifdef_depth[i] = 0xffffffff;
    }

    if ( !expectToken( parser-&amp;gt;lexer, token, Token::Token_OpenBrace ) ) {
        return;
    }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Next is simply arriving at the first token that contains all the glsl code:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;    // Advance token and cache the starting point of the code.
    nextToken( parser-&amp;gt;lexer, token );
    code_fragment.code = token.text;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;And now some more parsing craftmanship.&lt;!-- raw HTML omitted --&gt;
We cannot use anymore the simple check to end parsing when encountering a closed brace, because there can be different structs defined that will break that mechanism.&lt;!-- raw HTML omitted --&gt;
Instead we track the number of open braces and when we close the last one, we consider finished the parsing of the &lt;strong&gt;code fragment&lt;/strong&gt;!&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;    uint32_t open_braces = 1;

    // Scan until close brace token
    while ( open_braces ) {

        if ( token.type == Token::Token_OpenBrace )
            ++open_braces;
        else if ( token.type == Token::Token_CloseBrace )
            --open_braces;

&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The only token that we care inside the code fragment is the &lt;strong&gt;hash&lt;/strong&gt;, signalling either an include or a define, used for separating &lt;em&gt;per-stage code&lt;/em&gt;.&lt;!-- raw HTML omitted --&gt;
The parsing of the &lt;em&gt;hash&lt;/em&gt; token will be done inside the &lt;strong&gt;directiveIdentifier&lt;/strong&gt; method:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;        // Parse hash for includes and defines
        if ( token.type == Token::Token_Hash ) {
            // Get next token and check which directive is
            nextToken( parser-&amp;gt;lexer, token );

            directiveIdentifier( parser, token, code_fragment );
        }

&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Before diving deep into the &lt;strong&gt;directive identifiers&lt;/strong&gt;, let&amp;rsquo;s finish the main parsing routine.&lt;!-- raw HTML omitted --&gt;
We advance to the next token until we close all the braces, and then save the text length of all the code fragment:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;        nextToken( parser-&amp;gt;lexer, token );
    }
    
    // Calculate code string length
    code_fragment.code.length = token.text.text - code_fragment.code.text;

&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Final step is to save the newly parsed code fragment into the parser data:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;    parser-&amp;gt;code_fragments.emplace_back( code_fragment );
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;We can now dive deep into the parsing of directives, namely #if defined, #pragma include and #endif.&lt;/p&gt;
&lt;h4 id=&#34;parsing-if-defined&#34;&gt;Parsing &amp;lsquo;#if defined&amp;rsquo;&lt;/h4&gt;
&lt;p&gt;When we encounter the &lt;strong&gt;Hash&lt;/strong&gt; token within the &lt;strong&gt;glsl&lt;/strong&gt; part, we need to parse further to understand the other keywords.&lt;!-- raw HTML omitted --&gt;
&lt;strong&gt;#if defined&lt;/strong&gt; is the most important directive for us, because it will tell the parser which &lt;strong&gt;shader stage&lt;/strong&gt; we are parsing currently and thus where to direct the text!&lt;!-- raw HTML omitted --&gt;
It starts from a common/shared stage, for shared code, and when encounters a #if defined it can signal a stage specific code.&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;p&gt;Namely when parsing the following line in HFX:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;// HFX

#(Here!)if defined VERTEX
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The parser needs to check 2 other identifiers. Remember that the parser is currently AFTER the &lt;strong&gt;Hash&lt;/strong&gt; token, as beautifully written in the previous snippet!&lt;!-- raw HTML omitted --&gt;
Let&amp;rsquo;s look at the code:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;// C++

inline void directiveIdentifier( Parser* parser, const Token&amp;amp; token, CodeFragment&amp;amp; code_fragment ) {
    
    Token new_token;
    for ( uint32_t i = 0; i &amp;lt; token.text.length; ++i ) {
        char c = *(token.text.text + i);

        switch ( c ) {
            case &#39;i&#39;:
            {
                // Search for the pattern &#39;if defined&#39;
                if ( expectKeyword( token.text, 2, &amp;quot;if&amp;quot; ) ) {
                    nextToken( parser-&amp;gt;lexer, new_token );

                    if ( expectKeyword( new_token.text, 7, &amp;quot;defined&amp;quot; ) ) {
                        nextToken( parser-&amp;gt;lexer, new_token );

                        // Use 0 as not set value for the ifdef depth.
                        ++code_fragment.ifdef_depth;

                        if ( expectKeyword( new_token.text, 6, &amp;quot;VERTEX&amp;quot; ) ) {

                            code_fragment.stage_ifdef_depth[CodeFragment::Vertex] = code_fragment.ifdef_depth;
                            code_fragment.current_stage = CodeFragment::Vertex;
                        }
                        else if ( expectKeyword( new_token.text, 8, &amp;quot;FRAGMENT&amp;quot; ) ) {

                            code_fragment.stage_ifdef_depth[CodeFragment::Fragment] = code_fragment.ifdef_depth;
                            code_fragment.current_stage = CodeFragment::Fragment;
                        }
                        else if ( expectKeyword( new_token.text, 7, &amp;quot;COMPUTE&amp;quot; ) ) {

                            code_fragment.stage_ifdef_depth[CodeFragment::Compute] = code_fragment.ifdef_depth;
                            code_fragment.current_stage = CodeFragment::Compute;
                        }
                    }

                    return;
                }
                break;
            }

&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Let&amp;rsquo;s dissect this code!&lt;/p&gt;
&lt;p&gt;Starting from the current token, just after the &lt;strong&gt;#(Hash)&lt;/strong&gt;, we need to check the correct composition of the keywords.&lt;!-- raw HTML omitted --&gt;
We expect &amp;lsquo;if&amp;rsquo;, and then if found we go to the next token:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;if ( expectKeyword( token.text, 2, &amp;quot;if&amp;quot; ) ) {
    nextToken( parser-&amp;gt;lexer, new_token );
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;We search for the &amp;lsquo;defined&amp;rsquo; identifier and if found we go to the next identifier:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;if ( expectKeyword( new_token.text, 7, &amp;quot;defined&amp;quot; ) ) {
    nextToken( parser-&amp;gt;lexer, new_token );
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The parser is currently here:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;#if defined (Here!)VERTEX
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;And thus the last step is to check which &lt;strong&gt;shader stage&lt;/strong&gt; is currently starting.
This is done here:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;if ( expectKeyword( new_token.text, 6, &amp;quot;VERTEX&amp;quot; ) ) {

    code_fragment.stage_ifdef_depth[CodeFragment::Vertex] = code_fragment.ifdef_depth;
    code_fragment.current_stage = CodeFragment::Vertex;
}

&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;In this central piece of code, we set the current stage to Vertex (because we found the keyword &amp;lsquo;VERTEX&amp;rsquo;) and we save the current ifdef depth.&lt;!-- raw HTML omitted --&gt;
Why that ? &lt;!-- raw HTML omitted --&gt;
Because when we will parse #endif, we will do the same for the open/close braces depth in the main glsl parser: we want to be sure that the defines are paired correctly and we are saving the per-stage code in the correct way!&lt;!-- raw HTML omitted --&gt;
This will be more clear when we see the #endif parsing.&lt;/p&gt;
&lt;p&gt;Moving on, we will do the same for all the other keywords (&amp;lsquo;FRAGMENT&amp;rsquo; and &amp;lsquo;COMPUTE&amp;rsquo; for now):&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;else if ( expectKeyword( new_token.text, 8, &amp;quot;FRAGMENT&amp;quot; ) ) {

    code_fragment.stage_ifdef_depth[CodeFragment::Fragment] = code_fragment.ifdef_depth;
    code_fragment.current_stage = CodeFragment::Fragment;
}
else if ( expectKeyword( new_token.text, 7, &amp;quot;COMPUTE&amp;quot; ) ) {

    code_fragment.stage_ifdef_depth[CodeFragment::Compute] = code_fragment.ifdef_depth;
    code_fragment.current_stage = CodeFragment::Compute;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;And the parsing of &lt;strong&gt;#if defined&lt;/strong&gt; is over!&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;h4 id=&#34;parsing-pragma-include&#34;&gt;Parsing &amp;lsquo;#pragma include&amp;rsquo;&lt;/h4&gt;
&lt;p&gt;In HFX we are parsing the following:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;// HFX

#pragma include &amp;quot;Platform.h&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;With the following code (inside &lt;em&gt;directiveIdentifier&lt;/em&gt; method):&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;// C++

case &#39;p&#39;:
{
    if ( expectKeyword( token.text, 6, &amp;quot;pragma&amp;quot; ) ) {
        nextToken( parser-&amp;gt;lexer, new_token );

        if ( expectKeyword( new_token.text, 7, &amp;quot;include&amp;quot; ) ) {
            nextToken( parser-&amp;gt;lexer, new_token );

            code_fragment.includes.emplace_back( new_token.text );
            code_fragment.includes_stage.emplace_back( code_fragment.current_stage );
        }

        return;
    }
    break;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This is simply saving the filename after the include, that being surrounded by &amp;quot;&amp;quot; is classified as string, and is using the current stage to know which stage should include that file!&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;h4 id=&#34;parsing-endif&#34;&gt;Parsing &amp;lsquo;#endif&amp;rsquo;&lt;/h4&gt;
&lt;p&gt;Final part is the &lt;strong&gt;#endif&lt;/strong&gt; identifier:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;case &#39;e&#39;:
{
    if ( expectKeyword( token.text, 5, &amp;quot;endif&amp;quot; ) ) {

        if ( code_fragment.stage_ifdef_depth[CodeFragment::Vertex] == code_fragment.ifdef_depth ) {
            
            code_fragment.stage_ifdef_depth[CodeFragment::Vertex] = 0xffffffff;
            code_fragment.current_stage = CodeFragment::Common;
        }
        else if ( code_fragment.stage_ifdef_depth[CodeFragment::Fragment] == code_fragment.ifdef_depth ) {

            code_fragment.stage_ifdef_depth[CodeFragment::Fragment] = 0xffffffff;
            code_fragment.current_stage = CodeFragment::Common;
        }
        else if ( code_fragment.stage_ifdef_depth[CodeFragment::Compute] == code_fragment.ifdef_depth ) {

            code_fragment.stage_ifdef_depth[CodeFragment::Compute] = 0xffffffff;
            code_fragment.current_stage = CodeFragment::Common;
        }

        --code_fragment.ifdef_depth;

        return;
    }
    break;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This is mirroring the &lt;strong&gt;#if defined&lt;/strong&gt; and simply goes back to set the current stage to common/shared and reset the per-stage ifdef depth.&lt;/p&gt;
&lt;p&gt;We can now proceed to the final part of the parsing, the &lt;strong&gt;passes&lt;/strong&gt;!&lt;!-- raw HTML omitted --&gt;
This is the glue to generate the different files from the code fragments.&lt;/p&gt;
&lt;h3 id=&#34;parsing-pass&#34;&gt;Parsing &amp;lsquo;pass&amp;rsquo;&lt;/h3&gt;
&lt;p&gt;Reading the HFX file, we are now in the final part of the file:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;// HFX

pass ToScreen {
   vertex = ToScreen
   fragment = ToScreen
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;A pass is simply a collection of &lt;strong&gt;code fragments&lt;/strong&gt; associated with each shader stage (vertex, fragment, compute).&lt;!-- raw HTML omitted --&gt;
When we parsed the fragments, we saved them in the parser to be retrieved.&lt;/p&gt;
&lt;p&gt;To refresh our memory, this is the actual &lt;strong&gt;Pass struct&lt;/strong&gt; in C++:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;// C++

struct Pass {

    StringRef                   name;

    const CodeFragment*         vs                  = nullptr;
    const CodeFragment*         fs                  = nullptr;
    const CodeFragment*         cs                  = nullptr;

}; // struct Pass
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Going back to the main directive method, we call the &lt;strong&gt;declarationPass&lt;/strong&gt; method when we encounter the &amp;lsquo;pass&amp;rsquo; identifier.&lt;!-- raw HTML omitted --&gt;
We will parse the following line:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;// HFX

pass ToScreen {
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;With the following code (similar to everything else, it should be easier to read now):&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;// C++

inline void declarationPass( Parser* parser ) {

    Token token;
    if ( !expectToken( parser-&amp;gt;lexer, token, Token::Token_Identifier ) ) {
        return;
    }

    Pass pass = {};
    // Cache name string
    pass.name = token.text;

    if ( !expectToken( parser-&amp;gt;lexer, token, Token::Token_OpenBrace ) ) {
        return;
    }

&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;After we saved the pass name we can start reading the individual stages using the &lt;strong&gt;passIdentifier&lt;/strong&gt; method:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;    while ( !equalToken( parser-&amp;gt;lexer, token, Token::Token_CloseBrace ) ) {
        passIdentifier( parser, token, pass );
    }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;And then save the newly parsed pass.&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;    parser-&amp;gt;passes.emplace_back( pass );
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;For each identifier now, we will check which stage we are parsing.&lt;!-- raw HTML omitted --&gt;
Currently we are here, after the open brace and all the whitespace:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;// HFX

pass ToScreen {
   (Here!)vertex = ToScreen
   fragment = ToScreen
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;What is next is thus checking the identifier and filling the corresponding &lt;strong&gt;shader stage&lt;/strong&gt; of the &lt;strong&gt;pass&lt;/strong&gt;.&lt;!-- raw HTML omitted --&gt;
I will post all the code of the method, because is similar to most code we seen and should be straightforward:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;// C++

inline void passIdentifier( Parser* parser, const Token&amp;amp; token, Pass&amp;amp; pass ) {
    // Scan the name to know which stage we are parsing    
    for ( uint32_t i = 0; i &amp;lt; token.text.length; ++i ) {
        char c = *(token.text.text + i);

        switch ( c ) {
            
            case &#39;c&#39;:
            {
                if ( expectKeyword( token.text, 7, &amp;quot;compute&amp;quot;) ) {
                    declarationShaderStage( parser, &amp;amp;pass.cs );
                    return;
                }
                break;
            }

            case &#39;v&#39;:
            {
                if ( expectKeyword( token.text, 6, &amp;quot;vertex&amp;quot; ) ) {
                    declarationShaderStage( parser, &amp;amp;pass.vs );
                    return;
                }
                break;
            }

            case &#39;f&#39;:
            {
                if ( expectKeyword( token.text, 8, &amp;quot;fragment&amp;quot; ) ) {
                    declarationShaderStage( parser, &amp;amp;pass.fs );
                    return;
                }
                break;
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The real &amp;lsquo;magic&amp;rsquo; here is the &amp;lsquo;declarationShaderStage&amp;rsquo; method.&lt;!-- raw HTML omitted --&gt;
This method parses the couple &amp;lsquo;identifier&amp;rsquo; &amp;lsquo;=&amp;rsquo; &amp;lsquo;identifier&amp;rsquo;, and searches the &lt;strong&gt;code fragment&lt;/strong&gt; with the same name:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;inline void declarationShaderStage( Parser* parser, const CodeFragment** out_fragment ) {

    Token token;
    if ( !expectToken( parser-&amp;gt;lexer, token, Token::Token_Equals ) ) {
        return;
    }

    if ( !expectToken( parser-&amp;gt;lexer, token, Token::Token_Identifier ) ) {
        return;
    }

    *out_fragment = findCodeFragment( parser, token.text );
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;After all the stages of the current pass are parsed, we save the pass and finish parsing the file!&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;h1 id=&#34;shader-permutation-generation&#34;&gt;Shader Permutation Generation&lt;/h1&gt;
&lt;p&gt;The final step of this amazing journey is the simplest, and it is actually to generate the single files we need.&lt;!-- raw HTML omitted --&gt;
In our case another specific class, &lt;strong&gt;CodeGenerator&lt;/strong&gt;, will generate the different files from the parsed HFX file.&lt;/p&gt;
&lt;p&gt;After we&amp;rsquo;ve done with the parsing, we can call the &lt;strong&gt;generateShaderPermutations&lt;/strong&gt; method that will generate files for each shader stage in each pass:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;void generateShaderPermutations( CodeGenerator* code_generator, const char* path ) {

    code_generator-&amp;gt;string_buffer_0.clear();
    code_generator-&amp;gt;string_buffer_1.clear();
    code_generator-&amp;gt;string_buffer_2.clear();

    // For each pass and for each pass generate permutation file.
    const uint32_t pass_count = (uint32_t)code_generator-&amp;gt;parser-&amp;gt;passes.size();
    for ( uint32_t i = 0; i &amp;lt; pass_count; i++ ) {

        // Create one file for each code fragment
        const Pass&amp;amp; pass = code_generator-&amp;gt;parser-&amp;gt;passes[i];
        
        if ( pass.cs ) {
            outputCodeFragment( code_generator, path, CodeFragment::Compute, pass.cs );
        }

        if ( pass.fs ) {
            outputCodeFragment( code_generator, path, CodeFragment::Fragment, pass.fs );
        }

        if ( pass.vs ) {
            outputCodeFragment( code_generator, path, CodeFragment::Vertex, pass.vs );
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The code should be straightforward, and the real action happens into the &lt;strong&gt;outputCodeFragment&lt;/strong&gt; method.&lt;!-- raw HTML omitted --&gt;
Let&amp;rsquo;s have a look at the code.&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;p&gt;First we define some data, like the file extensions for each shader stage or the defines to compile the code:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;// Additional data to be added to output shaders.
static const char*              s_shader_file_extension[CodeFragment::Count] = { &amp;quot;.vert&amp;quot;, &amp;quot;.frag&amp;quot;, &amp;quot;.compute&amp;quot;, &amp;quot;.h&amp;quot; };
static const char*              s_shader_stage_defines[CodeFragment::Count] = { &amp;quot;#define VERTEX\r\n&amp;quot;, &amp;quot;#define FRAGMENT\r\n&amp;quot;, &amp;quot;#define COMPUTE\r\n&amp;quot;, &amp;quot;&amp;quot; };
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Then we start to write the file.&lt;!-- raw HTML omitted --&gt;
We will use the &lt;em&gt;string_buffer_0&lt;/em&gt; to dynamically generate the path of the file without allocating memory:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;void outputCodeFragment( CodeGenerator* code_generator, const char* path, CodeFragment::Stage stage, const CodeFragment* code_fragment ) {
    // Create file
    FILE* output_file;

    code_generator-&amp;gt;string_buffer_0.clear();
    code_generator-&amp;gt;string_buffer_0.append( path );
    code_generator-&amp;gt;string_buffer_0.append( code_fragment-&amp;gt;name );
    code_generator-&amp;gt;string_buffer_0.append( s_shader_file_extension[stage] );
    fopen_s( &amp;amp;output_file, code_generator-&amp;gt;string_buffer_0.data, &amp;quot;wb&amp;quot; );

    if ( !output_file ) {
        printf( &amp;quot;Error opening file. Aborting. \n&amp;quot; );
        return;
    }

&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;And then use &lt;em&gt;string_buffer_1&lt;/em&gt; to instead generate the actual code into the file.&lt;!-- raw HTML omitted --&gt;
First, and most important, we will add all the includes for this particular stage by opening the file, reading it into memory and adding it into the final code buffer.&lt;/p&gt;
&lt;p&gt;We will still use &lt;em&gt;string_buffer_0&lt;/em&gt; to generate the path of the file:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;    code_generator-&amp;gt;string_buffer_1.clear();

    // Append includes for the current stage.
    for ( size_t i = 0; i &amp;lt; code_fragment-&amp;gt;includes.size(); i++ ) {
        if ( code_fragment-&amp;gt;includes_stage[i] != stage &amp;amp;&amp;amp; code_fragment-&amp;gt;includes_stage[i] != CodeFragment::Common ) {
            continue;
        }

        // Open and read file
        code_generator-&amp;gt;string_buffer_0.clear();
        code_generator-&amp;gt;string_buffer_0.append( path );
        code_generator-&amp;gt;string_buffer_0.append( code_fragment-&amp;gt;includes[i] );
        char* include_code = ReadEntireFileIntoMemory( code_generator-&amp;gt;string_buffer_0.data, nullptr );

        code_generator-&amp;gt;string_buffer_1.append( include_code );
        code_generator-&amp;gt;string_buffer_1.append( &amp;quot;\r\n&amp;quot; );
    }

&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;After that is done we can copy the define needed for the current shader stage:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;    code_generator-&amp;gt;string_buffer_1.append( &amp;quot;\t\t&amp;quot; );
    code_generator-&amp;gt;string_buffer_1.append( s_shader_stage_defines[stage] );

&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;And finally the actual code:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;    code_generator-&amp;gt;string_buffer_1.append( &amp;quot;\r\n\t\t&amp;quot; );
    code_generator-&amp;gt;string_buffer_1.append( code_fragment-&amp;gt;code );

&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Write to file and close it and we are done!&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;    fprintf( output_file, &amp;quot;%s&amp;quot;, code_generator-&amp;gt;string_buffer_1.data );

    fclose( output_file );
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;And this will generate the shader permutations for each pass with a single file, using the standard GLSL convention for files extensions.&lt;/p&gt;
&lt;h1 id=&#34;conclusions-and-next-part&#34;&gt;Conclusions and next part&lt;/h1&gt;
&lt;p&gt;We parsed our simple &lt;em&gt;shader language&lt;/em&gt; to enhance and embed &lt;em&gt;glsl&lt;/em&gt; code fragments into our codebase by generating single files that can be used into any OpenGL based renderer.&lt;!-- raw HTML omitted --&gt;
We also laid out the foundation for a more powerful tool - namely code generation - even though there are some intermediate steps to be taken to arrive there.&lt;!-- raw HTML omitted --&gt;
First of all, we will need a target rendering library (something like the amazing &lt;a href=&#34;https://github.com/floooh/sokol&#34;&gt;Sokol&lt;/a&gt;), so we can specialize our CPU rendering code. I already wrote something like Sokol but with a more Vulkan/D3D12 interface in mind, and I will use that. Still unsure if I will write a specific post on that.&lt;/p&gt;
&lt;p&gt;In the next article we will add support for the new graphics library and develop the language more to generate code that will manage Constant buffers, automatically creating a CPU-side class, adding UI to edit it in realtime and possibly load/save the values.&lt;/p&gt;
&lt;p&gt;Of course, any feedback/improvements/suggestions on anything related here (article, code, etc) please let me know.&lt;/p&gt;
&lt;p&gt;Stay tuned!
Gabriel&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
